Translate the C Code to Rust. 
You need to translate the macro only.
Notice that: 
Remember when translating macros, add `pub(crate)` to the macro definition to make it visible.
When using another macros in C, you should use macros in Rust with the same name. For example, `#define MY_MACRO ANOTHER_MACRO(ANOTHER_MACRO2)` should be translated to `macro_rules! MY_MACRO { () => { ANOTHER_MACRO!(ANOTHER_MACRO2!()) } }\n pub(crate) use MY_MACRO;`. Notice that C original macros, like __FILE__ and __LINE__, should also be translated to __FILE__!() and __LINE__!() in Rust.
Any expression as a condition of `if` or `while` or ternary operator should be append with `.as_bool()` method in Rust. For example, `(MyFunc(1)) ? 1 : 0` should be translated to `if MyFunc(1).as_bool() { 1 } else { 0 }`.
When using the C string literals, use cstr! macro to translate it to Rust. For example, `#define MY_STR "Hello, World!"` should be translated to `macro_rules! MY_STR { () => { cstr!("Hello, World!") } }\n pub(crate) use MY_STR;`.
When translating a macro that represents NULL pointer, use NULL!() macro in Rust. For example, `#define MY_NULL 0` should be translated to `macro_rules! MY_NULL { () => { NULL!() } }\n pub(crate) use MY_NULL;`. If it represents true or false, just use the numbers in C, for example, `#define MY_TRUE 1` should be translated to `macro_rules! MY_TRUE { () => { 1 } }\n pub(crate) use MY_TRUE;`, and `#define MY_FALSE 0` should be translated to `macro_rules! MY_FALSE { () => { 0 } }\n pub(crate) use MY_FALSE;`.
When using global variables that start with `g_`, use the lock() method to get reference of the variable. For example, `int a = g_a;` should be translated to `let mut a = (*g_a.lock());`, and `g_a = 10;` should be translated to `(*g_a.lock()) = 10;`.
When find a C reference operator `&`, use c_ref! macro to translate it to Rust. For example, `int a = &b;` should be translated to `let mut a = c_ref!(b);`.
If the original number literal in C has type, like `10U`, just ignore it and translate to Rust number without types directly, i.e. `10`. For example, `#define MY_NUM 10U` should be translated to `macro_rules! MY_NUM { () => { 10 } }\n pub(crate) use MY_NUM;`. However, if it is explicitly casted, like `(size_t)10`, you should translate it to Rust with the cast, with original `isize` literal, i.e. `(10isize as usize)`. 

Source:
```c
#define MY_NUMA 10U
```

Translation:
```rust
macro_rules! MY_NUMA { () => { 10 } }
pub(crate) use MY_NUMA;
```

Source:
```c
#define MY_NUMB 10LL
```

Translation:
```rust
macro_rules! MY_NUMB { () => { 10 } }
pub(crate) use MY_NUMB;
```

Source:
```c
#define MY_FFFF 0xffffL
```

Translation:
```rust
macro_rules! MY_FFFF { () => { 0xffff } }
pub(crate) use MY_FFFF;
```

Source:
```c
#define MYHEX 0x30
```

Translation:
```rust
macro_rules! MYHEX { () => { 0x30 } }
pub(crate) use MYHEX;
```

Source:
```c
#define MY_MALLOC_8 malloc(8)
```

Translation:
```rust
macro_rules! MY_MALLOC_8 { () => { malloc(8) } }
pub(crate) use MY_MALLOC_8;
```

Source:
```c
#define MY_NULL 0
```

Translation:
```rust
macro_rules! MY_NULL { () => { NULL!() } }
pub(crate) use MY_NULL;
```

Source:
```c
#define MY_EOK 0
```

Translation:
```rust
macro_rules! MY_EOK { () => { 0 } }
pub(crate) use MY_EOK;
```

Source:
```c
#define MY_NEG (uint8_t)~0
```

Translation:
```rust
macro_rules! MY_NEG { () => { (!0isize) as u8 } }
pub(crate) use MY_NEG;
```

Source:
```c
#define MY_SELECTION (MY_CONDITION!()) ? MY_SELECTION_TRUE : MY_SELECTION_FALSE
```

Translation:
```rust
macro_rules! MY_SELECTION { () => { if MY_CONDITION!().as_bool() > 10 { MY_SELECTION_TRUE!() } else { MY_SELECTION_FALSE!() } } }
pub(crate) use MY_SELECTION;
```

Source:
```c
#define MY_U8_MINUS (uint8_t)-1
```

Translation:
```rust
macro_rules! MY_U8_MINUS { () => { (-1isize) as u8 } }
```

Source:
```c
#define MY_CALL_FUNC_WITH_CHAR My_calledFunc('a')
```

Translation:
```rust
macro_rules! MY_CALL_FUNC_WITH_CHAR { () => { My_calledFunc(b'a' as u8) } }
```