{
    "All": 128,
    "Compilation Pass": 58,
    "Compilation Error": 70,
    "Pass Rate": 0.453125,
    "Error Information": [
        {
            "c_code": "static inline uint32_t CmptLzGetNumProbs(CmptLzDecProt *decProt)\n    {\n\n        return (NUM_BASE_PROBS + ((uint32_t)0x300 << (decProt->litCtx + decProt->litPos)));\n    }",
            "rust_code": "pub fn CmptLzGetNumProbs(mut decProt: Ptr<CmptLzDecProt>) -> u32 {\n    return (NUM_BASE_PROBS!() + (0x300 << (decProt.litCtx + decProt.litPos)).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104504089)\nerror: mismatched closing delimiter: `}`\n   --> src/src/decode/cmptlz_dec_inner_h.rs:270:12\n    |\n269 | pub fn CmptLzGetNumProbs(mut decProt: Ptr<CmptLzDecProt>) -> u32 {\n    |                                                                  - closing delimiter possibly meant for this\n270 |     return (NUM_BASE_PROBS!() + (0x300 << (decProt.litCtx + decProt.litPos)).cast();\n    |            ^ unclosed delimiter\n271 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                                      EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n\n    decCtx->remainLen = 0;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecCtxPrepare(mut decCtx: Ptr<CmptLzDecCtx>, mut pSrcIn: Ptr<u8>, mut srcInLen: usize, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut readCodeLen: usize = CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize;\n    readCodeLen = if srcInLen < readCodeLen { srcInLen } else { readCodeLen };\n    while (readCodeLen.suffix_minus_minus() > 0).as_bool() {\n        decCtx.tempBuf[decCtx.tempBufSize] = *pSrcIn;\n        decCtx.tempBufSize += 1;\n        pSrcIn += 1;\n    }\n\n    if (decCtx.tempBufSize != 0).as_bool() && (decCtx.tempBuf[0] != 0).as_bool() {\n        decCtx.tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n        return CMPT_ERROR_DATA!();\n    }\n    if (decCtx.tempBufSize < CMPTLZ_RANGE_CODE_SIZE!()).as_bool() {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    CmptLzRangeCodeInit(decCtx.cast());\n\n    if (decCtx.remainLen > CMPTLZ_MATCH_MAX_LEN!() + 1).as_bool() {\n        CmptLzDecGetProbsInit(decCtx.cast());\n        decCtx.reps[0] = 1;\n        decCtx.reps[1] = 1;\n        decCtx.reps[2] = 1;\n        decCtx.reps[3] = 1;\n    }\n\n    decCtx.remainLen = 0;\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104505016)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_c.rs:64:34\n   |\n64 |     let mut readCodeLen: usize = CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize;\n   |                          -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |                          |\n   |                          expected due to this\n   |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n64 |     let mut readCodeLen: usize = (CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize).try_into().unwrap();\n   |                                  +                                              +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}",
            "rust_code": "pub fn CmptLzDecDecodeToDic(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut pSrcIn: Ptr<u8>, mut pStrInLen: Ptr<usize>, mut finMode: EnCmptLzFinMode, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut res: i32;\n    let mut carefulDecDone: bool = false;\n    let mut srcDecLenTmp: usize = Default::default();\n    let mut srcDecLen: usize = 0;\n    let mut srcInLen: usize = *pStrInLen;\n\n    if (decCtx.remainLen > CMPTLZ_MATCH_MAX_LEN!()).as_bool() {\n        let mut oldTempBufSize: usize = decCtx.tempBufSize.cast();\n        res = CmptLzDecCtxPrepare(decCtx.cast(), pSrcIn.cast(), srcInLen.cast(), finStatus.cast()).cast();\n        srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize).cast();\n        if (res != CMPT_OK!()).as_bool() || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT!()).as_bool() {\n            *pStrInLen = srcDecLenTmp.cast();\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx.tempBufSize = 0;\n    }\n\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()).as_bool() {\n        if (decCtx.code != 0).as_bool() {\n            return CMPT_ERROR_DATA!();\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n\n    if (decCtx.remainLen != 0).as_bool() {\n        CmptLzDecRemWriteInDict(decCtx.cast(), dicPosLimit.cast());\n    }\n\n    if (decCtx.tempBufSize != 0).as_bool() {\n        res = CmptLzDecSinglePacket(decCtx.cast(), dicPosLimit.cast(), pSrcIn.cast(), srcInLen.cast(), c_ref!(srcDecLenTmp).cast()).cast();\n        *pStrInLen = srcDecLenTmp.cast();\n        if (res == CMPT_ERROR_DATA!()).as_bool() {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n            return CMPT_ERROR_DATA!();\n        } else if (res == CMPTLZ_DEC_INPUT_EOF!()).as_bool() {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n            return CMPT_OK!();\n        } else {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while (decCtx.dictPos < dicPosLimit).as_bool() && (carefulDecDone == false).as_bool() {\n        decCtx.buf = pSrcIn.cast();\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX!()).as_bool() {\n            res = CmptLzDecCarefulProcess(decCtx.cast(), dicPosLimit.cast(), (pSrcIn + srcInLen).cast()).cast();\n            carefulDecDone = true;\n        } else {\n            res = CmptLzDecDirectProcess(decCtx.cast(), dicPosLimit.cast(), (pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX!()).cast()).cast();\n        }\n        srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA!()).as_bool() {\n            *pStrInLen = srcDecLen.cast();\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n            return CMPT_ERROR_DATA!();\n        }\n    }\n\n    *pStrInLen = srcDecLen.cast();\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()).as_bool() && (decCtx.code == 0).as_bool() {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n    if (decCtx.dictPos < dicPosLimit).as_bool() {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen == 0).as_bool() && (decCtx.code == 0).as_bool() {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK!();\n        return CMPT_OK!();\n    }\n    if (finMode == CMPTLZ_FINISH_ANY!()).as_bool() {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen != 0).as_bool() {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n        return CMPT_ERROR_DATA!();\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx.cast(), dicPosLimit.cast(), pSrcIn.cast(), srcInLen.cast(), c_ref!(srcDecLenTmp).cast()).cast();\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen.cast();\n    if (res == CMPTLZ_DEC_INPUT_EOF!()).as_bool() {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()).as_bool() && (decCtx.code == 0).as_bool() {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n    return CMPT_ERROR_DATA!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104505222)\nerror[E0659]: `CMPTLZ_REQUIRED_INPUT_MAX` is ambiguous\n   --> src/src/decode/cmptlz_dec_c.rs:119:25\n    |\n119 |         if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX!()).as_bool() {\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ ambiguous name\n    |\n    = note: ambiguous because of multiple glob imports of a name in the same module\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:2:9\n    |\n2   | pub use crate::src::decode::cmptlz_dec_inner_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could also refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:3:9\n    |\n3   | pub use crate::src::public::cmptlz_log_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\n\nerror[E0659]: `CMPTLZ_REQUIRED_INPUT_MAX` is ambiguous\n   --> src/src/decode/cmptlz_dec_c.rs:123:98\n    |\n123 | ...   res = CmptLzDecDirectProcess(decCtx.cast(), dicPosLimit.cast(), (pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX!()).cast()).cast();\n    |                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ ambiguous name\n    |\n    = note: ambiguous because of multiple glob imports of a name in the same module\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:2:9\n    |\n2   | pub use crate::src::decode::cmptlz_dec_inner_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could also refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:3:9\n    |\n3   | pub use crate::src::public::cmptlz_log_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_c.rs:78:46\n   |\n78 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize).cast();\n   |                                              ^^^^^^^^^^^^^^ expected `u32`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `u32`\n  --> src/src/decode/cmptlz_dec_c.rs:78:44\n   |\n78 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize).cast();\n   |                                            ^ no implementation for `u32 - usize`\n   |\n   = help: the trait `std::ops::Sub<usize>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n             `&u32` implements `std::ops::Sub<u32>`\n             `&u32` implements `std::ops::Sub`\n             `u32` implements `std::ops::Sub<&u32>`\n             `u32` implements `std::ops::Sub<types::num::Num>`\n             `u32` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_c.rs:125:64\n    |\n125 |         srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n    |                                                                ^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot add `u32` to `usize`\n   --> src/src/decode/cmptlz_dec_c.rs:125:62\n    |\n125 |         srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n    |                                                              ^ no implementation for `usize + u32`\n    |\n    = help: the trait `std::ops::Add<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Add<Rhs>`:\n              `&usize` implements `std::ops::Add<usize>`\n              `&usize` implements `std::ops::Add`\n              `usize` implements `std::ops::Add<&usize>`\n              `usize` implements `std::ops::Add<types::num::Num>`\n              `usize` implements `std::ops::Add`\n\nSome errors have detailed explanations: E0277, E0308, E0659.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "int CmptLzDecDecodeToBuf(CmptLzDecCtx *decCtx, CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, EnCmptLzFinMode finMode,\n                         EnCmptLzStatus *finStatus)\n{\n    int res = CMPT_OK;\n    size_t dictPos;\n    size_t dictPosLimit;\n    size_t srcCostSize;\n\n    size_t leftSrcSize = pDecIn->strInLen;\n    size_t leftDestSize = pDecOut->destOutLen;\n    const unsigned char *pSrcIn = pDecIn->pSrcIn;\n    unsigned char *pDestOut = pDecOut->pDestOut;\n    EnCmptLzFinMode tmpFinMode;\n\n    do\n    {\n        if (decCtx->dictPos == decCtx->dictBufSize)\n        {\n            decCtx->dictPos = 0;\n        }\n        dictPos = decCtx->dictPos;\n        if (leftDestSize > decCtx->dictBufSize - dictPos)\n        {\n            dictPosLimit = decCtx->dictBufSize;\n            tmpFinMode = CMPTLZ_FINISH_ANY;\n        }\n        else\n        {\n            dictPosLimit = dictPos + leftDestSize;\n            tmpFinMode = finMode;\n        }\n        srcCostSize = leftSrcSize;\n        res = CmptLzDecDecodeToDic(decCtx, dictPosLimit, pSrcIn, &srcCostSize, tmpFinMode, finStatus);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n        pSrcIn += srcCostSize;\n        leftSrcSize -= srcCostSize;\n        dictPosLimit = decCtx->dictPos - dictPos;\n        leftDestSize -= dictPosLimit;\n        if (dictPosLimit == 0)\n        {\n            break;\n        }\n        if (memcpy_s(pDestOut, (pDecOut->destOutLen - leftDestSize), decCtx->dict + dictPos, dictPosLimit) != EOK)\n        {\n            return CMPT_ERROR_MEM;\n        }\n        pDestOut += dictPosLimit;\n    } while (leftDestSize != 0);\n\n    pDecIn->strInCostLen = pDecIn->strInLen - leftSrcSize;\n    pDecOut->destOutFillLen = pDecOut->destOutLen - leftDestSize;\n\n    return res;\n}",
            "rust_code": "pub fn CmptLzDecDecodeToBuf(mut decCtx: Ptr<CmptLzDecCtx>, mut pDecIn: Ptr<CmptLzDecIn>, mut pDecOut: Ptr<CmptLzDecOut>, mut finMode: EnCmptLzFinMode, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut res: i32 = CMPT_OK!();\n    let mut dictPos: usize;\n    let mut dictPosLimit: usize;\n    let mut srcCostSize: usize;\n\n    let mut leftSrcSize: usize = pDecIn.strInLen.cast();\n    let mut leftDestSize: usize = pDecOut.destOutLen.cast();\n    let mut pSrcIn: Ptr<u8> = pDecIn.pSrcIn.cast();\n    let mut pDestOut: Ptr<u8> = pDecOut.pDestOut.cast();\n    let mut tmpFinMode: EnCmptLzFinMode;\n\n    c_do!({\n        if (decCtx.dictPos == decCtx.dictBufSize).as_bool() {\n            decCtx.dictPos = 0;\n        }\n        dictPos = decCtx.dictPos.cast();\n        if (leftDestSize > decCtx.dictBufSize - dictPos).as_bool() {\n            dictPosLimit = decCtx.dictBufSize.cast();\n            tmpFinMode = CMPTLZ_FINISH_ANY!();\n        } else {\n            dictPosLimit = dictPos + leftDestSize;\n            tmpFinMode = finMode.cast();\n        }\n        srcCostSize = leftSrcSize.cast();\n        res = CmptLzDecDecodeToDic(decCtx.cast(), dictPosLimit.cast(), pSrcIn.cast(), c_ref!(srcCostSize).cast(), tmpFinMode.cast(), finStatus.cast()).cast();\n        if (res != CMPT_OK!()).as_bool() {\n            break;\n        }\n        pSrcIn += srcCostSize;\n        leftSrcSize -= srcCostSize;\n        dictPosLimit = (decCtx.dictPos - dictPos).cast();\n        leftDestSize -= dictPosLimit;\n        if (dictPosLimit == 0).as_bool() {\n            break;\n        }\n        if (c_memcpy_s!(pDestOut, (pDecOut.destOutLen - leftDestSize).cast(), decCtx.dict + dictPos, dictPosLimit) != EOK!()).as_bool() {\n            return CMPT_ERROR_MEM!();\n        }\n        pDestOut += dictPosLimit;\n    } while (leftDestSize != 0);\n\n    pDecIn.strInCostLen = (pDecIn.strInLen - leftSrcSize).cast();\n    pDecOut.destOutFillLen = (pDecOut.destOutLen - leftDestSize).cast();\n\n    return res.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104505432)\nerror: mismatched closing delimiter: `}`\n   --> src/src/decode/cmptlz_dec_c.rs:92:10\n    |\n80  | pub fn CmptLzDecDecodeToBuf(mut decCtx: Ptr<CmptLzDecCtx>, mut pDecIn: Ptr<CmptLzDecIn>, mut pDecOut: Ptr<CmptLzDecOut>, mut finMode: EnCmptLzFinMode, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    |                                                                                                                                                                                                   - closing delimiter possibly meant for this\n...\n92  |     c_do!({\n    |          ^ unclosed delimiter\n...\n126 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptlzDecompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzDecParam *param)\n{\n    if (src == NULL || dst == NULL || dstSize == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The input parameter NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"dstSize:0x%zx srcSize:0x%zx\", *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (param == NULL || param->memHook == NULL || param->protData == NULL || param->protSize != CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The compress param NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecIn decIn = {.pSrcIn = src, .strInLen = srcSize, .strInCostLen = 0};\n    CmptLzDecOut decOut = {.pDestOut = dst, .destOutLen = *dstSize, .destOutFillLen = 0};\n    EnCmptLzStatus enFinStat = CMPTLZ_STATUS_BUT;\n    int ret = CmptLzDecode(&decIn, &decOut, param->protData, CMPTLZ_FINISH_ANY, &enFinStat, param->memHook);\n\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}",
            "rust_code": "pub fn CmptlzDecompress(mut src: Ptr<Void>, mut srcSize: usize, mut dst: Ptr<Void>, mut dstSize: Ptr<usize>, mut param: Ptr<CmptlzDecParam>) -> i32 {\n    if (src == NULL!()).as_bool() || (dst == NULL!()).as_bool() || (dstSize == NULL!()).as_bool() {\n        CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The input parameter NULL is incorrect.\"));\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    if (srcSize > 0x7fffffff).as_bool() || (*dstSize > 0x7fffffff).as_bool() {\n        CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"dstSize:0x%zx srcSize:0x%zx\"), *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    if (param == NULL!()).as_bool() || (param.memHook == NULL!()).as_bool() || (param.protData == NULL!()).as_bool() || (param.protSize != CMPTLZ_PROPS_SIZE!()).as_bool() {\n        CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The compress param NULL is incorrect.\"));\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    let mut decIn: CmptLzDecIn = CmptLzDecIn {\n        pSrcIn: src.cast(),\n        strInLen: srcSize,\n        strInCostLen: 0,\n    };\n    let mut decOut: CmptLzDecOut = CmptLzDecOut {\n        pDestOut: dst.cast(),\n        destOutLen: *dstSize,\n        destOutFillLen: 0,\n    };\n    let mut enFinStat: EnCmptLzStatus = CMPTLZ_STATUS_BUT!();\n    let mut ret: i32 = CmptLzDecode(c_ref!(decIn).cast(), c_ref!(decOut).cast(), param.protData.cast(), CMPTLZ_FINISH_ANY!(), c_ref!(enFinStat).cast(), param.memHook.cast()).cast();\n\n    *dstSize = decOut.destOutFillLen.cast();\n    return ret.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104505503)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/decode/cmptlz_dec_c.rs:87:9\n   |\n87 |         CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The input parameter NULL is incorrect.\"));\n   |         --------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:14:39\n   |\n14 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[$(&$args), *]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/decode/cmptlz_dec_c.rs:92:9\n   |\n92 |         CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"dstSize:0x%zx srcSize:0x%zx\"), *dstSize, srcSize);\n   |         ----------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/decode/cmptlz_dec_c.rs:97:9\n   |\n97 |         CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The compress param NULL is incorrect.\"));\n   |         -------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "static inline int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzPropsDecode(mut protData: Ptr<u8>, mut protSize: u32, mut decProt: Ptr<CmptLzDecProt>) -> i32 {\n    let mut dictSize: u32;\n\n    if (protSize < CMPTLZ_PROPS_SIZE!()).as_bool() {\n        return CMPT_ERROR_UNSUPPORTED!();\n    } else {\n        dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN!()).as_bool() {\n        dictSize = CMPTLZ_DICT_MIN_LEN!();\n    }\n    decProt.dicSize = dictSize.cast();\n\n    let mut firstData: u8 = protData[0].cast();\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX!() * CMPTLZ_POS_STATE_MAX!() * CMPTLZ_LIT_POS_MAX!())).as_bool() {\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    decProt.litCtx = (firstData % CMPTLZ_LIT_CTX_MAX!()).cast();\n    firstData /= CMPTLZ_LIT_CTX_MAX!();\n    decProt.posBits = (firstData / CMPTLZ_POS_STATE_MAX!()).cast();\n    decProt.litPos = (firstData % CMPTLZ_LIT_POS_MAX!()).cast();\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104505722)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:35\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:33\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                 ^ no implementation for `u8 | u32`\n   |\n   = help: the trait `BitOr<u32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n             `&u8` implements `BitOr<u8>`\n             `&u8` implements `BitOr`\n             `u8` implements `BitOr<&u8>`\n             `u8` implements `BitOr`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:65\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:63\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                               ^ no implementation for `u8 | u32`\n   |\n   = help: the trait `BitOr<u32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n             `&u8` implements `BitOr<u8>`\n             `&u8` implements `BitOr`\n             `u8` implements `BitOr<&u8>`\n             `u8` implements `BitOr`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:96\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:94\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                                                              ^ no implementation for `u8 | u32`\n   |\n   = help: the trait `BitOr<u32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n             `&u8` implements `BitOr<u8>`\n             `&u8` implements `BitOr`\n             `u8` implements `BitOr<&u8>`\n             `u8` implements `BitOr`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "static inline void *CmptLzDecMemAlloc(CmptLzMemHook *memHook, int32_t memHandle, size_t allocSize)\n{\n    return memHook->CmptLzAlloc(memHandle, allocSize);\n}",
            "rust_code": "pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> Ptr<Void> {\n    return memHook.CmptLzAlloc(memHandle.cast(), allocSize.cast());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104506138)\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/decode/cmptlz_dec_init_c.rs:43:20\n   |\n43 |     return memHook.CmptLzAlloc(memHandle.cast(), allocSize.cast());\n   |                    ^^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzAlloc` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n   |\n43 |     return (memHook.CmptLzAlloc)(memHandle.cast(), allocSize.cast());\n   |            +                   +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}",
            "rust_code": "pub fn CmptLzDecMemFree(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut freeAddress: Ptr<Void>) {\n    memHook.CmptLzFree(memHandle.cast(), freeAddress.cast());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104506346)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/decode/cmptlz_dec_init_c.rs:48:13\n   |\n48 |     memHook.CmptLzFree(memHandle.cast(), freeAddress.cast());\n   |             ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n48 |     (memHook.CmptLzFree)(memHandle.cast(), freeAddress.cast());\n   |     +                  +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecAllocateProbs(mut decCtx: Ptr<CmptLzDecCtx>, mut decProt: Ptr<CmptLzDecProt>, mut memHook: Ptr<CmptLzMemHook>) -> i32 {\n    let mut numProbs: u32 = CmptLzGetNumProbs(decProt.cast()).cast();\n\n    if (decCtx.probs == NULL!()).as_bool() {\n        decCtx.probs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n    } else {\n        if (numProbs != decCtx.numProbs).as_bool() {\n            CmptLzDecFreeProbs(decCtx.cast(), memHook.cast());\n            decCtx.probs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n        }\n    }\n\n    if (decCtx.probs == NULL!()).as_bool() {\n        return CMPT_ERROR_MEM!();\n    }\n\n    decCtx.probsPlus1664 = (decCtx.probs + 1664).cast();\n    decCtx.numProbs = numProbs.cast();\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104506976)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:72:81\n   |\n72 | ...obs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n   |          -----------------                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |          |\n   |          arguments to this function are incorrect\n   |\nnote: function defined here\n  --> src/src/decode/cmptlz_dec_init_c.rs:42:8\n   |\n42 | pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> Ptr<Void> {\n   |        ^^^^^^^^^^^^^^^^^                                                      --------------------\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n72 |         decCtx.probs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), (numProbs * c_sizeof!(CmptLzDecProb)).try_into().unwrap()).cast::<Ptr<CmptLzDecProb>>();\n   |                                                                                 +                                   +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:76:85\n   |\n76 | ...obs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n   |          -----------------                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |          |\n   |          arguments to this function are incorrect\n   |\nnote: function defined here\n  --> src/src/decode/cmptlz_dec_init_c.rs:42:8\n   |\n42 | pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> Ptr<Void> {\n   |        ^^^^^^^^^^^^^^^^^                                                      --------------------\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n76 |             decCtx.probs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), (numProbs * c_sizeof!(CmptLzDecProb)).try_into().unwrap()).cast::<Ptr<CmptLzDecProb>>();\n   |                                                                                     +                                   +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int CmptLzDecAllocate(CmptLzDecCtx *decCtx, const unsigned char *protData, unsigned protSize, CmptLzMemHook *memHook)\n{\n    int res;\n    uint32_t dictMask;\n    size_t dictBufSize;\n    CmptLzDecProt decProt;\n\n    if ((decCtx == NULL) || (protData == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    res = CmptLzPropsDecode(protData, protSize, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    uint32_t dictSize = decProt.dicSize;\n    if (dictSize >= ((uint32_t)1 << CMPTLZ_BIG_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE) - 1;\n    }\n    else if (dictSize >= ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_SMALL_DICT_LG_SIZE) - 1;\n    }\n    else\n    {\n        dictMask = CMPTLZ_DICT_MIN_LEN - 1;\n    }\n\n    dictBufSize = ((size_t)dictSize + dictMask) & ~dictMask;\n    if (dictBufSize < dictSize)\n    {\n        dictBufSize = dictSize;\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n    }\n    else\n    {\n        if (dictBufSize != decCtx->dictBufSize)\n        {\n            CmptLzFreeDict(decCtx, memHook);\n            decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n        }\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        CmptLzDecFreeProbs(decCtx, memHook);\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->dictBufSize = dictBufSize;\n    decCtx->prop = decProt;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecAllocate(mut decCtx: Ptr<CmptLzDecCtx>, mut protData: Ptr<u8>, mut protSize: u32, mut memHook: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n    let mut dictMask: u32;\n    let mut dictBufSize: usize;\n    let mut decProt: CmptLzDecProt = Default::default();\n\n    if (decCtx == NULL!()).as_bool() || (protData == NULL!()).as_bool() || (memHook == NULL!()).as_bool() {\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    res = CmptLzPropsDecode(protData.cast(), protSize.cast(), c_ref!(decProt).cast()).cast();\n    if (res != CMPT_OK!()).as_bool() {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(decCtx.cast(), c_ref!(decProt).cast(), memHook.cast()).cast();\n    if (res != CMPT_OK!()).as_bool() {\n        return res;\n    }\n\n    let mut dictSize: u32 = decProt.dicSize.cast();\n    if (dictSize >= (1 << CMPTLZ_BIG_DICT_LG_SIZE!()).cast()).as_bool() {\n        dictMask = ((1 << CMPTLZ_MID_DICT_LG_SIZE!()) - 1).cast();\n    } else if (dictSize >= (1 << CMPTLZ_MID_DICT_LG_SIZE!()).cast()).as_bool() {\n        dictMask = ((1 << CMPTLZ_SMALL_DICT_LG_SIZE!()) - 1).cast();\n    } else {\n        dictMask = (CMPTLZ_DICT_MIN_LEN!() - 1).cast();\n    }\n\n    dictBufSize = ((dictSize + dictMask) & !dictMask).cast::<usize>();\n    if (dictBufSize < dictSize.cast()).as_bool() {\n        dictBufSize = dictSize.cast();\n    }\n\n    if (decCtx.dict == NULL!()).as_bool() {\n        decCtx.dict = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_DICT_HANDLE!(), dictBufSize.cast()).cast::<Ptr<u8>>();\n    } else {\n        if (dictBufSize != decCtx.dictBufSize.cast()).as_bool() {\n            CmptLzFreeDict(decCtx.cast(), memHook.cast());\n            decCtx.dict = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_DICT_HANDLE!(), dictBufSize.cast()).cast::<Ptr<u8>>();\n        }\n    }\n\n    if (decCtx.dict == NULL!()).as_bool() {\n        CmptLzDecFreeProbs(decCtx.cast(), memHook.cast());\n        return CMPT_ERROR_MEM!();\n    }\n\n    decCtx.dictBufSize = dictBufSize.cast();\n    decCtx.prop = decProt.cast();\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104507182)\nerror[E0277]: the trait bound `cmptlz_dec_h::CmptLzDecProt: CastInto<cmptlz_dec_h::CmptLzDecProt>` is not satisfied\n   --> src/src/decode/cmptlz_dec_init_c.rs:121:27\n    |\n121 |     decCtx.prop = decProt.cast();\n    |                           ^^^^ the trait `integer::Integer` is not implemented for `cmptlz_dec_h::CmptLzDecProt`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `cmptlz_dec_h::CmptLzDecProt` to implement `cast_trait::CastFrom<cmptlz_dec_h::CmptLzDecProt>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `cmptlz_dec_h::CmptLzDecProt` to implement `CastInto<cmptlz_dec_h::CmptLzDecProt>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptLzDecode(CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, const unsigned char *protData, EnCmptLzFinMode finMode,\n                 EnCmptLzStatus *finStatus, CmptLzMemHook *memHook)\n{\n    int res;\n    size_t inSize = pDecIn->strInLen;\n    CmptLzDecProt decProt;\n    CmptLzDecCtx decCtx;\n    decCtx.numProbs = 0;\n\n    if (inSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecConstruct(&decCtx);\n    res = CmptLzPropsDecode(protData, CMPTLZ_PROPS_SIZE, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(&decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    decCtx.prop = decProt;\n    decCtx.dict = pDecOut->pDestOut;\n    decCtx.dictBufSize = pDecOut->destOutLen;\n    CmptLzDecInit(&decCtx);\n\n    *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n    res = CmptLzDecDecodeToDic(&decCtx, pDecOut->destOutLen, pDecIn->pSrcIn, &inSize, finMode, finStatus);\n    pDecIn->strInCostLen = inSize;\n    pDecOut->destOutFillLen = decCtx.dictPos;\n    CmptLzDecFreeProbs(&decCtx, memHook);\n\n    return res;\n}",
            "rust_code": "pub fn CmptLzDecode(mut pDecIn: Ptr<CmptLzDecIn>, mut pDecOut: Ptr<CmptLzDecOut>, mut protData: Ptr<u8>, mut finMode: EnCmptLzFinMode, mut finStatus: Ptr<EnCmptLzStatus>, mut memHook: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n    let mut inSize: usize = pDecIn.strInLen.cast();\n    let mut decProt: CmptLzDecProt = Default::default();\n    let mut decCtx: CmptLzDecCtx = Default::default();\n    decCtx.numProbs = 0;\n\n    if (inSize < CMPTLZ_PROPS_SIZE!()).as_bool() {\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    CmptLzDecConstruct(c_ref!(decCtx).cast());\n    res = CmptLzPropsDecode(protData.cast(), CMPTLZ_PROPS_SIZE!(), c_ref!(decProt).cast()).cast();\n    if (res != CMPT_OK!()).as_bool() {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(c_ref!(decCtx).cast(), c_ref!(decProt).cast(), memHook.cast()).cast();\n    if (res != CMPT_OK!()).as_bool() {\n        return res;\n    }\n\n    decCtx.prop = decProt.cast();\n    decCtx.dict = pDecOut.pDestOut.cast();\n    decCtx.dictBufSize = pDecOut.destOutLen.cast();\n    CmptLzDecInit(c_ref!(decCtx).cast());\n\n    *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n    res = CmptLzDecDecodeToDic(c_ref!(decCtx).cast(), pDecOut.destOutLen.cast(), pDecIn.pSrcIn.cast(), c_ref!(inSize).cast(), finMode.cast(), finStatus.cast()).cast();\n    pDecIn.strInCostLen = inSize.cast();\n    pDecOut.destOutFillLen = decCtx.dictPos.cast();\n    CmptLzDecFreeProbs(c_ref!(decCtx).cast(), memHook.cast());\n\n    return res.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104507815)\nerror[E0277]: the trait bound `cmptlz_dec_h::CmptLzDecProt: CastInto<cmptlz_dec_h::CmptLzDecProt>` is not satisfied\n   --> src/src/decode/cmptlz_dec_init_c.rs:117:27\n    |\n117 |     decCtx.prop = decProt.cast();\n    |                           ^^^^ the trait `integer::Integer` is not implemented for `cmptlz_dec_h::CmptLzDecProt`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `cmptlz_dec_h::CmptLzDecProt` to implement `cast_trait::CastFrom<cmptlz_dec_h::CmptLzDecProt>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `cmptlz_dec_h::CmptLzDecProt` to implement `CastInto<cmptlz_dec_h::CmptLzDecProt>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                         uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                         const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzTryDecLenAndDist(mut decCtx: Ptr<CmptLzDecCtx>, mut mkState: u32, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut probSlot: Ptr<CmptLzDecProb>, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut offset: u32;\n    let mut bits2BeDec: u32;\n    let mut pbMask: u32 = ((1 as u32) << (decCtx.prop.posBits)) - 1;\n    let mut posState: u32 = CMPTLZ_CALC_POS_STATE!(decCtx.processedPos, pbMask);\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n    let mut probBit: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    probLen = probSlot + CMPTLZ_LEN_CHOICE!();\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n    if (rangeCode < rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    } else {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n        if (rangeCode < rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n    let mut decSym: u32 = 1;\n    c_do!({\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    } while decSym < ((1 as u32) << bits2BeDec));\n    decSym -= ((1 as u32) << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4).as_bool() {\n        *pbufLimit = bufTryDec.cast();\n        return CMPT_OK!();\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix.cast()) + CmptLzGetLenCondition(decSym.cast());\n\n    decSym = 1;\n    c_do!({\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    } while decSym < (1 << CMPTLZ_POS_SLOT_BITS!()));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS!());\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT!()).as_bool() {\n        if (decSym < CMPTLZ_HIGH_POSSLOT!()).as_bool() {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix.cast()) + (CmptLzGetBaseDistByPosSlot(decSym.cast()) << bits2BeDec);\n        } else {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS!();\n            c_do!({\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while bits2BeDec.suffix_minus_minus() > 0);\n            probSlot = CmptLzGetAilgnProb(probsMatrix.cast());\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS!();\n        }\n\n        decSym = 1;\n        offset = 1;\n        c_do!({\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n            if (rangeCode < rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while bits2BeDec.suffix_minus_minus() > 0);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104508018)\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:79:5\n   |\n79 |     probLen = probSlot + CMPTLZ_LEN_CHOICE!();\n   |     ^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n79 |     let probLen = probSlot + CMPTLZ_LEN_CHOICE!();\n   |     +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:80:55\n   |\n80 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n   |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:83:9\n   |\n83 |         probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n   |         ^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n83 |         let probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n   |         +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:90:9\n   |\n90 |         probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n   |         ^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n90 |         let probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n   |         +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:91:59\n   |\n91 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n   |                                                           ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:94:13\n   |\n94 |             probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n   |             ^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n94 |             let probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n   |             +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n  --> src/src/decode/cmptlz_dec_try_c.rs:99:13\n   |\n99 |             probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n   |             ^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n99 |             let probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n   |             +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n   --> src/src/decode/cmptlz_dec_try_c.rs:109:19\n    |\n109 |         probBit = probLen + decSym;\n    |                   ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n78 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |     ------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                        ^^ no implementation for `u32 |= u8`\n...\n78 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |     ------------------------------------------------------------------ in this macro invocation\n   |\n   = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n             `u32` implements `BitOrAssign<&u32>`\n             `u32` implements `BitOrAssign`\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n88 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                        ^^ no implementation for `u32 |= u8`\n...\n88 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n             `u32` implements `BitOrAssign<&u32>`\n             `u32` implements `BitOrAssign`\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n105 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n105 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:63\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                               ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n110 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:61\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                             ^ no implementation for `u32 * u16`\n...\n110 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n111 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n111 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:63\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                               ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n126 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:61\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                             ^ no implementation for `u32 * u16`\n...\n126 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n127 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n127 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n138 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n138 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n149 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n149 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:151:61\n    |\n151 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n    |                                                             ^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:151:59\n    |\n151 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n    |                                                           ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n164 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n164 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 30 previous errors\n"
        },
        {
            "c_code": "static inline int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                        const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzTryDecLitPacket(mut decCtx: Ptr<CmptLzDecCtx>, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut probBit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n    let mut procPos: u32 = decCtx.processedPos.cast();\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> decCtx.prop.litCtx);\n\n    let mut dictBufSize: usize = decCtx.dictBufSize.cast();\n    let mut dicPos: usize = decCtx.dictPos.cast();\n    let mut dict: Ptr<u8> = decCtx.dict.cast();\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n\n    if (decCtx.dictPos >= decCtx.dictBufSize).as_bool() {\n        return CMPT_ERROR_DATA!();\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix.cast());\n    if (procPos != 0).as_bool() || (decCtx.checkDicSize != 0).as_bool() {\n        probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask)\n                                   << decCtx.prop.litCtx;\n    }\n\n    let mut decSym: u32 = 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()).as_bool() {\n        c_do!({\n            probBit = (probSlot + decSym).cast();\n            CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    } else {\n        let mut bit: u32 = Default::default();\n        let mut matchSym: u32 = dict[dicPos - decCtx.reps[0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })].cast();\n        let mut offset: u32 = 0x100;\n        c_do!({\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = (probSlot + (offset + bit + decSym)).cast();\n            CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104508251)\nerror: mismatched closing delimiter: `}`\n  --> src/src/decode/cmptlz_dec_try_c.rs:92:34\n   |\n91 |     if (procPos != 0).as_bool() || (decCtx.checkDicSize != 0).as_bool() {\n   |                                                                         - closing delimiter possibly meant for this\n92 |         probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask)\n   |                                  ^ unclosed delimiter\n93 |                                    << decCtx.prop.litCtx;\n94 |     }\n   |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}",
            "rust_code": "pub fn CmptLzTryDecOnePacket(mut decCtx: Ptr<CmptLzDecCtx>, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut rangeBound: u32 = 0;\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut mkState: u32 = decCtx.state;\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probSlot1: Ptr<CmptLzDecProb>;\n    let mut probSlot2: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n\n    let mut pbMask: u32 = ((1).cast::<u32>() << decCtx.prop.posBits) - 1;\n    let mut posState: u32 = CMPTLZ_CALC_POS_STATE!(decCtx.processedPos, pbMask);\n\n    probSlot1 = (CmptLzGetIsMatchProb(probsMatrix.cast()) + posState + mkState).cast();\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1);\n    if (rangeCode < rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx.cast(), range.cast(), rangeCode.cast(), rangeBound.cast(), bufTryDec.cast(), pbufLimit.cast()).cast();\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = (CmptLzGetIsRepProb(probsMatrix.cast()) + mkState).cast();\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2);\n    if (rangeCode < rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix.cast()).cast();\n        mkState = 0;\n    } else {\n        if (decCtx.dictPos >= decCtx.dictBufSize).as_bool() {\n            return CMPT_ERROR_DATA!();\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = (CmptLzGetIsRepG0Prob(probsMatrix.cast()) + mkState).cast();\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n        if (rangeCode < rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = (CmptLzGetIsRepG0LongProb(probsMatrix.cast()) + posState + mkState).cast();\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n            if (rangeCode < rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec.cast();\n                return CMPT_OK!();\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            }\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = (CmptLzGetIsRepG1Prob(probsMatrix.cast()) + mkState).cast();\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n            if (rangeCode < rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = (CmptLzGetIsRepG2Prob(probsMatrix.cast()) + mkState).cast();\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n                if (rangeCode < rangeBound).as_bool() {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                } else {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix.cast()).cast();\n        mkState = CMPTLZ_MKSTATE_NUM!();\n    }\n    return CmptLzTryDecLenAndDist(decCtx.cast(), mkState.cast(), range.cast(), rangeCode.cast(), rangeBound.cast(), probSlot.cast(), bufTryDec.cast(), pbufLimit.cast()).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104508324)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:95:53\n   |\n95 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1);\n   |                                                     ^^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n  --> src/src/decode/cmptlz_dec_try_c.rs:95:51\n   |\n95 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1);\n   |                                                   ^ no implementation for `u32 * u16`\n   |\n   = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n             `&u32` implements `std::ops::Mul<u32>`\n             `&u32` implements `std::ops::Mul`\n             `u32` implements `std::ops::Mul<&u32>`\n             `u32` implements `std::ops::Mul<Duration>`\n             `u32` implements `std::ops::Mul<types::num::Num>`\n             `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n98 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                        ^^ no implementation for `u32 |= u8`\n...\n98 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n             `u32` implements `BitOrAssign<&u32>`\n             `u32` implements `BitOrAssign`\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n103 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n103 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:106:53\n    |\n106 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2);\n    |                                                     ^^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:106:51\n    |\n106 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2);\n    |                                                   ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n116 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n116 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:119:57\n    |\n119 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                         ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:119:55\n    |\n119 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                       ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n122 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n122 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:125:61\n    |\n125 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                             ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:125:59\n    |\n125 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                           ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n128 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n128 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n136 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n136 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:139:61\n    |\n139 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                             ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:139:59\n    |\n139 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                           ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n144 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n144 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:147:65\n    |\n147 |                 rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                                 ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:147:63\n    |\n147 |                 rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n    |                                                               ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 26 previous errors\n"
        },
        {
            "c_code": "int CmptLzDecCarefulProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    int res = CMPT_OK;\n    uint32_t remainLen;\n    const unsigned char *bufLimitTmp;\n    const unsigned char *pSrcIn;\n\n    do\n    {\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx->buf;\n\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, &bufLimitTmp);\n        if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if ((res != CMPT_OK) || (decCtx->buf != bufLimitTmp))\n        {\n            return CMPT_ERROR_DATA;\n        }\n        if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n        {\n            break;\n        }\n    } while (decCtx->dictPos < dicPosLimit);\n\n    if ((res == CMPTLZ_DEC_INPUT_EOF) && (decCtx->buf < bufLimit))\n    {\n        remainLen = (uint32_t)(bufLimit - decCtx->buf);\n        decCtx->tempBufSize = remainLen;\n        for (uint32_t idx = 0; idx < remainLen; idx++)\n        {\n            decCtx->tempBuf[idx] = decCtx->buf[idx];\n        }\n    }\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecCarefulProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    let mut res: i32 = CMPT_OK!();\n    let mut remainLen: u32;\n    let mut bufLimitTmp: Ptr<u8>;\n    let mut pSrcIn: Ptr<u8>;\n\n    c_do!({\n        bufLimitTmp = bufLimit.cast();\n        pSrcIn = decCtx.buf.cast();\n\n        res = CmptLzTryDecOnePacket(decCtx.cast(), pSrcIn.cast(), c_ref!(bufLimitTmp).cast()).cast();\n        if (res == CMPTLZ_DEC_INPUT_EOF!()).as_bool() {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx.cast(), dicPosLimit.cast(), bufLimitTmp.cast()).cast();\n        if (res != CMPT_OK!()).as_bool() || (decCtx.buf != bufLimitTmp).as_bool() {\n            return CMPT_ERROR_DATA!();\n        }\n        if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()).as_bool() {\n            break;\n        }\n    } while (decCtx.dictPos < dicPosLimit).as_bool();\n\n    if (res == CMPTLZ_DEC_INPUT_EOF!()).as_bool() && (decCtx.buf < bufLimit).as_bool() {\n        remainLen = (bufLimit - decCtx.buf).cast::<u32>();\n        decCtx.tempBufSize = remainLen.cast();\n        c_for!(let mut idx: u32 = 0; idx < remainLen; idx.suffix_plus_plus(); {\n            decCtx.tempBuf[idx] = decCtx.buf[idx].cast();\n        });\n    }\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104508533)\nerror: mismatched closing delimiter: `}`\n   --> src/src/decode/cmptlz_dec_try_c.rs:90:10\n    |\n84  | pub fn CmptLzDecCarefulProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    |                                                                                                                     - closing delimiter possibly meant for this\n...\n90  |     c_do!({\n    |          ^ unclosed delimiter\n...\n116 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}",
            "rust_code": "pub fn CmptLzDistDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probsMatrix: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut decLen: u32) -> usize {\n    let mut assistBits: u32;\n    let mut posSlot: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf.cast();\n    let mut distDec: u32;\n\n    let mut probPosSlot: Ptr<CmptLzDecProb> = CmptLzGetPosSlotProb(probsMatrix.cast()) + CmptLzGetLenCondition(decLen.cast());\n\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < CMPTLZ_POS_SLOT_BITS!().cast(); i.suffix_plus_plus(); {\n        CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    });\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT!()).as_bool() {\n        distDec = posSlot.cast();\n        CmptLzDistDecHelper(decCtx.cast(), distDec.cast(), bufToDec.cast(), pRange.cast(), pRangeCode.cast(), pRangeBound.cast(), range.cast(), rangeCode.cast(), rangeBound.cast());\n\n        if (distDec == 0xFFFFFFFF.cast::<usize>()).as_bool() {\n            return distDec.cast();\n        } else {\n            return (distDec + 1).cast();\n        }\n    }\n\n    let mut directBitNum: u32 = ((posSlot >> 1) - 1).cast();\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot.cast()).cast();\n    if (posSlot < CMPTLZ_HIGH_POSSLOT!()).as_bool() {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix.cast());\n        c_do!({\n            if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while directBitNum.prefix_minus_minus() > 0);\n        distDec -= assistBits;\n    } else {\n        directBitNum -= CMPTLZ_REP4!();\n        c_do!({\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((rangeCode >> 31).cast::<u32>())).cast();\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while directBitNum.prefix_minus_minus() > 0);\n\n        let mut probDist: Ptr<CmptLzDecProb>;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix.cast());\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS!();\n        assistBits = 1;\n\n        let mut cycleSym: u32 = 1;\n        c_for!(i = 0; i < 3; i.suffix_plus_plus(); {\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        });\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probDist = (probPosSlot + assistBits).cast();\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n        if (rangeCode < rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probDist, range, rangeBound);\n            assistBits -= 8;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx.cast(), distDec.cast(), bufToDec.cast(), pRange.cast(), pRangeCode.cast(), pRangeBound.cast(), range.cast(), rangeCode.cast(), rangeBound.cast());\n\n    if (distDec == 0xFFFFFFFF.cast::<usize>()).as_bool() {\n        return distDec.cast();\n    } else {\n        return (distDec + 1).cast();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104509039)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound).as_bool() {\n    |                --------------------------------------------------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound);.as_bool() {\n    |                                                                                           +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:59\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:57\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:24\n    |\n161 |         if (distDec == 0xFFFFFFFF.cast::<usize>()).as_bool() {\n    |             -------    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n    |             |\n    |             expected because this is `u32`\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n161 |         if (distDec == 0xFFFFFFFF.cast::<usize>().try_into().unwrap()).as_bool() {\n    |                                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound).as_bool() {\n    |                --------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:177:92\n    |\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound).as_bool() {\n    |                                                                                            ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound).as_bool() {\n    |                --------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n179 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n179 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n184 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n184 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n193 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n193 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n209 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n209 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:95:59\n    |\n95  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n210 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n    |             ----------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:95:57\n    |\n95  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n210 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n    |             ----------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n213 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n213 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:215:57\n    |\n215 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n    |                                                         ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:215:55\n    |\n215 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n    |                                                       ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n222 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n222 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:228:20\n    |\n228 |     if (distDec == 0xFFFFFFFF.cast::<usize>()).as_bool() {\n    |         -------    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n    |         |\n    |         expected because this is `u32`\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n228 |     if (distDec == 0xFFFFFFFF.cast::<usize>().try_into().unwrap()).as_bool() {\n    |                                              ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 26 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    return decLen;\n}",
            "rust_code": "pub fn CmptLzLenDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probSlot: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut posState: u32) -> u32 {\n    let mut decLen: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf.cast();\n    let mut probLen: Ptr<CmptLzDecProb> = (probSlot + CMPTLZ_LEN_CHOICE!()).cast();\n\n    let mut i: i32 = 0;\n    if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_0!(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probLen = (probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState).cast();\n        c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT!().cast(); i.suffix_plus_plus(); {\n            CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n        });\n        decLen -= 8;\n    } else {\n        CMPTLZ_RANGE_UPDATE_1!(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n        probLen = (probSlot + CMPTLZ_LEN_CHOICE2!()).cast();\n        if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n            probLen = (probSlot + (CMPTLZ_LEN_CHOICE2!() + posState)).cast();\n            c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT!().cast(); i.suffix_plus_plus(); {\n                CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n            });\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n            probLen = (probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!()).cast();\n            c_for!(i = 0; i < CMPTLZ_HIGH_LEN_BIT!().cast(); i.suffix_plus_plus(); {\n                CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n            });\n            decLen -= CMPTLZ_HIGH_LEN_CLASS!();\n            decLen += (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        }\n    }\n\n    *pRange = range.cast();\n    *pRangeCode = rangeCode.cast();\n    *pRangeBound = rangeBound.cast();\n    decCtx.buf = bufToDec.cast();\n\n    return decLen.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104509258)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |        ----------------------------------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                   +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |            ----------------------------------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                       +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |        ----------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:154:68\n    |\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |                                                                    ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |        ----------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n156 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n156 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n159 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n    |             ---------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n159 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n    |             ---------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n164 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n164 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |            ----------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:167:72\n    |\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |                                                                        ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |            ----------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n169 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n169 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n173 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 ---------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n173 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 ---------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n177 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n177 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n181 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 ---------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n181 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen).cast(), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 ---------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 22 previous errors; 2 warnings emitted\n"
        },
        {
            "c_code": "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n    let mut dicCopyPos: usize;\n    let mut dicPos: usize = decCtx.dictPos.cast();\n    let mut dictBufSize: usize = decCtx.dictBufSize.cast();\n    let mut remainDicLen: u32 = (dicPosLimit - dicPos).cast();\n    let mut dict: Ptr<u8> = decCtx.dict.cast();\n\n    if (remainDicLen == 0).as_bool() {\n        return CMPT_ERROR_DATA!();\n    }\n\n    let mut decDicLen: u32 = if remainDicLen < matchLen { remainDicLen } else { matchLen };\n    decCtx.processedPos += decDicLen.cast();\n    decCtx.dictPos += decDicLen.cast();\n    decCtx.remainLen = (matchLen - decDicLen).cast();\n\n    if (dicPos < matchDist).as_bool() {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    } else {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    c_do!({\n        dict[dicPos] = dict[dicCopyPos].cast();\n        dicPos += 1;\n        dicCopyPos += 1;\n        if (dicCopyPos == dictBufSize).as_bool() {\n            dicCopyPos = 0;\n        }\n    } while decDicLen.suffix_minus_minus() != 0);\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104509501)\nerror[E0308]: mismatched types\n   --> src/include/cmptlz_base_h.rs:160:52\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/decode/cmptlz_dec_process_c.rs:150:129\n    |\n150 | pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n    |                                                                                                                                 --- expected `u32` because of return type\n...\n158 |         return CMPT_ERROR_DATA!();\n    |                ------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n    |                                                    +                                               +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}",
            "rust_code": "pub fn CmptLzShortRepDec(mut decCtx: Ptr<CmptLzDecCtx>) {\n    let mut rep0: u32 = decCtx.reps[0].cast();\n    let mut dict: Ptr<u8> = decCtx.dict.cast();\n    let mut dictPos: usize = decCtx.dictPos.cast();\n    let mut dictBufSize: usize = decCtx.dictBufSize.cast();\n\n    dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    decCtx.dictPos += 1;\n    decCtx.processedPos += 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()).as_bool() {\n        decCtx.state = 9;\n    } else {\n        decCtx.state = 11;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104509719)\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:36\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    |                                    ^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:34\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    |                                  ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:56\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    |                                              -------   ^^^^ expected `usize`, found `u32`\n    |                                              |\n    |                                              expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0.try_into().unwrap() { dictBufSize } else { 0 }].cast();\n    |                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                                    size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}",
            "rust_code": "pub fn CmptLzRepDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n    let mut repLen: u32;\n    let mut repDist: u32;\n    let mut mkState: u32 = decCtx.state.cast();\n    let mut bufToDec: Ptr<u8> = decCtx.buf.cast();\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix.cast()) + mkState;\n    if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix.cast()) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            *pRange = range.cast();\n            *pRangeCode = rangeCode.cast();\n            *pRangeBound = rangeBound.cast();\n            decCtx.buf = bufToDec.cast();\n            CmptLzShortRepDec(decCtx.cast());\n            return CMPT_OK!();\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[0].cast();\n        }\n    } else {\n        CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix.cast()) + mkState;\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[1].cast();\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix.cast()) + mkState;\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP2!()].cast();\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP3!()].cast();\n                decCtx.reps[CMPTLZ_REP3!()] = decCtx.reps[CMPTLZ_REP2!()].cast();\n            }\n            decCtx.reps[CMPTLZ_REP2!()] = decCtx.reps[1].cast();\n        }\n        decCtx.reps[1] = decCtx.reps[0].cast();\n        decCtx.reps[0] = repDist.cast();\n    }\n\n    *pRange = range.cast();\n    *pRangeCode = rangeCode.cast();\n    *pRangeBound = rangeBound.cast();\n    decCtx.buf = bufToDec.cast();\n\n    decCtx.state = if mkState < CMPTLZ_LIT_STATES!() { 8 } else { 11 };\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix.cast());\n    repLen = CmptLzLenDec(decCtx.cast(), probSlot.cast(), pRange.cast(), pRangeCode.cast(), pRangeBound.cast(), posState.cast()).cast();\n\n    return CmptLzDecByDistAndLen(decCtx.cast(), repDist.cast(), (repLen + 2).cast(), dicPosLimit.cast()).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104509929)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |        ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                    +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                            +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |        ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:173:69\n    |\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                     ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |        ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n175 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n175 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:178:73\n    |\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                         ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n180 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n180 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n189 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n189 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:197:73\n    |\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                         ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n199 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n199 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n203 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n203 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:206:77\n    |\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                             ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n208 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n208 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n212 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n212 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 32 previous errors; 4 warnings emitted\n"
        },
        {
            "c_code": "static inline uint32_t CmptLzMatchDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode,\n                                      uint32_t *pRangeBound, size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t matchLen;\n    size_t matchDist;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n    if (matchDist > decCtx->dictBufSize)\n    {\n        if (matchDist == (size_t)0xFFFFFFFF)\n        {\n            decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN;\n            decCtx->state -= CMPTLZ_MKSTATE_NUM;\n            return CMPT_OK;\n        }\n        else\n        {\n            return CMPT_ERROR_DATA;\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, matchLen + 2, dicPosLimit);\n}",
            "rust_code": "pub fn CmptLzMatchDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n    let mut matchLen: u32 = Default::default();\n    let mut matchDist: usize = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix.cast());\n    matchLen = CmptLzLenDec(decCtx.cast(), probSlot.cast(), pRange.cast(), pRangeCode.cast(), pRangeBound.cast(), posState.cast()).cast();\n    matchDist = CmptLzDistDec(decCtx.cast(), probsMatrix.cast(), pRange.cast(), pRangeCode.cast(), pRangeBound.cast(), matchLen.cast()).cast();\n    if (matchDist > decCtx.dictBufSize).as_bool() {\n        if (matchDist == 0xFFFFFFFF).as_bool() {\n            decCtx.remainLen = CMPTLZ_MATCH_MAX_LEN!();\n            decCtx.state -= CMPTLZ_MKSTATE_NUM!();\n            return CMPT_OK!();\n        } else {\n            return CMPT_ERROR_DATA!();\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx.cast(), matchDist.cast(), (matchLen + 2).cast(), dicPosLimit.cast()).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104510153)\nerror[E0308]: mismatched types\n   --> src/include/cmptlz_base_h.rs:160:52\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/decode/cmptlz_dec_process_c.rs:165:175\n    |\n165 | ...chDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u3...\n    |                                                                                                                                                                  --- expected `u32` because of return type\n...\n180 | ...rn CMPT_ERROR_DATA!();\n    |       ------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n    |                                                    +                                               +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzLitDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>) -> u32 {\n    let mut decSym: u32 = 1;\n    let mut mkState: u32 = decCtx.state.cast();\n    let mut procPos: u32 = decCtx.processedPos.cast();\n    let mut checkDicSize: u32 = decCtx.checkDicSize.cast();\n    let mut litCtx: u32 = decCtx.prop.litCtx.cast();\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> litCtx);\n\n    let mut probLit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n\n    let mut bufToDec: Ptr<u8> = decCtx.buf.cast();\n    let mut dict: Ptr<u8> = decCtx.dict.cast();\n    let mut dictBufSize: usize = decCtx.dictBufSize.cast();\n    let mut dictPos: usize = decCtx.dictPos.cast();\n\n    let mut range: u32 = *pRange;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut rangeCode: u32 = *pRangeCode;\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix.cast());\n    if (procPos != 0).as_bool() || (checkDicSize != 0).as_bool() {\n        probSlot += (CMPTLZ_REP3!() as u32) *\n                    ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx);\n    }\n\n    let mut i: i32 = 0;\n    if (mkState < CMPTLZ_LIT_STATES!()).as_bool() {\n        mkState -= if (mkState < 4).as_bool() { mkState } else { 3 };\n        c_for!(i = 0; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_NORMAL_BIT_DEC!((probSlot + decSym).cast(), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        });\n    } else {\n        let mut bit: u32 = Default::default();\n        let mut offset: u32 = 0x100;\n        let mut rep0: u32 = decCtx.reps[0].cast();\n        let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n        mkState -= if (mkState < 10).as_bool() { CMPTLZ_REP3!() } else { 6 };\n        c_for!(i = 0; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        });\n    }\n\n    *pRange = range.cast();\n    *pRangeCode = rangeCode.cast();\n    *pRangeBound = rangeBound.cast();\n\n    dict[dictPos] = decSym.cast::<u8>();\n    dictPos += 1;\n    decCtx.processedPos += 1;\n    decCtx.state = mkState.cast();\n    decCtx.dictPos = dictPos.cast();\n    decCtx.buf = bufToDec.cast();\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104510372)\nerror: expected expression, found `$`\n   --> src/src/decode/cmptlz_dec_process_c.rs:76:9\n    |\n76  |         $probLit = $probSlot + ($offset + $bit + $decSym);\n    |         ^^^^^^^^ expected expression\n...\n211 |             CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n    |             ------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_MATCH_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:194:41\n    |\n194 |                     ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx);\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n   --> src/src/decode/cmptlz_dec_process_c.rs:194:39\n    |\n194 |                     ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx);\n    |                                       ^ no implementation for `u32 + u8`\n    |\n    = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Add<Rhs>`:\n              `&u32` implements `std::ops::Add<u32>`\n              `&u32` implements `std::ops::Add`\n              `u32` implements `std::ops::Add<&u32>`\n              `u32` implements `std::ops::Add<types::num::Num>`\n              `u32` implements `std::ops::Add`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n202 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n202 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:208:48\n    |\n208 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                                ^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/decode/cmptlz_dec_process_c.rs:208:46\n    |\n208 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                              ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:208:70\n    |\n208 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                                            -------   ^^^^ expected `usize`, found `u32`\n    |                                                            |\n    |                                                            expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n208 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0.try_into().unwrap()).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                                                          ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
        },
        {
            "c_code": "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n\n    return (int)decRes;\n}",
            "rust_code": "pub fn CmptLzDecDirectProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    let mut decRes: u32;\n    let mut pbMask: u32 = ((1).cast::<u32>() << decCtx.prop.posBits) - 1;\n    let mut procPos: u32;\n    let mut mkState: u32;\n    let mut posState: u32;\n\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut rangeBound: u32 = 0;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx.cast());\n\n    c_do!({\n        procPos = decCtx.processedPos;\n        mkState = decCtx.state;\n        posState = CMPTLZ_CALC_POS_STATE!(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix.cast()) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n            decRes = CmptLzLitDec(decCtx.cast(), c_ref!(range).cast(), c_ref!(rangeCode).cast(), c_ref!(rangeBound).cast()).cast();\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix.cast()) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n                decRes = CmptLzMatchDec(decCtx.cast(), c_ref!(range).cast(), c_ref!(rangeCode).cast(), c_ref!(rangeBound).cast(), dicPosLimit.cast(), posState.cast()).cast();\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n                decRes = CmptLzRepDec(decCtx.cast(), c_ref!(range).cast(), c_ref!(rangeCode).cast(), c_ref!(rangeBound).cast(), dicPosLimit.cast(), posState.cast()).cast();\n            }\n            if (decRes != CMPT_OK!()).as_bool() {\n                break;\n            }\n        }\n    } while (decCtx.dictPos < dicPosLimit).as_bool() && (decCtx.buf < bufLimit).as_bool() && (decCtx.remainLen < CMPTLZ_MATCH_MAX_LEN!()).as_bool());\n\n    decCtx.range = range;\n    decCtx.code = rangeCode;\n\n    return decRes.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104510583)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                            +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |         ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |         ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:195:73\n    |\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                         ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n197 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n197 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n201 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n201 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:205:77\n    |\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                             ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n207 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n207 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n211 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n211 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 18 previous errors; 2 warnings emitted\n"
        },
        {
            "c_code": "static inline int CmptlzIsLE(void)\n    {\n#if (defined(__GNUC__) || defined(__clang__))\n        return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n        int n = 1;\n        return *(char *)(&n);\n    }",
            "rust_code": "pub fn CmptlzIsLE() -> i32 {\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        return (__BYTE_ORDER__!() == __ORDER_LITTLE_ENDIAN__!()).cast();\n    }\n    #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n    {\n        let mut n: i32 = 1;\n        return (*c_ref!(n).cast::<Ptr<u8>>()).cast();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104510807)\nerror: cannot find macro `__BYTE_ORDER__` in this scope\n  --> src/src/public/cmptlz_utils_h.rs:26:17\n   |\n26 |         return (__BYTE_ORDER__!() == __ORDER_LITTLE_ENDIAN__!()).cast();\n   |                 ^^^^^^^^^^^^^^\n\nerror: cannot find macro `__ORDER_LITTLE_ENDIAN__` in this scope\n  --> src/src/public/cmptlz_utils_h.rs:26:38\n   |\n26 |         return (__BYTE_ORDER__!() == __ORDER_LITTLE_ENDIAN__!()).cast();\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        CmptRcCtx *rc = encCtx->rcCtx;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n        probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n        CmptlzState state = encCtx->state;\n        CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n        if (state < 7)\n        {\n            shiftRes = CmptRcLitProcess(rc, probs, curByte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        else\n        {\n            const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n            shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncLit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut rc: Ptr<CmptRcCtx> = encCtx.rcCtx.cast();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = rc.range;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[encCtx.state][posState]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    rc.range = range;\n    let mut litProb: Ptr<CmptlzProb> = c_ref!(encCtx.litMarcov.literal[0][0]).cast();\n    let mut curByte: u8 = mf.srcStart[mf.readPos - mf.readAhead].cast();\n    probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n    let mut state: CmptlzState = encCtx.state.cast();\n    CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n    if (state < 7).as_bool() {\n        shiftRes = CmptRcLitProcess(rc.cast(), probs.cast(), curByte.cast()).cast();\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut match_byte: u8 = mf.srcStart[mf.readPos - encCtx.reps[0] - 1 - mf.readAhead].cast();\n        shiftRes = CmptRcLitAfterMatch(rc.cast(), probs.cast(), curByte.cast(), match_byte.cast()).cast();\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104511924)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:32\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |                                ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:27:5\n   |\n27 |     CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |     ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:20:40\n   |\n20 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:20:38\n   |\n20 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:22:23\n   |\n22 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n26 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:27:5\n   |\n27 |     CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |     ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:32:59\n   |\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:11:41\n   |\n11 |         $litProb + 3u32 * ((($pos << 8) + $prevByte) & (*$encCtx.lock()).lpMask) << (*$encCtx.lock()).litMarcov.lcBits\n   |                                         ^ no implementation for `u32 + u8`\n...\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |             ----------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Add<Rhs>`:\n             `&u32` implements `std::ops::Add<u32>`\n             `&u32` implements `std::ops::Add`\n             `u32` implements `std::ops::Add<&u32>`\n             `u32` implements `std::ops::Add<types::num::Num>`\n             `u32` implements `std::ops::Add`\n   = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptLzEncCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:11:66\n   |\n11 |         $litProb + 3u32 * ((($pos << 8) + $prevByte) & (*$encCtx.lock()).lpMask) << (*$encCtx.lock()).litMarcov.lcBits\n   |                                                                  ^^^^ method not found in `Ptr<TagCmptLzEncCtx>`\n...\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |             ----------------------------------------------------------------------------------------- in this macro invocation\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n   = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptLzEncCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:11:95\n   |\n11 |         $litProb + 3u32 * ((($pos << 8) + $prevByte) & (*$encCtx.lock()).lpMask) << (*$encCtx.lock()).litMarcov.lcBits\n   |                                                                                               ^^^^ method not found in `Ptr<TagCmptLzEncCtx>`\n...\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |             ----------------------------------------------------------------------------------------- in this macro invocation\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n   = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
        },
        {
            "c_code": "static inline int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[encCtx.state][posState]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep[encCtx.state]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104512167)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:32\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |                                ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:41:5\n   |\n41 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:32\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |                                ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:46:5\n   |\n46 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:34\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                  ^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:51:20\n   |\n51 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |                    --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:56\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                                        ^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:51:20\n   |\n51 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |                    --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:24:40\n   |\n24 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:24:38\n   |\n24 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n30 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:31:5\n    |\n31  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n35 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:36:5\n    |\n36  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n40 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:41:5\n   |\n41 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n45 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:46:5\n   |\n46 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 14 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static inline int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        encCtx->rcCtx->range = range;\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n\n        shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        backRes -= CMPTLZ_NUM_REPS;\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = backRes;\n\n        encCtx->matchPriceCount++;\n\n        uint32_t posSlot = PosSloter(backRes);\n        shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        if (backRes >= 4)\n        {\n            shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncNormalMatch(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32, mut backRes: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[encCtx.state][posState]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep[encCtx.state]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    encCtx.rcCtx.range = range;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.matchLenEncoder).cast(), encCtx.rcCtx.cast(), lenRes.cast(), posState.cast()).cast();\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    backRes -= CMPTLZ_NUM_REPS!();\n    encCtx.reps[3] = encCtx.reps[2];\n    encCtx.reps[2] = encCtx.reps[1];\n    encCtx.reps[1] = encCtx.reps[0];\n    encCtx.reps[0] = backRes;\n\n    encCtx.matchPriceCount += 1;\n\n    let mut posSlot: u32 = PosSloter(backRes.cast()).cast();\n    shiftRes = CmptRcPosSlotProcess(encCtx.cast(), posSlot.cast(), lenRes.cast()).cast();\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    if (backRes >= 4).as_bool() {\n        shiftRes = CmptRcDistProcess(encCtx.cast(), posSlot.cast(), backRes.cast()).cast();\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104512408)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:32\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |                                ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:42:5\n   |\n42 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:29:40\n   |\n29 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:29:38\n   |\n29 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:31:23\n   |\n31 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n36 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:37:5\n    |\n37  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:31:23\n   |\n31 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n41 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:42:5\n   |\n42 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_inner_h.rs:67:9\n   |\n67 |         $state = if $state < 7 { LIT_MATCH!() } else { NOTLIT_MATCH!() };\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:47:5\n   |\n47 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n   |     ------------   ------------------------------------ in this macro invocation\n   |     |\n   |     expected due to the type of this binding\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_MATCH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static inline int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n\n        uint32_t range, bit0Prob, newBound;\n        uint32_t realDist;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n\n        switch (repIndex)\n        {\n        case 0:\n            CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRep0Long[encCtx->state][posState];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        case 1:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 2:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 3:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx->reps[3];\n            encCtx->reps[3] = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        default:\n            break;\n        }\n        CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        --encCtx->repLenPriceCount;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut repIndex: u32, mut nowpos32: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut realDist: u32;\n    range = encCtx.rcCtx.range;\n\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[encCtx.state][posState]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep[encCtx.state]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]).cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n\n    c_switch!(repIndex, {\n        0 => {\n            CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n            probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]).cast();\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n        },\n        1 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]).cast();\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n        },\n        2 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]).cast();\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]).cast();\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n        },\n        3 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]).cast();\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]).cast();\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[3];\n            encCtx.reps[3] = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n        },\n        _ => {},\n    });\n    CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.repLenEncoder).cast(), encCtx.rcCtx.cast(), lenRes.cast(), posState.cast()).cast();\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.repLenPriceCount -= 1;\n\n    let mut state: CmptlzState = encCtx.state.cast();\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state).cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104512637)\nerror: no rules expected `,`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:55:23\n   |\n55 |     c_switch!(repIndex, {\n   |                       ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n   |\n3  | macro_rules! c_switch {\n   | --------------------- when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_switch.rs:5:17\n   |\n5  |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n   |                 ^\n\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:75:34\n    |\n75  |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n    |                                  ^^^^^^^^^^^ not a value\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:123:20\n    |\n123 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state).cast();\n    |                    -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:75:55\n    |\n75  |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n    |                                                       ^^^^^^^^^^ not a value\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:123:20\n    |\n123 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state).cast();\n    |                    -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:34:40\n   |\n34 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:34:38\n   |\n34 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:37:23\n   |\n37 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n43 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:44:5\n    |\n44  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:37:23\n   |\n37 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n48 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:49:5\n    |\n49  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:37:23\n   |\n37 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n53 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static inline int CmptRcLitProcess(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, bit0Prob, newBound, curBit;\n\n        for (sym |= 0x100; sym < 0x10000; sym <<= 1)\n        {\n            CmptlzProb *litProbTableIndex = prob + (sym >> 8);\n            curBit = (sym >> 7) & 1;\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptRcLitProcess(mut rcCtx: Ptr<CmptRcCtx>, mut prob: Ptr<CmptlzProb>, mut sym: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut curBit: u32;\n\n    c_for!(sym |= 0x100; sym < 0x10000; sym <<= 1; {\n        let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (sym >> 8)).cast();\n        curBit = (sym >> 7) & 1;\n        CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    });\n    rcCtx.range = range.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104512873)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n    |\n83  |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n    |                      ^^^^^^^^^^^^^^^^^^^ not a value\n...\n141 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n    |\n65  |         $bit0Prob = *$prob;\n    |                     ^^^^^^ expected `u32`, found `u16`\n...\n134 |     let mut bit0Prob: u32;\n    |                       --- expected due to this type\n...\n141 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n    |\n80  |             (*$rcCtx.lock()).low += mask;\n    |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n...\n141 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n141 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                       ^^ no implementation for `u32 += i32`\n...\n141 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n        for (sym |= 0x100; sym < 0x10000;)\n        {\n            matchByte <<= 1;\n            CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n            curBit = (sym >> 7) & 1;\n            sym <<= 1;\n            offs &= ~(matchByte ^ sym);\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptRcLitAfterMatch(mut rcCtx: Ptr<CmptRcCtx>, mut prob: Ptr<CmptlzProb>, mut sym: u32, mut matchByte: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut offs: u32 = 0x100;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut curBit: u32;\n    sym |= 0x100;\n    while (sym < 0x10000).as_bool() {\n        matchByte <<= 1;\n        let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (offs + (matchByte & offs) + (sym >> 8)).cast();\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= !(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    rcCtx.range = range.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104513099)\nerror: mismatched closing delimiter: `}`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:146:54\n    |\n144 |     while (sym < 0x10000).as_bool() {\n    |                                     - closing delimiter possibly meant for this\n145 |         matchByte <<= 1;\n146 |         let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (offs + (matchByte & offs) + (sym >> 8)).cast();\n    |                                                      ^ unclosed delimiter\n...\n152 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                      CMPT_PRICE_BITS_MOVING_NUM];\n    }",
            "rust_code": "pub fn CmptPriceOneBit(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb, mut curbit: u32) -> u32 {\n    return encCtx.priceRootTable[((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!()).cast()].cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104513389)\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_price_h.rs:23:47\n   |\n23 |     return encCtx.priceRootTable[((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!...\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n\nerror[E0277]: no implementation for `u16 ^ u32`\n  --> src/src/encode/cmptlz_enc_price_h.rs:23:45\n   |\n23 |     return encCtx.priceRootTable[((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!...\n   |                                             ^ no implementation for `u16 ^ u32`\n   |\n   = help: the trait `BitXor<u32>` is not implemented for `u16`\n   = help: the following other types implement trait `BitXor<Rhs>`:\n             `&u16` implements `BitXor<u16>`\n             `&u16` implements `BitXor`\n             `u16` implements `BitXor<&u16>`\n             `u16` implements `BitXor`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceBit0(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM];\n    }",
            "rust_code": "pub fn CmptPriceBit0(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb) -> u32 {\n    return encCtx.priceRootTable[(bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM!()).cast()].cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104513613)\nerror[E0282]: type annotations needed\n  --> src/src/encode/cmptlz_enc_price_h.rs:28:12\n   |\n28 |     return encCtx.priceRootTable[(bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM!()).cast()].cast();\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceBit1(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM - 1)) >> CMPT_PRICE_BITS_MOVING_NUM];\n    }",
            "rust_code": "pub fn CmptPriceBit1(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb) -> u32 {\n    return encCtx.priceRootTable[((bit0Prob ^ (CMPTLZ_PROB_MAX_NUM!() - 1)) >> CMPT_PRICE_BITS_MOVING_NUM!()).cast()].cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104513821)\nerror[E0282]: type annotations needed\n  --> src/src/encode/cmptlz_enc_price_h.rs:33:12\n   |\n33 |     return encCtx.priceRootTable[((bit0Prob ^ (CMPTLZ_PROB_MAX_NUM!() - 1)) >> CMPT_PRICE_BITS_MOVING_NUM!()).cast()].cast();\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceSymbol(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                           uint32_t symbol)\n    {\n        uint32_t price = 0;\n        symbol += (1U << symbolBitsNum);\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[symbol], bit);\n        } while (symbol != 1);\n        return price;\n    }",
            "rust_code": "pub fn CmptPriceSymbol(mut encCtx: Ptr<CmptLzEncCtx>, mut symbolProbs: Ptr<CmptlzProb>, mut symbolBitsNum: u32, mut symbol: u32) -> u32 {\n    let mut price: u32 = 0;\n    symbol += (1 << symbolBitsNum);\n    c_do!({\n        let mut bit: u32 = symbol & 1;\n        symbol >>= 1;\n        price += CmptPriceOneBit(encCtx.cast(), symbolProbs[symbol].cast(), bit.cast()).cast();\n    } while symbol != 1);\n    return price.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104514023)\nerror[E0283]: type annotations needed\n  --> src/src/encode/cmptlz_enc_price_h.rs:43:89\n   |\n43 |         price += CmptPriceOneBit(encCtx.cast(), symbolProbs[symbol].cast(), bit.cast()).cast();\n   |               -- type must be known at this point                                       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\n   = note: multiple `impl`s satisfying `u32: std::ops::AddAssign<_>` found in the `core` crate:\n           - impl std::ops::AddAssign for u32;\n           - impl std::ops::AddAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n   |\n43 |         price += CmptPriceOneBit(encCtx.cast(), symbolProbs[symbol].cast(), bit.cast()).cast::<T>();\n   |                                                                                             +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "CMPTLZ_static int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n#ifdef CMPTLZ_PRINTF_ENC_PROCESS\n        printf(\" now in CmptEncodeOneBlock process, backRes is %u, lenRes is %u\\n\", backRes, lenRes);\n        printf(\" nowpos32 is %u\\n\", nowpos32);\n#endif\n\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n\n        if (mf->readAhead == 0)\n        {\n\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}",
            "rust_code": "pub fn CmptEncodeOneBlock(mut encCtx: Ptr<CmptLzEncCtx>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = encCtx.mfCtx.cast();\n    let mut nowpos32: u32 = encCtx.nowpos64.cast();\n    let mut startpos: u32 = nowpos32.cast();\n    let mut backRes: u32;\n    let mut lenRes: u32;\n    let mut shiftRes: i32 = CMPT_OK!();\n    loop {\n        CmptlzDp(encCtx.cast(), mf.cast(), nowpos32.cast());\n        backRes = encCtx.backRes.cast();\n        lenRes = encCtx.lenRes.cast();\n        #[cfg(CMPTLZ_PRINTF_ENC_PROCESS)]\n        {\n            c_printf!(cstr!(\" now in CmptEncodeOneBlock process, backRes is {}, lenRes is {}\\n\"), backRes, lenRes);\n            c_printf!(cstr!(\" nowpos32 is {}\\n\"), nowpos32);\n        }\n\n        c_switch!(backRes, {\n            CMPTLZ_UINT32_MAX!() => {\n                shiftRes = CmptlzEncLit(encCtx.cast(), mf.cast(), nowpos32.cast()).cast();\n                if shiftRes != CMPT_OK!() {\n                    return shiftRes.cast();\n                }\n                break;\n            },\n            0 => {\n                shiftRes = CmptEncShortOrRep0(encCtx.cast(), nowpos32.cast(), lenRes.cast()).cast();\n                if shiftRes != CMPT_OK!() {\n                    return shiftRes.cast();\n                }\n                break;\n            },\n            1 => {\n                shiftRes = CmptlzEncLongRep(encCtx.cast(), 1, nowpos32.cast(), lenRes.cast()).cast();\n                if shiftRes != CMPT_OK!() {\n                    return shiftRes.cast();\n                }\n                break;\n            },\n            2 => {\n                shiftRes = CmptlzEncLongRep(encCtx.cast(), 2, nowpos32.cast(), lenRes.cast()).cast();\n                if shiftRes != CMPT_OK!() {\n                    return shiftRes.cast();\n                }\n                break;\n            },\n            3 => {\n                shiftRes = CmptlzEncLongRep(encCtx.cast(), 3, nowpos32.cast(), lenRes.cast()).cast();\n                if shiftRes != CMPT_OK!() {\n                    return shiftRes.cast();\n                }\n                break;\n            },\n            _ => {\n                shiftRes = CmptlzEncNormalMatch(encCtx.cast(), nowpos32.cast(), backRes.cast(), lenRes.cast()).cast();\n                if shiftRes != CMPT_OK!() {\n                    return shiftRes.cast();\n                }\n                break;\n            },\n        });\n\n        nowpos32 += lenRes;\n        mf.mfStart += lenRes;\n        mf.readAhead -= lenRes;\n\n        if (mf.readAhead == 0).as_bool() {\n            CmptPriceCheck(encCtx.cast());\n            if (mf.srcLen <= mf.mfStart).as_bool() {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE!()).as_bool() {\n                encCtx.nowpos64 += (nowpos32 - startpos).cast();\n                return 0;\n            }\n        }\n    }\n    encCtx.nowpos64 += (nowpos32 - startpos).cast();\n    return CmptlzFlush(encCtx.cast()).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104515354)\nerror: no rules expected `,`\n  --> src/src/encode/cmptlz_enc_blocks_c.rs:63:26\n   |\n63 |         c_switch!(backRes, {\n   |                          ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n   |\n3  | macro_rules! c_switch {\n   | --------------------- when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_switch.rs:5:17\n   |\n5  |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n   |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_blocks_c.rs:114:30\n    |\n114 |             if (mf.srcLen <= mf.mfStart).as_bool() {\n    |                 ---------    ^^^^^^^^^^ expected `usize`, found `u32`\n    |                 |\n    |                 expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n114 |             if (mf.srcLen <= mf.mfStart.try_into().unwrap()).as_bool() {\n    |                                        ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int CmptEncodeAll(CmptLzEncCtx *encCtx)\n{\n    CmptRcCtx *rc = encCtx->rcCtx;\n    CmptMfCtx *mf = encCtx->mfCtx;\n\n    if (mf->srcLen == 0)\n    {\n        return CmptlzFlush(encCtx);\n    }\n\n    if (encCtx->nowpos64 == 0)\n    {\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][0];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        int shiftRes = CMPT_OK;\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        uint8_t curByte = *(mf->srcStart);\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        mf->mfStart++;\n        encCtx->nowpos64++;\n        mf->readPos++;\n        if (mf->srcLen == 1)\n        {\n            return CmptlzFlush(encCtx);\n        }\n    }\n\n    int res;\n    while (true)\n    {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0 || encCtx->encNeedFinish)\n        {\n            break;\n        }\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptEncodeAll(mut encCtx: Ptr<CmptLzEncCtx>) -> i32 {\n    let mut rc: Ptr<CmptRcCtx> = encCtx.rcCtx.cast();\n    let mut mf: Ptr<CmptMfCtx> = encCtx.mfCtx.cast();\n\n    if (mf.srcLen == 0).as_bool() {\n        return CmptlzFlush(encCtx.cast());\n    }\n\n    if (encCtx.nowpos64 == 0).as_bool() {\n        let mut range: u32;\n        let mut bit0Prob: u32;\n        let mut newBound: u32;\n        range = rc.range.cast();\n        let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[encCtx.state][0]).cast();\n        CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n        let mut shiftRes: i32 = CMPT_OK!();\n        CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        rc.range = range.cast();\n        let mut curByte: u8 = (*mf.srcStart).cast();\n        let mut litProb: Ptr<CmptlzProb> = c_ref!(encCtx.litMarcov.literal[0][0]).cast();\n        shiftRes = CmptRcLitProcess(rc.cast(), litProb.cast(), curByte.cast()).cast();\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        mf.mfStart += 1;\n        encCtx.nowpos64 += 1;\n        mf.readPos += 1;\n        if (mf.srcLen == 1).as_bool() {\n            return CmptlzFlush(encCtx.cast());\n        }\n    }\n\n    let mut res: i32;\n    loop {\n        res = CmptEncodeOneBlock(encCtx.cast()).cast();\n        if (res != 0).as_bool() || encCtx.encNeedFinish.as_bool() {\n            break;\n        }\n    }\n    return res.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104515567)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:32\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |                                ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_blocks_c.rs:67:9\n   |\n67 |         CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |         ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_blocks_c.rs:61:27\n   |\n61 |         let mut bit0Prob: u32;\n   |                           --- expected due to this type\n...\n65 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |         ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_blocks_c.rs:67:9\n   |\n67 |         CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |         ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "int CmptHeadWrite(CmptLzEncCtx *encCtx, uint8_t *protData, size_t *propsSize)\n{\n    if (protData == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"protData is NULL\");\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"propsSize need 5 bytes, get %zu\", *propsSize);\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    CmptlzWriteLE32Bit(protData + 1, encCtx->dicSize);\n    protData[0] = (encCtx->posBits * CMPTLZ_POS_STATE_MAX + encCtx->litPos) * CMPTLZ_LIT_CTX_MAX + encCtx->litCtx;\n    *propsSize = CMPTLZ_PROPS_SIZE;\n    return 0;\n}",
            "rust_code": "pub fn CmptHeadWrite(mut encCtx: Ptr<CmptLzEncCtx>, mut protData: Ptr<u8>, mut propsSize: Ptr<usize>) -> i32 {\n    if (protData == NULL!()).as_bool() {\n        CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"protData is NULL\"));\n        return CMPT_ENC_ERROR_HEAD!();\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE!()).as_bool() {\n        CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"propsSize need 5 bytes, get {}\"), *propsSize);\n        return CMPT_ENC_ERROR_HEAD!();\n    }\n\n    CmptlzWriteLE32Bit((protData + 1).cast(), encCtx.dicSize.cast());\n    protData[0] = ((encCtx.posBits * CMPTLZ_POS_STATE_MAX!() + encCtx.litPos) * CMPTLZ_LIT_CTX_MAX!() + encCtx.litCtx).cast();\n    *propsSize = CMPTLZ_PROPS_SIZE!();\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104515791)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_head_c.rs:16:9\n   |\n16 |         CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"protData is NULL\"));\n   |         ---------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:14:39\n   |\n14 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[$(&$args), *]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_head_c.rs:21:9\n   |\n21 |         CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"propsSize need 5 bytes, get {}\"), *propsSize);\n   |         ------------------------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}",
            "rust_code": "pub fn CmptlzFreeAll(mut encCtx: Ptr<CmptLzEncCtx>, mut alloc: Ptr<CmptLzMemHook>) {\n    if (encCtx == NULL!()).as_bool() {\n        return;\n    }\n\n    if (encCtx.mfCtx != NULL!()).as_bool() {\n        if (encCtx.mfCtx.hash != NULL!()).as_bool() {\n            alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n            encCtx.mfCtx.hash = NULL!();\n        }\n        if (encCtx.mfCtx.son != NULL!()).as_bool() {\n            alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n            encCtx.mfCtx.son = NULL!();\n        }\n        alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n        encCtx.mfCtx = NULL!();\n    }\n\n    if (encCtx.rcCtx != NULL!()).as_bool() {\n        if (encCtx.rcCtx.bufBase != NULL!()).as_bool() {\n            alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n            encCtx.rcCtx.bufBase = NULL!();\n        }\n        alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n        encCtx.rcCtx = NULL!();\n    }\n\n    alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n    encCtx = NULL!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104516010)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:12:19\n   |\n12 |             alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n   |                   ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n12 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n   |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:16:19\n   |\n16 |             alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n   |                   ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n16 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n   |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:19:15\n   |\n19 |         alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n   |               ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n19 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n   |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:25:19\n   |\n25 |             alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n   |                   ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n25 |             (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n   |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:28:15\n   |\n28 |         alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n   |               ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n28 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n   |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:32:11\n   |\n32 |     alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |           ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n32 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |     +                +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx);\n\n    res = CmptEncodeAll(encCtx);\n\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n\n    *destLen -= encCtx->rcCtx->outBufLeft;\n\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}",
            "rust_code": "pub fn CmptlzEncodeIO(mut encCtx: Ptr<CmptLzEncCtx>, mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n\n    res = CmptMfPrepare(encCtx.cast(), src.cast(), srcLen.cast(), alloc.cast()).cast();\n    if (res != 0).as_bool() {\n        CMPTLZ_LOG!(res, cstr!(\"CmptMfPrepare Fail!\"));\n        CmptlzFreeAll(encCtx.cast(), alloc.cast());\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx.cast(), dest.cast(), destLen.cast(), alloc.cast()).cast();\n    if (res != 0).as_bool() {\n        CMPTLZ_LOG!(res, cstr!(\"CmptRcPrepare Fail!\"));\n        CmptlzFreeAll(encCtx.cast(), alloc.cast());\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx.cast());\n\n    res = CmptEncodeAll(encCtx.cast()).cast();\n\n    if (res != 0).as_bool() {\n        CmptlzFreeAll(encCtx.cast(), alloc.cast());\n        CMPTLZ_LOG!(res, cstr!(\"CmptEncode Process Fail!\"));\n        return res;\n    }\n\n    *destLen = (*destLen - encCtx.rcCtx.outBufLeft).cast();\n\n    if (encCtx.nowpos64 != srcLen).as_bool() {\n        CMPTLZ_LOG!(res, cstr!(\"CmptEncode FileSize Fail!\"));\n        CmptlzFreeAll(encCtx.cast(), alloc.cast());\n        return CMPT_ENC_ERROR_FILESIZE!();\n    }\n\n    CmptlzFreeAll(encCtx.cast(), alloc.cast());\n    return res.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104516234)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:15:9\n   |\n15 |         CMPTLZ_LOG!(res, cstr!(\"CmptMfPrepare Fail!\"));\n   |         ---------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:22:9\n   |\n22 |         CMPTLZ_LOG!(res, cstr!(\"CmptRcPrepare Fail!\"));\n   |         ---------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:33:9\n   |\n33 |         CMPTLZ_LOG!(res, cstr!(\"CmptEncode Process Fail!\"));\n   |         --------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:40:9\n   |\n40 |         CMPTLZ_LOG!(res, cstr!(\"CmptEncode FileSize Fail!\"));\n   |         ---------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_c.rs:39:28\n   |\n39 |     if (encCtx.nowpos64 != srcLen).as_bool() {\n   |         ---------------    ^^^^^^ expected `u64`, found `usize`\n   |         |\n   |         expected because this is `u64`\n   |\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n   |\n39 |     if (encCtx.nowpos64 != srcLen.try_into().unwrap()).as_bool() {\n   |                                  ++++++++++++++++++++\n\nSome errors have detailed explanations: E0308, E0412.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptlzEncode(mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut src: Ptr<u8>, mut srcLen: usize, mut props: Ptr<CmptlzEncParam>, mut propsEncoded: Ptr<u8>, mut propsSize: Ptr<usize>, mut writeEndMark: i32, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n    if (alloc == NULL!()).as_bool() || (alloc.CmptLzAlloc == NULL!()).as_bool() || (alloc.CmptLzFree == NULL!()).as_bool() {\n        CMPTLZ_LOG!(CMPT_ENC_ERROR_PARAM!(), cstr!(\"Cmptlz input wrong param!\"));\n        return CMPT_ENC_ERROR_PARAM!();\n    }\n\n    let mut encCtx: Ptr<CmptLzEncCtx> = CmptInitCctx(alloc.cast(), writeEndMark.cast()).cast::<Ptr<CmptLzEncCtx>>();\n    if (encCtx == NULL!()).as_bool() {\n        CMPTLZ_LOG!(CMPT_ENC_CTX_INIT_FAIL!(), cstr!(\"CmptInitCctx Fail!\"));\n        return CMPT_ENC_CTX_INIT_FAIL!();\n    }\n    CmptlzSetParam(encCtx.cast(), props.cast());\n    res = CmptHeadWrite(encCtx.cast(), propsEncoded.cast(), propsSize.cast()).cast();\n    if (res != 0).as_bool() {\n        alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n        CMPTLZ_LOG!(res, cstr!(\"CmptHeadWrite Fail!\"));\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx.cast(), dest.cast(), destLen.cast(), src.cast(), srcLen.cast(), alloc.cast()).cast();\n    if (res != 0).as_bool() {\n        CMPTLZ_LOG!(res, cstr!(\"CmptlzEncode I / O Fail!\"));\n    }\n    return res.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104516474)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:18:9\n   |\n18 |         CMPTLZ_LOG!(CMPT_ENC_ERROR_PARAM!(), cstr!(\"Cmptlz input wrong param!\"));\n   |         ------------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:24:9\n   |\n24 |         CMPTLZ_LOG!(CMPT_ENC_CTX_INIT_FAIL!(), cstr!(\"CmptInitCctx Fail!\"));\n   |         ------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:31:9\n   |\n31 |         CMPTLZ_LOG!(res, cstr!(\"CmptHeadWrite Fail!\"));\n   |         ---------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:36:9\n   |\n36 |         CMPTLZ_LOG!(res, cstr!(\"CmptlzEncode I / O Fail!\"));\n   |         --------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:30:15\n   |\n30 |         alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |               ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n30 |         (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |         +                +\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t CmptMfAvail(const CmptMfCtx *mf)\n    {\n        return mf->srcLen - mf->readPos;\n    }",
            "rust_code": "pub fn CmptMfAvail(mut mf: Ptr<CmptMfCtx>) -> u32 {\n    return (mf.srcLen - mf.readPos).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104517610)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_inner_h.rs:109:25\n    |\n109 |     return (mf.srcLen - mf.readPos).cast();\n    |                         ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:109:23\n    |\n109 |     return (mf.srcLen - mf.readPos).cast();\n    |                       ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t PosSloter(uint32_t dist)\n    {\n        if (dist <= 4)\n        {\n            return dist;\n        }\n        uint32_t helper = PosSlotHelper(dist);\n        return (helper + helper + ((dist >> (helper - 1)) & 1));\n    }",
            "rust_code": "pub fn PosSloter(mut dist: u32) -> u32 {\n    if (dist <= 4).as_bool() {\n        return dist.cast();\n    }\n    let mut helper: u32 = PosSlotHelper(dist.cast()).cast();\n    return (helper + helper + ((dist >> (helper - 1)) & 1).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104518298)\nerror: mismatched closing delimiter: `}`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:155:12\n    |\n150 | pub fn PosSloter(mut dist: u32) -> u32 {\n    |                                        - closing delimiter possibly meant for this\n...\n155 |     return (helper + helper + ((dist >> (helper - 1)) & 1).cast();\n    |            ^ unclosed delimiter\n156 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}",
            "rust_code": "pub fn CmptMfPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    if (mf == NULL!()).as_bool() {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    c_memset_s!(mf, c_sizeof!(CmptMfCtx), 0, c_sizeof!(CmptMfCtx)).cast::<Void>();\n\n    encCtx.mfCtx = mf.cast();\n    mf.cycleSize = encCtx.dicSize + 1;\n    let mut hashMask: u32 = encCtx.dicSize - 1;\n    CMPT_HASH_MASK_CALC!(hashMask);\n    mf.hashMask = hashMask;\n    hashMask += 1;\n    hashMask += CMPTLZ_HASH_2_SIZE!();\n    hashMask += CMPTLZ_HASH_3_SIZE!();\n    mf.hashCount = hashMask;\n    mf.sonsCount = mf.cycleSize * 2;\n    mf.hash = NULL!();\n    mf.son = NULL!();\n    mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    c_memset_s!(mf.hash, mf.hashCount * c_sizeof!(u32), 0, mf.hashCount * c_sizeof!(u32)).cast::<Void>();\n    if (mf.hash == NULL!()).as_bool() {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    c_memset_s!(mf.son, mf.sonsCount * c_sizeof!(u32), 0, mf.sonsCount * c_sizeof!(u32)).cast::<Void>();\n    if (mf.son == NULL!()).as_bool() {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n\n    CmptlzMfGenHashTable(mf.cast());\n    mf.srcStart = src.cast();\n    mf.srcLen = srcLen.cast();\n    mf.offset = mf.cycleSize.cast();\n    mf.niceLen = encCtx.numFastBytes.cast();\n    mf.depth = (CMPT_MF_BASE_DEPTH!() + mf.niceLen / 2).cast();\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104518595)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:156:80\n    |\n156 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n    |                                  |\n    |                                  arguments to this function are incorrect\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:156:34\n    |\n156 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    |                 --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<TagCmptMatchFinder>`, found `Ptr<u8>`\n    |                 |\n    |                 expected due to this\n    |\n    = note: expected struct `memory::ptr::Ptr<TagCmptMatchFinder>`\n               found struct `memory::ptr::Ptr<u8>`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:174:61\n    |\n174 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    |               -------------------                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n    |               |\n    |               arguments to this function are incorrect\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n174 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), (mf.hashCount * c_sizeof!(u32)).try_into().unwrap());\n    |                                                             +                             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:174:15\n    |\n174 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    |     -------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u32>`, found `Ptr<u8>`\n    |     |\n    |     expected due to the type of this binding\n    |\n    = note: expected struct `memory::ptr::Ptr<u32>`\n               found struct `memory::ptr::Ptr<u8>`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:179:59\n    |\n179 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    |              -------------------                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n    |              |\n    |              arguments to this function are incorrect\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n179 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), (mf.sonsCount * c_sizeof!(u32)).try_into().unwrap());\n    |                                                           +                             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:179:14\n    |\n179 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    |     ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u32>`, found `Ptr<u8>`\n    |     |\n    |     expected due to the type of this binding\n    |\n    = note: expected struct `memory::ptr::Ptr<u32>`\n               found struct `memory::ptr::Ptr<u8>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "static void CmptBtSkip(CmptMfCtx *mf, const uint32_t lenLimit, const uint32_t pos, const uint8_t *const cur,\n                       uint32_t curMatch)\n{\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return;\n        }\n        uint32_t *pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, lenLimit);\n            if (len == lenLimit)\n            {\n                *ptr1 = pair[0];\n                *ptr0 = pair[1];\n                return;\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}",
            "rust_code": "pub fn CmptBtSkip(mut mf: Ptr<CmptMfCtx>, mut lenLimit: u32, mut pos: u32, mut cur: Ptr<u8>, mut curMatch: u32) {\n    let mut depth: u32 = mf.depth.cast();\n    let mut son: Ptr<u32> = mf.son.cast();\n    let mut cyclePos: u32 = mf.cyclePos.cast();\n    let mut cycleSize: u32 = mf.cycleSize.cast();\n\n    let mut ptr0: Ptr<u32> = (son + (cyclePos << 1) + 1).cast();\n    let mut ptr1: Ptr<u32> = (son + (cyclePos << 1)).cast();\n    let mut len0: u32 = 0;\n    let mut len1: u32 = 0;\n\n    loop {\n        let mut delta: u32 = (pos - curMatch).cast();\n        if (depth.suffix_minus_minus() == 0 || delta >= cycleSize).as_bool() {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE!();\n            *ptr1 = CMPT_EMPTY_HASH_VALUE!();\n            return;\n        }\n        let mut pair: Ptr<u32> = (son + ((cyclePos - delta + if delta > cyclePos { cycleSize } else { 0 }) << 1).cast();\n        let mut pb: Ptr<u8> = (cur - delta).cast();\n        let mut len: u32 = CMPTLZ_FIND_MIN!(len0, len1);\n        if (pb[len] == cur[len]).as_bool() {\n            len = CmptMemCmpLenSafe(pb.cast(), cur.cast(), (len + 1).cast(), lenLimit.cast()).cast();\n            if (len == lenLimit).as_bool() {\n                *ptr1 = pair[0].cast();\n                *ptr0 = pair[1].cast();\n                return;\n            }\n        }\n        if (pb[len] < cur[len]).as_bool() {\n            CMPT_MF_LEFT_SON_UPDATE!(ptr1, pair, curMatch, len1, len);\n        } else {\n            CMPT_MF_RIGHT_SON_UPDATE!(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104519273)\nerror: mismatched closing delimiter: `}`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:245:34\n    |\n238 |     loop {\n    |          - closing delimiter possibly meant for this\n...\n245 |         let mut pair: Ptr<u32> = (son + ((cyclePos - delta + if delta > cyclePos { cycleSize } else { 0 }) << 1).cast();\n    |                                  ^ unclosed delimiter\n...\n261 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static uint32_t CmptlzBt4Finder(CmptMfCtx *mf, CmptlzMatchPair *matches)\n{\n    const uint32_t niceLen = mf->niceLen;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t temp, hash2Value, hash3Value, hashValue;\n    uint32_t longestLen = 1, matchesCount = 0;\n    CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    uint32_t delta2 = pos - mf->hash[hash2Value];\n    uint32_t delta3 = pos - mf->hash[CMPTLZ_FIX_3_HASH + hash3Value];\n    uint32_t curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n    CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0)\n    {\n        longestLen = CmptMemCmpLenSafe(cur, cur - delta2, longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen)\n        {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS(mf);\n            return matchesCount;\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES)\n    {\n        longestLen = CMPT_MF_MATCH_3_BYTES;\n    }\n    matchesCount = (uint32_t)(CmptBtFind(mf, curMatch, matches + matchesCount, longestLen) - matches);\n\n    CMPT_MF_MOVE_POS(mf);\n    return matchesCount;\n}",
            "rust_code": "pub fn CmptlzBt4Finder(mut mf: Ptr<CmptMfCtx>, mut matches: Ptr<CmptlzMatchPair>) -> u32 {\n    let niceLen: u32 = mf.niceLen.cast();\n    let cur: Ptr<u8> = (mf.srcStart + mf.readPos).cast::<Ptr<u8>>();\n    let pos: u32 = (mf.readPos + mf.offset).cast();\n    let mut temp: u32 = Default::default();\n    let mut hash2Value: u32 = Default::default();\n    let mut hash3Value: u32 = Default::default();\n    let mut hashValue: u32 = Default::default();\n    let mut longestLen: u32 = 1;\n    let mut matchesCount: u32 = 0;\n    CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    let mut delta2: u32 = (pos - mf.hash[hash2Value]).cast();\n    let mut delta3: u32 = (pos - mf.hash[CMPTLZ_FIX_3_HASH!() + hash3Value]).cast();\n    let mut curMatch: u32 = mf.hash[CMPTLZ_FIX_4_HASH!() + hashValue].cast();\n    CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES!(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES!(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0).as_bool() {\n        longestLen = CmptMemCmpLenSafe(cur.cast(), (cur - delta2).cast(), longestLen.cast(), niceLen.cast()).cast();\n        matches[matchesCount - 1].len = longestLen.cast();\n        if (longestLen == niceLen).as_bool() {\n            CmptBtSkip(mf.cast(), niceLen.cast(), pos.cast(), cur.cast(), curMatch.cast());\n            CMPT_MF_MOVE_POS!(mf);\n            return matchesCount.cast();\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES!()).as_bool() {\n        longestLen = CMPT_MF_MATCH_3_BYTES!();\n    }\n    matchesCount = (CmptBtFind(mf.cast(), curMatch.cast(), (matches + matchesCount).cast(), longestLen.cast()) - matches).cast::<u32>();\n\n    CMPT_MF_MOVE_POS!(mf);\n    return matchesCount.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104519344)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:55:23\n    |\n55  |         $temp = (*$mf.lock()).hashRootTable[$cur[0]] ^ $cur[1];\n    |                       ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n242 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |     ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:64\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n242 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |     ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:110\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                                                              ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n242 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |     ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:66:15\n    |\n66  |         (*$mf.lock()).hash[$hash2Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n247 |     CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |     ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:67:15\n    |\n67  |         (*$mf.lock()).hash[CMPTLZ_FIX_3_HASH!() + $hash3Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n247 |     CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |     ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:68:15\n    |\n68  |         (*$mf.lock()).hash[CMPTLZ_FIX_4_HASH!() + $hashValue] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n247 |     CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |     ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:76:28\n    |\n76  |         if $delta2 < (*$mf.lock()).cycleSize && *($cur - $delta2) == *$cur {\n    |                            ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n248 |     CMPT_HASH_FIND_2_BYTES!(mf, delta2, longestLen, matchesCount, cur, matches);\n    |     --------------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_FIND_2_BYTES` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:89:50\n    |\n89  |         if $delta2 != $delta3 && $delta3 < (*$mf.lock()).cycleSize && *($cur - $delta3) == *$cur {\n    |                                                  ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n249 |     CMPT_HASH_FIND_3_BYTES!(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n    |     ----------------------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_FIND_3_BYTES` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
        },
        {
            "c_code": "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}",
            "rust_code": "pub fn CmptlzMatchSkiper(mut mf: Ptr<CmptMfCtx>, mut amount: u32) {\n    mf.readAhead += amount;\n    let mut pos: u32 = Default::default();\n    let mut temp: u32 = Default::default();\n    let mut hash2Value: u32 = Default::default();\n    let mut hash3Value: u32 = Default::default();\n    let mut hashValue: u32 = Default::default();\n    let mut curMatch: u32 = Default::default();\n    let niceLen: u32 = mf.niceLen;\n    c_do!({\n        let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n        if CMPTLZ_LIKELY!(niceLen <= lenLimit).as_bool() {\n            lenLimit = niceLen;\n        } else {\n            mf.readPos += 1;\n            continue;\n        }\n        let mut cur: Ptr<u8> = (mf.srcStart + mf.readPos).cast();\n        pos = mf.readPos + mf.offset;\n        CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf.hash[CMPTLZ_FIX_4_HASH!() + hashValue];\n        CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf.cast(), lenLimit.cast(), pos.cast(), cur.cast(), curMatch.cast());\n        CMPT_MF_MOVE_POS!(mf);\n    } while amount.prefix_minus_minus() != 0);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104519574)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:247:45\n    |\n247 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n    |                                             ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:247:33\n    |\n247 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n    |                           ---   ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n    |                           |\n    |                           expected due to this\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n247 |         let mut lenLimit: u32 = (mf.srcLen - mf.readPos).try_into().unwrap();\n    |                                 +                      +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:247:43\n    |\n247 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n    |                                           ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:55:23\n    |\n55  |         $temp = (*$mf.lock()).hashRootTable[$cur[0]] ^ $cur[1];\n    |                       ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n256 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |         ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:64\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n256 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |         ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:110\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                                                              ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n256 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |         ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:66:15\n    |\n66  |         (*$mf.lock()).hash[$hash2Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n258 |         CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |         ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:67:15\n    |\n67  |         (*$mf.lock()).hash[CMPTLZ_FIX_3_HASH!() + $hash3Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n258 |         CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |         ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:68:15\n    |\n68  |         (*$mf.lock()).hash[CMPTLZ_FIX_4_HASH!() + $hashValue] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n258 |         CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |         ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
        },
        {
            "c_code": "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}",
            "rust_code": "pub fn CmptlzMatchFinder(mut mf: Ptr<CmptMfCtx>, mut pCount: Ptr<u32>, mut matches: Ptr<CmptlzMatchPair>) -> u32 {\n    if CMPTLZ_UNLIKELY!((mf.srcLen - mf.readPos < mf.niceLen).as_bool()).as_bool() {\n        *pCount = 0;\n        mf.readPos.suffix_plus_plus();\n        mf.readAhead.suffix_plus_plus();\n        return 0;\n    }\n    let mut count: u32 = CmptlzBt4Finder(mf.cast(), matches.cast()).cast();\n    if (count == 0).as_bool() {\n        *pCount = 0;\n        mf.readAhead.suffix_plus_plus();\n        return 0;\n    }\n    let mut longestLen: u32 = matches[count - 1].len.cast();\n    if (longestLen == mf.niceLen).as_bool() {\n        let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n        let mut p1: Ptr<u8> = (mf.srcStart + mf.readPos - 1).cast::<Ptr<u8>>();\n        let mut p2: Ptr<u8> = (p1 - matches[count - 1].dist - 1).cast::<Ptr<u8>>();\n        longestLen = CmptMemCmpLenSafe(p1.cast(), p2.cast(), longestLen.cast(), bytesAvail.cast()).cast();\n    }\n    *pCount = count.cast();\n    mf.readAhead.suffix_plus_plus();\n    return longestLen.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104519809)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:243:38\n    |\n243 |     if CMPTLZ_UNLIKELY!((mf.srcLen - mf.readPos < mf.niceLen).as_bool()).as_bool() {\n    |                                      ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:243:36\n    |\n243 |     if CMPTLZ_UNLIKELY!((mf.srcLen - mf.readPos < mf.niceLen).as_bool()).as_bool() {\n    |                                    ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:243:51\n    |\n243 |     if CMPTLZ_UNLIKELY!((mf.srcLen - mf.readPos < mf.niceLen).as_bool()).as_bool() {\n    |                          ----------------------   ^^^^^^^^^^ expected `usize`, found `u32`\n    |                          |\n    |                          expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n243 |     if CMPTLZ_UNLIKELY!((mf.srcLen - mf.readPos < mf.niceLen.try_into().unwrap()).as_bool()).as_bool() {\n    |                                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:257:64\n    |\n257 |         let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n    |                                                                ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:257:62\n    |\n257 |         let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n    |                                                              ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n\n    encCtx->rcCtx = rc;\n\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}",
            "rust_code": "pub fn CmptRcPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx)).cast();\n    if (rc == NULL!()).as_bool() {\n        return CMPT_ENC_RC_INIT_FAIL!();\n    }\n    c_memset_s!(rc, c_sizeof!(CmptRcCtx), 0, c_sizeof!(CmptRcCtx)).cast::<Void>();\n\n    encCtx.rcCtx = rc.cast();\n\n    rc.bufBase = (alloc.CmptLzAlloc)(CMPTLZ_RC_BUF_HANDLE!(), CMPTLZ_RC_BUFFER_SIZE!()).cast();\n    c_memset_s!(rc.bufBase, CMPTLZ_RC_BUFFER_SIZE!(), 0, CMPTLZ_RC_BUFFER_SIZE!()).cast::<Void>();\n    if (rc.bufBase == NULL!()).as_bool() {\n        return CMPT_ENC_RC_INIT_FAIL!();\n    }\n\n    rc.outBufLeft = *destLen;\n    rc.outBuf = dest.cast();\n\n    rc.buf = rc.bufBase.cast();\n    rc.range = 0xFFFFFFFF;\n    rc.cacheSize = 0;\n    rc.cache = 0;\n    rc.low = 0;\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104520032)\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_c.rs:13:80\n   |\n13 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx)).cast();\n   |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n   |                                  |\n   |                                  arguments to this function are incorrect\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptRcShiftLow(mut rcCtx: Ptr<CmptRcCtx>) -> i32 {\n    let mut res: i32 = CMPT_OK!();\n    let mut lowLow32: u32 = rcCtx.low.cast::<u32>();\n    let mut high: u64 = (rcCtx.low >> 32).cast::<u32>().cast::<u64>();\n    rcCtx.low = (lowLow32 << 8).cast();\n    CMPT_RC_BREAK_CHECK!(rcCtx, rcCtx.buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0).as_bool() {\n        let mut buf: Ptr<u8> = rcCtx.buf.cast();\n        *buf = (rcCtx.cache + high).cast::<u8>();\n        buf += 1;\n        rcCtx.buf = buf.cast();\n        rcCtx.cache = (lowLow32 >> 24).cast::<u8>();\n        CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n        high += 0xFF;\n        loop {\n            let mut buf1: Ptr<u8> = rcCtx.buf.cast();\n            CMPT_RC_BREAK_SHIFTING!(rcCtx, buf1, res);\n            *buf1 = high.cast::<u8>();\n            buf1 += 1;\n            rcCtx.buf = buf1.cast();\n            rcCtx.cacheSize -= 1;\n        }\n        CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n    } else {\n        rcCtx.cacheSize += 1;\n    }\n    return res.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104520484)\nerror[E0423]: expected value, found macro `CMPT_OK`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:45:20\n   |\n45 |             return CMPT_OK;\n   |                    ^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:42:9\n   |\n42 |         CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n   |         ---------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BREAK_SHIFTING` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_OK`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:45:20\n   |\n45 |             return CMPT_OK;\n   |                    ^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:46:13\n   |\n46 |             CMPT_RC_BREAK_SHIFTING!(rcCtx, buf1, res);\n   |             ----------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BREAK_SHIFTING` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_OK`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:45:20\n   |\n45 |             return CMPT_OK;\n   |                    ^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:52:9\n   |\n52 |         CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n   |         ---------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BREAK_SHIFTING` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_c.rs:41:23\n   |\n41 |         rcCtx.cache = (lowLow32 >> 24).cast::<u8>();\n   |         -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `u8`\n   |         |\n   |         expected due to the type of this binding\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "int CmptRcLenProcess(CmptLenEncoder *lenEncoder, CmptRcCtx *rcCtx, uint32_t len, uint64_t posState)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t newBound, bit0Prob;\n    len -= CMPTLZ_MATCH_LEN_MIN;\n\n    CmptlzProb *probs = lenEncoder->low;\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND)\n    {\n        CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs += CMPT_LEN_BOUND;\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND * CMPT_DOUBLE)\n        {\n            CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            rcCtx->range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder->high, len - CMPT_LEN_BOUND * CMPT_DOUBLE);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            return CMPT_OK;\n        }\n        len -= CMPT_LEN_BOUND;\n    }\n\n    uint32_t m, bit;\n    CMPT_RC_BIT_0_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs += (posState << (1 + 3));\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcLenProcess(mut lenEncoder: Ptr<CmptLenEncoder>, mut rcCtx: Ptr<CmptRcCtx>, mut len: u32, mut posState: u64) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range.cast();\n    let mut newBound: u32;\n    let mut bit0Prob: u32;\n    len -= CMPTLZ_MATCH_LEN_MIN!();\n\n    let mut probs: Ptr<CmptlzProb> = lenEncoder.low.cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND!()).as_bool() {\n        CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        probs += CMPT_LEN_BOUND!();\n        CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND!() * CMPT_DOUBLE!()).as_bool() {\n            CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            rcCtx.range = range.cast();\n            shiftRes = CmptRcLitProcess(rcCtx.cast(), lenEncoder.high.cast(), (len - CMPT_LEN_BOUND!() * CMPT_DOUBLE!()).cast()).cast();\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            return CMPT_OK!();\n        }\n        len -= CMPT_LEN_BOUND!();\n    }\n\n    let mut m: u32;\n    let mut bit: u32;\n    CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs += (posState << (1 + 3)).cast::<usize>();\n    bit = (len >> 2).cast();\n    CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    rcCtx.range = range.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104521176)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:32\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |                                ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:84:5\n   |\n84 |     CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     ------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:92:5\n   |\n92 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:96:5\n   |\n96 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:23\n   |\n61 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n65 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:67:9\n    |\n67  |         CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:23\n   |\n61 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n70 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |         ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:72:13\n    |\n72  |             CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |             ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = $bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb;\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:84:5\n   |\n84 |     CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     ------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:23\n   |\n61 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:23\n   |\n61 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n92 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:92:5\n   |\n92 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:92:5\n   |\n92 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:92:5\n   |\n92 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:23\n   |\n61 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n96 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:96:5\n   |\n96 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:96:5\n   |\n96 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:96:5\n   |\n96 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 21 previous errors\n"
        },
        {
            "c_code": "inline int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcPosSlotProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut len: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = encCtx.rcCtx.range.cast();\n    let mut sym: u32 = posSlot + (1 << 6);\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut bit: u32;\n    let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n    c_do!({\n        let mut posSlotProbTableIndex: Ptr<CmptlzProb> = probs + (sym >> CMPTLZ_DIST_SLOT_BITS!());\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS!() - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } while sym < (1 << (CMPTLZ_DIST_SLOT_BITS!() * 2)));\n    encCtx.rcCtx.range = range.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104521421)\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:24:64\n   |\n24 | macro_rules! GET_LEN_TO_POS_STATE { ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 ...\n   |                                                                ^^^^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:69:58\n   |\n69 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n   |                                                          -------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:24:111\n   |\n24 | ... < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 } } }\n   |                                                      ^^^^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:69:58\n   |\n69 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n   |                                                          -------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:74:9\n   |\n74 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:74:9\n   |\n74 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:74:9\n   |\n74 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:74:9\n   |\n74 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "static inline int CmptRcReverseProcess(CmptRcCtx *rcCtx, CmptlzProb *probs, uint32_t numBits, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    uint32_t m = 1;\n    do\n    {\n        bit = sym & 1;\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        m = (m << 1) | bit;\n    } while (--numBits);\n\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcReverseProcess(mut rcCtx: Ptr<CmptRcCtx>, mut probs: Ptr<CmptlzProb>, mut numBits: u32, mut sym: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range.cast();\n    let mut bit0Prob: u32 = Default::default();\n    let mut newBound: u32 = Default::default();\n    let mut bit: u32 = Default::default();\n    let mut m: u32 = 1;\n    c_do!({\n        bit = (sym & 1).cast();\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        m = (m << 1) | bit;\n    } while (numBits.prefix_minus_minus()).as_bool());\n\n    rcCtx.range = range.cast();\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104521651)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:77:9\n   |\n77 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:70:23\n   |\n70 |     let mut bit0Prob: u32 = Default::default();\n   |                       --- expected due to this type\n...\n77 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:77:9\n   |\n77 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:77:9\n   |\n77 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:77:9\n   |\n77 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcDistProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut dist: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n\n    let mut footerBits: u32 = ((posSlot >> 1) - 1).cast();\n    if (dist < CMPT_DIST_LIMIT_2!()).as_bool() {\n        let mut base: u32 = ((2 | (posSlot & 1)) << footerBits).cast();\n        shiftRes = CmptRcReverseProcess(encCtx.rcCtx.cast(), (encCtx.probDistSpecial + base).cast(), footerBits.cast(), dist.cast()).cast();\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut pos2: u32 = (dist | 0xF) << (32 - footerBits);\n        let mut range: u32 = encCtx.rcCtx.range.cast();\n        c_do!({\n            range >>= 1;\n            encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        } while pos2 != 0xF0000000);\n\n        let mut m: u32 = 1;\n        let mut bit: u32;\n        let mut bit0Prob: u32;\n        let mut newBound: u32;\n        let mut k: i32;\n        c_for!(k = 0; k < CMPTLZ_ALIGN_BITS!() - 1; k.suffix_plus_plus(); {\n            bit = (dist & 1).cast();\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            m = (m << 1) + bit;\n        });\n        bit = (dist & 1).cast();\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        encCtx.rcCtx.range = range.cast();\n    }\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104521885)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:99:13\n   |\n99 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n   |             -------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n    |\n83  |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n    |                      ^^^^^^^^^^^^^^^^^^^ not a value\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:104:9\n    |\n104 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n    |         -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n  --> src/src/encode/cmptlz_enc_rc_c.rs:78:86\n   |\n78 |         shiftRes = CmptRcReverseProcess(encCtx.rcCtx.cast(), (encCtx.probDistSpecial + base).cast(), footerBits.cast(), dist.cast()).cast();\n   |                                                               ---------------------- ^ ---- u32\n   |                                                               |\n   |                                                               types::array::Array<u16, 128>\n   |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  | pub struct Array<T, const N: usize>(pub [T; N]);\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n  --> /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/ops/arith.rs:77:1\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_c.rs:85:33\n   |\n85 |             encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n  --> src/src/encode/cmptlz_enc_rc_c.rs:85:30\n   |\n85 |             encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n   |                              ^^ no implementation for `u64 += u32`\n   |\n   = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u64` implements `std::ops::AddAssign<&u64>`\n             `u64` implements `std::ops::AddAssign`\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 16>`\n  --> src/src/encode/cmptlz_enc_rc_c.rs:99:65\n   |\n99 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n   |                                                ---------------- ^ - u32\n   |                                                |\n   |                                                types::array::Array<u16, 16>\n   |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 16>`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  | pub struct Array<T, const N: usize>(pub [T; N]);\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n  --> /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/ops/arith.rs:77:1\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:99:13\n   |\n99 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n   |             -------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:99:13\n   |\n99 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n   |             -------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:99:13\n   |\n99 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n   |             -------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 16>`\n   --> src/src/encode/cmptlz_enc_rc_c.rs:104:61\n    |\n104 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n    |                                            ---------------- ^ - u32\n    |                                            |\n    |                                            types::array::Array<u16, 16>\n    |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 16>`\n   --> src/translation_utils/types/array.rs:5:1\n    |\n5   | pub struct Array<T, const N: usize>(pub [T; N]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n   --> /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/ops/arith.rs:77:1\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n    |\n80  |             (*$rcCtx.lock()).low += mask;\n    |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:104:9\n    |\n104 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n    |         -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:104:9\n    |\n104 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n    |         -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                       ^^ no implementation for `u32 += i32`\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:104:9\n    |\n104 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n    |         -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
        },
        {
            "c_code": "void CmptlzSetParam(CmptLzEncCtx *encCtx, const CmptlzEncParam *props)\n{\n    CmptlzEncParam param = *props;\n\n    CmptlzParamNormalize(&param);\n\n    encCtx->dicSize = param.dictSize;\n    encCtx->numFastBytes = param.fastBytes;\n    encCtx->litCtx = param.litCtx;\n    encCtx->litPos = param.litPos;\n    encCtx->posBits = param.posBits;\n    uint32_t i;\n    for (i = 7; i < 32; i++)\n    {\n        if (encCtx->dicSize <= (uint32_t)(1 << i))\n        {\n            break;\n        }\n    }\n    encCtx->distTableSize = i * 2;\n}",
            "rust_code": "pub fn CmptlzSetParam(mut encCtx: Ptr<CmptLzEncCtx>, mut props: Ptr<CmptlzEncParam>) {\n    let mut param: CmptlzEncParam = *props;\n\n    CmptlzParamNormalize(c_ref!(param).cast());\n\n    encCtx.dicSize = param.dictSize.cast();\n    encCtx.numFastBytes = param.fastBytes.cast();\n    encCtx.litCtx = param.litCtx.cast();\n    encCtx.litPos = param.litPos.cast();\n    encCtx.posBits = param.posBits.cast();\n    let mut i: u32 = 7;\n    c_for!(; i < 32; {\n        if (encCtx.dicSize <= (1 << i).cast()).as_bool() {\n            break;\n        }\n        i.suffix_plus_plus();\n    });\n    encCtx.distTableSize = (i * 2).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104522354)\nerror: unexpected end of macro invocation\n  --> src/src/encode/cmptlz_enc_init_c.rs:70:6\n   |\n70 |     });\n   |      ^ missing tokens in macro arguments\n   |\n  ::: src/translation_utils/c_alignment/c_for.rs:3:1\n   |\n3  | macro_rules! c_for {\n   | ------------------ when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_for.rs:13:53\n   |\n13 |     ($($init: stmt),+; $cond: expr; $($step: expr),+; $body: block) => {\n   |                                                     ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n\n    CmptlzPriceInit(encCtx);\n\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}",
            "rust_code": "pub fn CmptlzEncPrepare(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut i: u32 = Default::default();\n    let mut j: u32 = Default::default();\n\n    encCtx.encNeedFinish = false;\n    encCtx.cmptlzResponse = 0;\n    encCtx.nowpos64 = 0;\n\n    encCtx.state = 0;\n    encCtx.pbMask = (1 << encCtx.posBits) - 1;\n    encCtx.lpMask = (0x100 << encCtx.litPos) - (0x100 >> encCtx.litCtx);\n    encCtx.posMask = (1 << encCtx.posBits) - 1;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.reps[i] = 0;\n    });\n\n    encCtx.optsCurIndex = 0;\n    encCtx.optEndIndex = 0;\n    c_for!(i = 0; i < CMPT_DP_OPTMAX!(); i.suffix_plus_plus(); {\n        encCtx.opts[i].price = CMPT_INFINITY_PRICE!();\n    });\n\n    c_for!(i = 0; i < CMPTLZ_NUM_STATES!(); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < CMPTLZ_NUM_PB_STATES_MAX!(); j.suffix_plus_plus(); {\n            encCtx.isMatch[i][j] = CMPTLZ_PROB_INIT!();\n            encCtx.isRep0Long[i][j] = CMPTLZ_PROB_INIT!();\n        });\n        encCtx.isRep[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG0[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG1[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG2[i] = CMPTLZ_PROB_INIT!();\n    });\n\n    c_for!(i = 0; i < CMPTLZ_DIST_STATE_TOTAL!(); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS!()); j.suffix_plus_plus(); {\n            encCtx.probDistSlot[i][j] = CMPTLZ_PROB_INIT!();\n        });\n    });\n    c_for!(i = 0; i < CMPT_DIST_LIMIT_2!(); i.suffix_plus_plus(); {\n        encCtx.probDistSpecial[i] = CMPTLZ_PROB_INIT!();\n    });\n    c_for!(i = 0; i < (1 << CMPTLZ_ALIGN_BITS!()); i.suffix_plus_plus(); {\n        encCtx.probAlign[i] = CMPTLZ_PROB_INIT!();\n    });\n\n    encCtx.litMarcov.lcBits = encCtx.litCtx;\n    encCtx.litMarcov.posMask = (1 << encCtx.litPos) - 1;\n\n    c_for!(i = 0; i < (1 << CMPTLZ_LCLP_MAX!()); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < CMPTLZ_LIT_MAX_SIZE!(); j.suffix_plus_plus(); {\n            encCtx.litMarcov.literal[i][j] = CMPTLZ_PROB_INIT!();\n        });\n    });\n\n    c_for!(i = 0; i < (1 << CMPT_LEN_HIGH_BITS!()); i.suffix_plus_plus(); {\n        encCtx.matchLenEncoder.high[i] = CMPTLZ_PROB_INIT!();\n        encCtx.repLenEncoder.high[i] = CMPTLZ_PROB_INIT!();\n        encCtx.matchLenEncoder.low[i] = CMPTLZ_PROB_INIT!();\n        encCtx.repLenEncoder.low[i] = CMPTLZ_PROB_INIT!();\n    });\n\n    CmptlzPriceInit(encCtx.cast());\n\n    encCtx.repLenEncoder.tableSize = encCtx.numFastBytes - 1;\n    encCtx.matchLenEncoder.tableSize = encCtx.numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx.cast(), c_ref!(encCtx.matchLenEncoder).cast());\n    CmptPriceGenLenTable(encCtx.cast(), c_ref!(encCtx.repLenEncoder).cast());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104522800)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_init_c.rs:111:31\n    |\n111 |     encCtx.litMarcov.lcBits = encCtx.litCtx;\n    |     -----------------------   ^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}",
            "rust_code": "pub fn CmptInitCctx(mut alloc: Ptr<CmptLzMemHook>, mut writeEndMark: i32) -> Ptr<Void> {\n    let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n    if (handle == NULL!()).as_bool() {\n        return NULL!();\n    }\n    c_memset_s!(handle, c_sizeof!(CmptLzEncCtx), 0, c_sizeof!(CmptLzEncCtx)).cast::<Void>();\n    let mut encCtx: Ptr<CmptLzEncCtx> = handle.cast::<CmptLzEncCtx>();\n    encCtx.endMarker = writeEndMark.cast();\n    encCtx.rcCtx = NULL!();\n    encCtx.mfCtx = NULL!();\n    return encCtx.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104523022)\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_init_c.rs:72:39\n   |\n72 |     let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n   |                                       ^^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzAlloc` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n   |\n72 |     let mut handle: Ptr<Void> = (alloc.CmptLzAlloc)(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n   |                                 +                 +\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/encode/cmptlz_enc_init_c.rs:79:20\n    |\n79  |     encCtx.rcCtx = NULL!();\n    |                    ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/encode/cmptlz_enc_init_c.rs:80:20\n    |\n80  |     encCtx.mfCtx = NULL!();\n    |                    ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/encode/cmptlz_enc_init_c.rs:73:19\n    |\n73  |     if (handle == NULL!()).as_bool() {\n    |                   ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n\n    encCtx->matchPriceCount = 0;\n}",
            "rust_code": "pub fn CmptPriceGenDistTable(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut distState: u32 = 0;\n\n    c_do!({\n        let mut tmpPriceDistSlot: Ptr<u32> = encCtx.priceDistSlotTable[distState].cast();\n\n        c_for!(let mut i: u32 = 0; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx.cast(), encCtx.probDistSlot[distState].cast(), CMPTLZ_DIST_SLOT_BITS!(), i.cast()).cast();\n        });\n\n        c_for!(let mut i: u32 = 14; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect(((i >> 1) - 1 - CMPTLZ_ALIGN_BITS!()).cast()).cast();\n        });\n\n        c_for!(let mut i: u32 = 0; i < 4; i.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = tmpPriceDistSlot[i].cast();\n        });\n\n        distState.suffix_plus_plus();\n    } while distState < CMPTLZ_DIST_STATE_TOTAL!());\n\n    c_for!(let mut i: u32 = 4; i < 128; i.suffix_plus_plus(); {\n        let mut distSlot: u32 = PosSloter(i.cast()).cast();\n        let mut footerBits: u32 = ((distSlot >> 1) - 1).cast();\n        let mut base: u32 = ((2 | (distSlot & 1)) << footerBits).cast();\n        let mut price: u32 = CmptPriceSymbolReverse(encCtx.cast(), (encCtx.probDistSpecial + base - distSlot - 1).cast(), footerBits.cast(), (i - base).cast()).cast();\n\n        c_for!(distState = 0; distState < 4; distState.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = (price + encCtx.priceDistSlotTable[distState][distSlot]).cast();\n        });\n    });\n\n    encCtx.matchPriceCount = 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104523481)\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n  --> src/src/encode/cmptlz_enc_price_c.rs:61:92\n   |\n61 | ...   let mut price: u32 = CmptPriceSymbolReverse(encCtx.cast(), (encCtx.probDistSpecial + base - distSlot - 1).cast(), footerBits.cast()...\n   |                                                                   ---------------------- ^ ---- u32\n   |                                                                   |\n   |                                                                   types::array::Array<u16, 128>\n   |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  | pub struct Array<T, const N: usize>(pub [T; N]);\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n  --> /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/ops/arith.rs:77:1\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}",
            "rust_code": "pub fn CmptPriceLiteral(mut encCtx: Ptr<CmptLzEncCtx>, mut matchMode: bool, mut matchByte: u32, mut symbol: u32) -> u32 {\n    let mut pos: u32 = encCtx.litMarcov.pos.cast();\n    let mut prevByte: u32 = encCtx.litMarcov.prevByte.cast();\n    let mut litCtx: u32 = encCtx.litMarcov.lcBits.cast();\n    let mut lpMask: u32 = encCtx.litMarcov.posMask.cast();\n    let mut subCoder: Ptr<CmptlzProb> = CMPT_LIT_SUBCODER!(encCtx.litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    let mut price: u32 = 0;\n    if !matchMode.as_bool() {\n        price = CmptPriceSymbol(encCtx.cast(), subCoder.cast(), 8, symbol.cast()).cast();\n    } else {\n        let mut offset: u32 = 0x100;\n        symbol += 1 << 8;\n        c_do!({\n            matchByte <<= 1;\n            let mut matchBit: u32 = (matchByte & offset).cast();\n            let mut subCoderIndex: u32 = (offset + matchBit + (symbol >> 8)).cast();\n            let mut bit: u32 = ((symbol >> 7) & 1).cast();\n            price += CmptPriceOneBit(encCtx.cast(), subCoder[subCoderIndex].cast(), bit.cast()).cast();\n            symbol <<= 1;\n            offset &= !(matchByte ^ symbol);\n        } while symbol < (1 << 16));\n    }\n    return price.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104523933)\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_price_c.rs:6:9\n   |\n6  |         $probs[((($pos) & ($lpMask)) << ($litCtx)) + (($prevByte as u32) >> (8u32 - ($litCtx)))]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u16>`, found `Array<u16, 768>`\n...\n53 |     let mut subCoder: Ptr<CmptlzProb> = CMPT_LIT_SUBCODER!(encCtx.litMarcov.literal, litCtx, lpMask, pos, prevByte);\n   |                       ---------------   --------------------------------------------------------------------------- in this macro invocation\n   |                       |\n   |                       expected due to this\n   |\n   = note: expected struct `memory::ptr::Ptr<u16>`\n              found struct `types::array::Array<u16, 768>`\n   = note: this error originates in the macro `CMPT_LIT_SUBCODER` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static void CmptPriceSet(CmptLzEncCtx *encCtx, const CmptlzProb *probs, uint32_t startPrice, uint32_t *prices)\n{\n    uint32_t i;\n    for (i = 0; i < 8; i += 2)\n    {\n        uint32_t price = startPrice;\n        uint32_t prob;\n        price += CmptPriceOneBit(encCtx, probs[1], (i >> 2));\n        price += CmptPriceOneBit(encCtx, probs[2 + (i >> 2)], (i >> 1) & 1);\n        prob = probs[4 + (i >> 1)];\n        prices[i] = price + CmptPriceBit0(encCtx, prob);\n        prices[i + 1] = price + CmptPriceBit1(encCtx, prob);\n    }\n}",
            "rust_code": "pub fn CmptPriceSet(mut encCtx: Ptr<CmptLzEncCtx>, mut probs: Ptr<CmptlzProb>, mut startPrice: u32, mut prices: Ptr<u32>) {\n    let mut i: u32 = 0;\n    c_for!(i = 0; i < 8; i += 2; {\n        let mut price: u32 = startPrice.cast();\n        let mut prob: u32;\n        price += CmptPriceOneBit(encCtx.cast(), probs[1].cast(), (i >> 2).cast()).cast();\n        price += CmptPriceOneBit(encCtx.cast(), probs[2 + (i >> 2)].cast(), ((i >> 1) & 1).cast()).cast();\n        prob = probs[4 + (i >> 1)].cast();\n        prices[i] = (price + CmptPriceBit0(encCtx.cast(), prob.cast()).cast()).cast();\n        prices[i + 1] = (price + CmptPriceBit1(encCtx.cast(), prob.cast()).cast()).cast();\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104524162)\nerror[E0282]: type annotations needed\n  --> src/src/encode/cmptlz_enc_price_c.rs:61:21\n   |\n61 |         prices[i] = (price + CmptPriceBit0(encCtx.cast(), prob.cast()).cast()).cast();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n\n    uint32_t b;\n\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}",
            "rust_code": "pub fn CmptPriceGenLenTable(mut encCtx: Ptr<CmptLzEncCtx>, mut lenEncoder: Ptr<CmptLenEncoder>) {\n    let numPosStates: u32 = 1 << encCtx.posBits;\n\n    let mut b: u32;\n\n    let mut prob: u32 = lenEncoder.low[0];\n    let mut a: u32;\n    let mut c: u32;\n    let mut posState: u32;\n\n    b = CmptPriceBit1(encCtx.cast(), prob.cast()).cast();\n    a = CmptPriceBit0(encCtx.cast(), prob.cast()).cast();\n    c = (b + CmptPriceBit0(encCtx.cast(), lenEncoder.low[1 << CMPT_LEN_LOW_BITS!()].cast()).cast();\n\n    c_for!(posState = 0; posState < numPosStates; posState.suffix_plus_plus(); {\n        let mut prices: Ptr<u32> = lenEncoder.prices[posState].cast();\n        let mut probs: Ptr<CmptlzProb> = (lenEncoder.low + (posState << (1 + CMPT_LEN_LOW_BITS!()))).cast();\n        CmptPriceSet(encCtx.cast(), probs.cast(), a.cast(), prices.cast());\n        CmptPriceSet(encCtx.cast(), (probs + (1 << CMPT_LEN_LOW_BITS!())).cast(), c.cast(), (prices + (1 << CMPT_LEN_LOW_BITS!())).cast());\n    });\n\n    let mut i: u32 = lenEncoder.tableSize.cast();\n    if (i > (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()).as_bool() {\n        let mut probs: Ptr<CmptlzProb> = lenEncoder.high.cast();\n        let mut prices: Ptr<u32> = (lenEncoder.prices[0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()).cast();\n        i -= (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!() - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx.cast(), lenEncoder.low[(1 << CMPT_LEN_LOW_BITS!())].cast()).cast();\n        c_do!({\n            let mut sym: u32 = (i.prefix_minus_minus() + (1 << (CMPT_LEN_HIGH_BITS!() - 1))).cast();\n            let mut price: u32 = b.cast();\n            c_do!({\n                let mut bit: u32 = (sym & 1).cast();\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx.cast(), probs[sym].cast(), bit.cast()).cast();\n            } while sym >= 2);\n\n            prob = probs[(i + (1 << (CMPT_LEN_HIGH_BITS!() - 1))].cast();\n            prices[(i * CMPT_DOUBLE!())] = (price + CmptPriceBit0(encCtx.cast(), prob.cast())).cast();\n            prices[(i * CMPT_DOUBLE!() + 1)] = (price + CmptPriceBit1(encCtx.cast(), prob.cast())).cast();\n        } while i != 0);\n        let mut num: usize = (lenEncoder.tableSize - (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) * c_sizeofval!(lenEncoder.prices[0][0]);\n\n        c_for!(posState = 1; posState < numPosStates; posState.suffix_plus_plus(); {\n            c_memcpy_s!((lenEncoder.prices[posState] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()).cast(), CMPT_MF_LONGEST_MATCH!() - 1,\n                     (lenEncoder.prices[0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()).cast(), num);\n        });\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104524381)\nerror: mismatched closing delimiter: `]`\n  --> src/src/encode/cmptlz_enc_price_c.rs:95:26\n   |\n95 |             prob = probs[(i + (1 << (CMPT_LEN_HIGH_BITS!() - 1))].cast();\n   |                         -^                                      ^ mismatched closing delimiter\n   |                         ||\n   |                         |unclosed delimiter\n   |                         closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/encode/cmptlz_enc_price_c.rs:70:9\n    |\n58  | pub fn CmptPriceGenLenTable(mut encCtx: Ptr<CmptLzEncCtx>, mut lenEncoder: Ptr<CmptLenEncoder>) {\n    |                                                                                                 - closing delimiter possibly meant for this\n...\n70  |     c = (b + CmptPriceBit0(encCtx.cast(), lenEncoder.low[1 << CMPT_LEN_LOW_BITS!()].cast()).cast();\n    |         ^ unclosed delimiter\n...\n106 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "uint32_t CmptPriceShortRep(CmptLzEncCtx *encCtx, CmptlzState state, uint32_t posState)\n{\n    return CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRep0Long[state][posState]);\n}",
            "rust_code": "pub fn CmptPriceShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut state: CmptlzState, mut posState: u32) -> u32 {\n    return (CmptPriceBit0(encCtx.cast(), encCtx.isRepG0[state].cast()).cast::<u32>() + \n           (CmptPriceBit0(encCtx.cast(), encCtx.isRep0Long[state][posState].cast()).cast::<u32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104524704)\nerror: mismatched closing delimiter: `}`\n  --> src/src/encode/cmptlz_enc_price_c.rs:70:12\n   |\n68 | pub fn CmptPriceShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut state: CmptlzState, mut posState: u32) -> u32 {\n   |                                                                                                           - closing delimiter possibly meant for this\n69 |     return (CmptPriceBit0(encCtx.cast(), encCtx.isRepG0[state].cast()).cast::<u32>() + \n70 |            (CmptPriceBit0(encCtx.cast(), encCtx.isRep0Long[state][posState].cast()).cast::<u32>();\n   |            ^ unclosed delimiter\n71 | }\n   | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}",
            "rust_code": "pub fn CmptPriceLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut longRepIndex: u32, mut state: CmptlzState, mut posState: u32) -> u32 {\n    let mut price: u32 = 0;\n    c_switch!(longRepIndex, {\n        0 => {\n            price = (CmptPriceBit0(encCtx.cast(), encCtx.isRepG0[state].cast()).cast() + \n                    CmptPriceBit1(encCtx.cast(), encCtx.isRep0Long[state][posState].cast()).cast()).cast();\n            break;\n        },\n        1 => {\n            price = (CmptPriceBit1(encCtx.cast(), encCtx.isRepG0[state].cast()).cast() + \n                    CmptPriceBit0(encCtx.cast(), encCtx.isRepG1[state].cast()).cast()).cast();\n            break;\n        },\n        2 => {\n            price = (CmptPriceBit1(encCtx.cast(), encCtx.isRepG0[state].cast()).cast() + \n                    CmptPriceBit1(encCtx.cast(), encCtx.isRepG1[state].cast()).cast() + \n                    CmptPriceBit0(encCtx.cast(), encCtx.isRepG2[state].cast()).cast()).cast();\n            break;\n        },\n        3 => {\n            price = (CmptPriceBit1(encCtx.cast(), encCtx.isRepG0[state].cast()).cast() + \n                    CmptPriceBit1(encCtx.cast(), encCtx.isRepG1[state].cast()).cast() + \n                    CmptPriceBit1(encCtx.cast(), encCtx.isRepG2[state].cast()).cast()).cast();\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    return price.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104524776)\nerror: no rules expected `,`\n  --> src/src/encode/cmptlz_enc_price_c.rs:75:27\n   |\n75 |     c_switch!(longRepIndex, {\n   |                           ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n   |\n3  | macro_rules! c_switch {\n   | --------------------- when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_switch.rs:5:17\n   |\n5  |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n   |                 ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceDistWithLen(CmptLzEncCtx *encCtx, uint32_t dist, uint32_t len, uint32_t posState)\n{\n    const uint32_t distState = CMPT_GET_DIST_STATE(len);\n    uint32_t price;\n    if (dist < 128)\n    {\n        price = encCtx->priceDistTable[distState][dist];\n    }\n    else\n    {\n\n        uint32_t distSlot = PosSloter(dist);\n        price = encCtx->priceDistSlotTable[distState][distSlot] +\n                encCtx->priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS) - 1)];\n    }\n\n    price += CmptPriceLen(&encCtx->matchLenEncoder, len, posState);\n\n    return price;\n}",
            "rust_code": "pub fn CmptPriceDistWithLen(mut encCtx: Ptr<CmptLzEncCtx>, mut dist: u32, mut len: u32, mut posState: u32) -> u32 {\n    let mut distState: u32 = CMPT_GET_DIST_STATE!(len);\n    let mut price: u32;\n    if (dist < 128).as_bool() {\n        price = encCtx.priceDistTable[distState][dist];\n    } else {\n        let mut distSlot: u32 = PosSloter(dist.cast()).cast();\n        price = encCtx.priceDistSlotTable[distState][distSlot] + \n                encCtx.priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS!()) - 1)];\n    }\n    price += CmptPriceLen(c_ref!(encCtx.matchLenEncoder).cast(), len.cast(), posState.cast()).cast();\n    return price.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104525001)\nerror[E0283]: type annotations needed\n  --> src/src/encode/cmptlz_enc_price_c.rs:88:95\n   |\n88 |     price += CmptPriceLen(c_ref!(encCtx.matchLenEncoder).cast(), len.cast(), posState.cast()).cast();\n   |           -- type must be known at this point                                                 ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\n   = note: multiple `impl`s satisfying `u32: std::ops::AddAssign<_>` found in the `core` crate:\n           - impl std::ops::AddAssign for u32;\n           - impl std::ops::AddAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n   |\n88 |     price += CmptPriceLen(c_ref!(encCtx.matchLenEncoder).cast(), len.cast(), posState.cast()).cast::<T>();\n   |                                                                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[0].state = encCtx->state;\n\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}",
            "rust_code": "pub fn CmptlzDpInit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut position: u32) -> u32 {\n    let niceLen: u32 = mf.niceLen;\n    let mut lenMain: u32;\n    let mut matchesCount: u32 = 0;\n\n    if (mf.readAhead == 0).as_bool() {\n        lenMain = CmptlzMatchFinder(mf.cast(), c_ref!(matchesCount).cast(), encCtx.matches.cast()).cast();\n    } else {\n        lenMain = encCtx.longestMatchLen.cast();\n        matchesCount = encCtx.matchesCount.cast();\n    }\n\n    let buf: Ptr<u8> = (CmptMfGetPtr(mf.cast()) - 1).cast();\n    let bufAvail: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf.cast()) + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN!()).as_bool() {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    let mut repLens: Array<u32, { CMPTLZ_NUM_REPS!() }> = Default::default();\n    let mut repMaxIndex: u32 = 0;\n\n    let mut i: u32;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        let bufBack: Ptr<u8> = (buf - encCtx.reps[i] - 1).cast();\n\n        if NOT_EQUAL_2_BYTES!(buf, bufBack).as_bool() {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf.cast(), bufBack.cast(), CMPTLZ_MATCH_LEN_MIN!(), bufAvail.cast()).cast();\n        if (repLens[i] > repLens[repMaxIndex]).as_bool() {\n            repMaxIndex = i;\n        }\n    });\n\n    if (repLens[repMaxIndex] >= niceLen).as_bool() {\n        encCtx.backRes = repMaxIndex.cast();\n        encCtx.lenRes = repLens[repMaxIndex].cast();\n        CmptlzMatchSkiper(mf.cast(), (repLens[repMaxIndex] - 1).cast());\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    if (lenMain >= niceLen).as_bool() {\n        encCtx.backRes = (encCtx.matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS!()).cast();\n        encCtx.lenRes = lenMain.cast();\n        CmptlzMatchSkiper(mf.cast(), (lenMain - 1).cast());\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    let currentByte: u8 = *buf;\n    let matchByte: u8 = *(buf - encCtx.reps[0] - 1);\n    let lenEnd: u32 = CMPTLZ_FIND_MAX!(lenMain, repLens[repMaxIndex]).cast();\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()).as_bool() && (currentByte != matchByte).as_bool() {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    encCtx.opts[0].state = encCtx.state.cast();\n\n    let posState: u32 = (position & encCtx.posMask).cast();\n\n    encCtx.litMarcov.pos = position.cast();\n    encCtx.litMarcov.prevByte = *(buf - 1);\n    let isLiteralState: bool = (encCtx.state < 7).as_bool();\n    let isMatchMode: bool = !isLiteralState;\n\n    encCtx.opts[1].price = (CmptPriceBit0(encCtx.cast(), encCtx.isMatch[encCtx.state][posState].cast()).cast() +\n                            CmptPriceLiteral(encCtx.cast(), isMatchMode.cast(), matchByte.cast(), currentByte.cast()).cast()).cast();\n    encCtx.opts[1].backPrev = CMPTLZ_UINT32_MAX!();\n\n    let matchPrice: u32 = CmptPriceBit1(encCtx.cast(), encCtx.isMatch[encCtx.state][posState].cast()).cast();\n    let repMatchPrice: u32 = (matchPrice + CmptPriceBit1(encCtx.cast(), encCtx.isRep[encCtx.state].cast()).cast()).cast();\n\n    if (matchByte == currentByte).as_bool() {\n        CmptlzDpInitShortRep(encCtx.cast(), repMatchPrice.cast(), posState.cast());\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()).as_bool() {\n        encCtx.backRes = encCtx.opts[1].backPrev.cast();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    encCtx.opts[1].posPrev = 0;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.opts[0].backs[i] = encCtx.reps[i].cast();\n    });\n\n    let mut len: u32 = lenEnd.cast();\n    c_do!({\n        encCtx.opts[len].price = CMPT_INFINITY_PRICE!();\n        len -= 1;\n    } while len >= CMPTLZ_MATCH_LEN_MIN!());\n\n    CmptlzDpInitLongRep(encCtx.cast(), repLens.cast(), repMatchPrice.cast(), posState.cast());\n\n    let normalMatchPrice: u32 = (matchPrice + CmptPriceBit0(encCtx.cast(), encCtx.isRep[encCtx.state].cast()).cast()).cast();\n    len = if (repLens[0] > CMPTLZ_MATCH_LEN_MIN!()).as_bool() { repLens[0] + 1 } else { CMPTLZ_MATCH_LEN_MIN!() };\n\n    if (len <= lenMain).as_bool() {\n        CmptlzDpInitMatch(encCtx.cast(), matchesCount.cast(), normalMatchPrice.cast(), posState.cast(), len.cast());\n    }\n    return lenEnd.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104525973)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_dp_c.rs:125:33\n    |\n125 |     encCtx.litMarcov.prevByte = *(buf - 1);\n    |     -------------------------   ^^^^^^^^^^ expected `u32`, found `u8`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void CmptlzDpPre(CmptLzEncCtx *encCtx, uint32_t *mainReps, const uint32_t cur)\n{\n    uint32_t posPointer = encCtx->opts[cur].posPrev;\n    CmptlzState state = encCtx->opts[posPointer].state;\n\n    if (posPointer == cur - 1)\n    {\n        if (encCtx->opts[cur].backPrev == 0)\n        {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_LIT(state);\n        }\n    }\n    else\n    {\n        uint32_t backPointer;\n        backPointer = encCtx->opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_MATCH(state);\n        }\n\n        uint32_t i;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            mainReps[0] = encCtx->opts[posPointer].backs[backPointer];\n\n            for (i = 1; i <= backPointer; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n            for (; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i];\n            }\n        }\n        else\n        {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS;\n            for (i = 1; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n        }\n    }\n\n    encCtx->opts[cur].state = state;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[cur].backs[i] = mainReps[i];\n    }\n}",
            "rust_code": "pub fn CmptlzDpPre(mut encCtx: Ptr<CmptLzEncCtx>, mut mainReps: Ptr<u32>, mut cur: u32) {\n    let mut posPointer: u32 = encCtx.opts[cur].posPrev;\n    let mut state: CmptlzState = encCtx.opts[posPointer].state;\n\n    if (posPointer == cur - 1).as_bool() {\n        if (encCtx.opts[cur].backPrev == 0).as_bool() {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n        } else {\n            CMPT_STATE_UPDATE_WHEN_LIT!(state);\n        }\n    } else {\n        let mut backPointer: u32;\n        backPointer = encCtx.opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS!()).as_bool() {\n            CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n        } else {\n            CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n        }\n\n        let mut i: u32;\n        if (backPointer < CMPTLZ_NUM_REPS!()).as_bool() {\n            mainReps[0] = encCtx.opts[posPointer].backs[backPointer];\n\n            c_for!(i = 1; i <= backPointer; i.suffix_plus_plus(); {\n                mainReps[i] = encCtx.opts[posPointer].backs[i - 1];\n            });\n            c_for!(; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n                mainReps[i] = encCtx.opts[posPointer].backs[i];\n            });\n        } else {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS!();\n            c_for!(i = 1; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n                mainReps[i] = encCtx.opts[posPointer].backs[i - 1];\n            });\n        }\n    }\n\n    encCtx.opts[cur].state = state;\n\n    let mut i: u32;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.opts[cur].backs[i] = mainReps[i];\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104526219)\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:34\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                  ^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:70:13\n   |\n70 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |             --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:56\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                                        ^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:70:13\n   |\n70 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |             --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:75:34\n   |\n75 |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n   |                                  ^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:79:13\n   |\n79 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n   |             -------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:75:55\n   |\n75 |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n   |                                                       ^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:79:13\n   |\n79 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n   |             -------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "static inline void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                        const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                        const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}",
            "rust_code": "pub fn CmptlzDpTryCurAndLit(mut encCtx: Ptr<CmptLzEncCtx>, mut curPrice: u32, mut curState: CmptlzState, mut posState: u32, mut cur: u32, mut latestMatchByte: u8, mut curByte: u8) {\n    let mut isLiteralState: bool = (curState < 7).as_bool();\n    let mut isMatchMode: bool = !isLiteralState;\n    let mut curAndLitPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast() + CmptPriceLiteral(encCtx.cast(), isMatchMode.cast(), latestMatchByte.cast(), curByte.cast()).cast();\n    if (curAndLitPrice < encCtx.opts[cur + 1].price).as_bool() {\n        encCtx.opts[cur + 1].price = curAndLitPrice.cast();\n        encCtx.opts[cur + 1].posPrev = cur.cast();\n        encCtx.opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX!();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104526461)\nerror[E0284]: type annotations needed\n  --> src/src/encode/cmptlz_enc_dp_c.rs:72:118\n   |\n72 | ...tPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast() + CmptPriceLiteral(encCtx.cast...\n   |                           - type must be known at this point                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\n   = note: cannot satisfy `<u32 as std::ops::Add<_>>::Output == _`\nhelp: consider specifying the generic argument\n   |\n72 |     let mut curAndLitPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast::<T>() + CmptPriceLiteral(encCtx.cast(), isMatchMode.cast(), latestMatchByte.cast(), curByte.cast()).cast();\n   |                                                                                                                          +++++\n\nerror[E0283]: type annotations needed\n  --> src/src/encode/cmptlz_enc_dp_c.rs:72:118\n   |\n72 | ...tPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast() + CmptPriceLiteral(encCtx.cast...\n   |                           - type must be known at this point                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nnote: multiple `impl`s satisfying `u32: std::ops::Add<_>` found\n  --> src/translation_utils/types/num.rs:72:1\n   |\n72 | impl Add<Num> for u32 {\n   | ^^^^^^^^^^^^^^^^^^^^^\n   = note: and more `impl`s found in the following crates: `core`:\n           - impl std::ops::Add for u32;\n           - impl std::ops::Add<&u32> for u32;\nhelp: consider specifying the generic argument\n   |\n72 |     let mut curAndLitPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast::<T>() + CmptPriceLiteral(encCtx.cast(), isMatchMode.cast(), latestMatchByte.cast(), curByte.cast()).cast();\n   |                                                                                                                          +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline void CmptlzDpTryCurAndShort(CmptLzEncCtx *encCtx, const uint32_t repMatchPrice, const uint32_t cur,\n                                          CmptlzState curState, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, curState, posState);\n    if (shortRepPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = shortRepPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = 0;\n    }\n}",
            "rust_code": "pub fn CmptlzDpTryCurAndShort(mut encCtx: Ptr<CmptLzEncCtx>, mut repMatchPrice: u32, mut cur: u32, mut curState: CmptlzState, mut posState: u32) {\n    let mut shortRepPrice: u32 = repMatchPrice + CmptPriceShortRep(encCtx.cast(), curState.cast(), posState.cast()).cast();\n    if (shortRepPrice < encCtx.opts[cur + 1].price).as_bool() {\n        encCtx.opts[cur + 1].price = shortRepPrice.cast();\n        encCtx.opts[cur + 1].posPrev = cur.cast();\n        encCtx.opts[cur + 1].backPrev = 0;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104526706)\nerror[E0284]: type annotations needed\n  --> src/src/encode/cmptlz_enc_dp_c.rs:75:117\n   |\n75 |     let mut shortRepPrice: u32 = repMatchPrice + CmptPriceShortRep(encCtx.cast(), curState.cast(), posState.cast()).cast();\n   |                                                - type must be known at this point                                   ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\n   = note: cannot satisfy `<u32 as std::ops::Add<_>>::Output == u32`\nhelp: consider specifying the generic argument\n   |\n75 |     let mut shortRepPrice: u32 = repMatchPrice + CmptPriceShortRep(encCtx.cast(), curState.cast(), posState.cast()).cast::<T>();\n   |                                                                                                                         +++++\n\nerror[E0283]: type annotations needed\n  --> src/src/encode/cmptlz_enc_dp_c.rs:75:117\n   |\n75 |     let mut shortRepPrice: u32 = repMatchPrice + CmptPriceShortRep(encCtx.cast(), curState.cast(), posState.cast()).cast();\n   |                                                - type must be known at this point                                   ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nnote: multiple `impl`s satisfying `u32: std::ops::Add<_>` found\n  --> src/translation_utils/types/num.rs:72:1\n   |\n72 | impl Add<Num> for u32 {\n   | ^^^^^^^^^^^^^^^^^^^^^\n   = note: and more `impl`s found in the following crates: `core`:\n           - impl std::ops::Add for u32;\n           - impl std::ops::Add<&u32> for u32;\nhelp: consider specifying the generic argument\n   |\n75 |     let mut shortRepPrice: u32 = repMatchPrice + CmptPriceShortRep(encCtx.cast(), curState.cast(), posState.cast()).cast::<T>();\n   |                                                                                                                         +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline void CmptlzDpTryCurAndLong(CmptLzEncCtx *encCtx, const uint32_t prefixPrice, const uint32_t cur,\n                                         uint32_t mainRepIndex, uint32_t lenEqual, const uint32_t posState)\n{\n    do\n    {\n        const uint32_t curLongRepPrice = prefixPrice + CmptPriceLen(&encCtx->repLenEncoder, lenEqual, posState);\n\n        if (curLongRepPrice < encCtx->opts[cur + lenEqual].price)\n        {\n            encCtx->opts[cur + lenEqual].price = curLongRepPrice;\n            encCtx->opts[cur + lenEqual].posPrev = cur;\n            encCtx->opts[cur + lenEqual].backPrev = mainRepIndex;\n        }\n    } while (--lenEqual >= CMPTLZ_MATCH_LEN_MIN);\n}",
            "rust_code": "pub fn CmptlzDpTryCurAndLong(mut encCtx: Ptr<CmptLzEncCtx>, mut prefixPrice: u32, mut cur: u32, mut mainRepIndex: u32, mut lenEqual: u32, mut posState: u32) {\n    c_do!({\n        let curLongRepPrice: u32 = (prefixPrice + CmptPriceLen(c_ref!(encCtx.repLenEncoder).cast(), lenEqual.cast(), posState.cast())).cast();\n        if (curLongRepPrice < encCtx.opts[cur + lenEqual].price).as_bool() {\n            encCtx.opts[cur + lenEqual].price = curLongRepPrice.cast();\n            encCtx.opts[cur + lenEqual].posPrev = cur.cast();\n            encCtx.opts[cur + lenEqual].backPrev = mainRepIndex.cast();\n        }\n    } while lenEqual.suffix_minus_minus() >= CMPTLZ_MATCH_LEN_MIN!());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104526942)\nerror[E0596]: cannot borrow `curLongRepPrice` as mutable, as it is not declared as mutable\n  --> src/src/encode/cmptlz_enc_dp_c.rs:83:49\n   |\n83 |             encCtx.opts[cur + lenEqual].price = curLongRepPrice.cast();\n   |                                                 ^^^^^^^^^^^^^^^ cannot borrow as mutable\n   |\nhelp: consider changing this to be mutable\n   |\n81 |         let mut curLongRepPrice: u32 = (prefixPrice + CmptPriceLen(c_ref!(encCtx.repLenEncoder).cast(), lenEqual.cast(), posState.cast())).cast();\n   |             +++\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void CmptlzDpTryCurAndMatch(CmptLzEncCtx *encCtx, uint32_t startLen, uint32_t matchCount,\n                                          const uint32_t normalmatch_prefixPrice, const uint32_t cur,\n                                          const uint32_t posState)\n{\n    uint32_t i = 0;\n    while (startLen > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    uint32_t lenTest;\n    for (lenTest = startLen;; lenTest++)\n    {\n        const uint32_t curBack = encCtx->matches[i].dist;\n        uint32_t cur_normalmatchPrice =\n            normalmatch_prefixPrice + CmptPriceDistWithLen(encCtx, curBack, lenTest, posState);\n        if (cur_normalmatchPrice < encCtx->opts[cur + lenTest].price)\n        {\n            encCtx->opts[cur + lenTest].price = cur_normalmatchPrice;\n            encCtx->opts[cur + lenTest].posPrev = cur;\n            encCtx->opts[cur + lenTest].backPrev = curBack + CMPTLZ_NUM_REPS;\n        }\n        if (lenTest == encCtx->matches[i].len)\n        {\n            if (++i == matchCount)\n            {\n                break;\n            }\n        }\n    }\n}",
            "rust_code": "pub fn CmptlzDpTryCurAndMatch(mut encCtx: Ptr<CmptLzEncCtx>, mut startLen: u32, mut matchCount: u32, mut normalmatch_prefixPrice: u32, mut cur: u32, mut posState: u32) {\n    let mut i: u32 = 0;\n    while (startLen > encCtx.matches[i].len).as_bool() {\n        i += 1;\n    }\n    let mut lenTest: u32;\n    c_for!(lenTest = startLen; ; lenTest += 1 {\n        let mut curBack: u32 = encCtx.matches[i].dist;\n        let mut cur_normalmatchPrice: u32 = normalmatch_prefixPrice + CmptPriceDistWithLen(encCtx.cast(), curBack.cast(), lenTest.cast(), posState.cast()).cast();\n        if (cur_normalmatchPrice < encCtx.opts[cur + lenTest].price).as_bool() {\n            encCtx.opts[cur + lenTest].price = cur_normalmatchPrice.cast();\n            encCtx.opts[cur + lenTest].posPrev = cur.cast();\n            encCtx.opts[cur + lenTest].backPrev = (curBack + CMPTLZ_NUM_REPS!()).cast();\n        }\n        if (lenTest == encCtx.matches[i].len).as_bool() {\n            if (i.prefix_plus_plus() == matchCount).as_bool() {\n                break;\n            }\n        }\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104527167)\nerror: no rules expected `{`\n  --> src/src/encode/cmptlz_enc_dp_c.rs:90:47\n   |\n90 |     c_for!(lenTest = startLen; ; lenTest += 1 {\n   |                                               ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_for.rs:3:1\n   |\n3  | macro_rules! c_for {\n   | ------------------ when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_for.rs:13:53\n   |\n13 |     ($($init: stmt),+; $cond: expr; $($step: expr),+; $body: block) => {\n   |                                                     ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                       uint32_t position, const uint32_t cur)\n{\n\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n\n        const uint32_t lenEqualMem = lenEqual;\n\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}",
            "rust_code": "pub fn CmptlzDpProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut mainReps: Ptr<u32>, mut lenEnd: u32, mut position: u32, mut cur: u32) -> u32 {\n    let mut curState: CmptlzState = encCtx.opts[cur].state;\n    let mut bufAvailFull: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf.cast()) + 1, CMPT_DP_OPTMAX!() - 1 - cur);\n    let mut buf: Ptr<u8> = CmptMfGetPtr(mf.cast()) - 1;\n    let mut niceLen: u32 = mf.niceLen;\n    let mut curPrice: u32 = encCtx.opts[cur].price;\n    let mut curByte: u8 = *buf;\n    let mut latestMatchByte: u8 = *(buf - mainReps[0] - 1);\n    let mut posState: u32 = position & encCtx.posMask;\n\n    encCtx.litMarcov.pos = position;\n    encCtx.litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx.cast(), curPrice.cast(), curState.cast(), posState.cast(), cur.cast(), latestMatchByte.cast(), curByte.cast());\n\n    let mut matchPrice: u32 = curPrice + CmptPriceBit1(encCtx.cast(), encCtx.isMatch[curState][posState].cast());\n    let mut repMatchPrice: u32 = matchPrice + CmptPriceBit1(encCtx.cast(), encCtx.isRep[curState].cast());\n\n    if (curByte == latestMatchByte).as_bool() && !(encCtx.opts[cur + 1].posPrev < cur && encCtx.opts[cur + 1].backPrev == 0).as_bool() {\n        CmptlzDpTryCurAndShort(encCtx.cast(), repMatchPrice.cast(), cur.cast(), curState.cast(), posState.cast());\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN!()).as_bool() {\n        return lenEnd.cast();\n    }\n    let mut bufAvail: u32 = CMPTLZ_FIND_MIN!(bufAvailFull, niceLen);\n    let mut startLen: u32 = CMPTLZ_MATCH_LEN_MIN!();\n\n    let mut mainRepIndex: u32;\n    c_for!(mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS!(); mainRepIndex.suffix_plus_plus(); {\n        let mut bufRepBack: Ptr<u8> = buf - mainReps[mainRepIndex] - 1;\n\n        if NOT_EQUAL_2_BYTES!(buf, bufRepBack).as_bool() {\n            continue;\n        }\n\n        let mut lenEqual: u32;\n        lenEqual = CmptMemCmpLenSafe(buf.cast(), bufRepBack.cast(), CMPTLZ_MATCH_LEN_MIN!(), bufAvail.cast()).cast();\n        while (lenEnd < cur + lenEqual).as_bool() {\n            lenEnd.suffix_plus_plus();\n            encCtx.opts[lenEnd].price = CMPT_INFINITY_PRICE!();\n        }\n\n        let mut lenEqualMem: u32 = lenEqual;\n\n        let mut prefixPrice: u32 = repMatchPrice + CmptPriceLongRep(encCtx.cast(), mainRepIndex.cast(), curState.cast(), posState.cast());\n\n        CmptlzDpTryCurAndLong(encCtx.cast(), prefixPrice.cast(), cur.cast(), mainRepIndex.cast(), lenEqual.cast(), posState.cast());\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0).as_bool() {\n            startLen = lenEqual + 1;\n        }\n    });\n\n    let mut newLongestLen: u32 = encCtx.longestMatchLen;\n    let mut matchCount: u32 = encCtx.matchesCount;\n\n    if (newLongestLen > bufAvail).as_bool() {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx.matches[matchCount].len).as_bool() {\n            matchCount.prefix_plus_plus();\n        }\n        encCtx.matches[matchCount].len = newLongestLen;\n        matchCount.suffix_plus_plus();\n    }\n\n    if (newLongestLen >= startLen).as_bool() {\n        let mut normalmatch_prefixPrice: u32 = matchPrice + CmptPriceBit0(encCtx.cast(), encCtx.isRep[curState].cast());\n\n        while (lenEnd < cur + newLongestLen).as_bool() {\n            lenEnd.suffix_plus_plus();\n            encCtx.opts[lenEnd].price = CMPT_INFINITY_PRICE!();\n        }\n        CmptlzDpTryCurAndMatch(encCtx.cast(), startLen.cast(), matchCount.cast(), normalmatch_prefixPrice.cast(), cur.cast(), posState.cast());\n    }\n    return lenEnd.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744104527392)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_dp_c.rs:100:33\n    |\n100 |     encCtx.litMarcov.prevByte = *(buf - 1);\n    |     -------------------------   ^^^^^^^^^^ expected `u32`, found `u8`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        }
    ]
}