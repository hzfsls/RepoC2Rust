{"All": 9, "Compilation Pass": 4, "Compilation Error": 5, "Pass Rate": 0.4444444444444444, "Error Information": [{"c_code": "void vosSha256Begin(VOS_SHA256_CTX *pstCtx)\n    {\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n        pstCtx->h[0] = 0x6a09e667UL;\n        pstCtx->h[1] = 0xbb67ae85UL;\n        pstCtx->h[2] = 0x3c6ef372UL;\n        pstCtx->h[3] = 0xa54ff53aUL;\n        pstCtx->h[4] = 0x510e527fUL;\n        pstCtx->h[5] = 0x9b05688cUL;\n        pstCtx->h[6] = 0x1f83d9abUL;\n        pstCtx->h[7] = 0x5be0cd19UL;\n        pstCtx->outlen = SHA256_DIGEST_SIZE;\n    }", "rust_code": "pub fn vosSha256Begin(mut pstCtx: Ptr<VOS_SHA256_CTX>) {\n    if (pstCtx == NULL!()).as_bool() {\n        return;\n    }\n\n    c_memset_s!(pstCtx, c_sizeof!(VOS_SHA256_CTX), 0, c_sizeof!(VOS_SHA256_CTX)).cast::<Void>();\n    pstCtx.h[0] = 0x6a09e667UL;\n    pstCtx.h[1] = 0xbb67ae85UL;\n    pstCtx.h[2] = 0x3c6ef372UL;\n    pstCtx.h[3] = 0xa54ff53aUL;\n    pstCtx.h[4] = 0x510e527fUL;\n    pstCtx.h[5] = 0x9b05688cUL;\n    pstCtx.h[6] = 0x1f83d9abUL;\n    pstCtx.h[7] = 0x5be0cd19UL;\n    pstCtx.outlen = SHA256_DIGEST_SIZE!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744103873919)\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:76:19\n   |\n76 |     pstCtx.h[0] = 0x6a09e667UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:77:19\n   |\n77 |     pstCtx.h[1] = 0xbb67ae85UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:78:19\n   |\n78 |     pstCtx.h[2] = 0x3c6ef372UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:79:19\n   |\n79 |     pstCtx.h[3] = 0xa54ff53aUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:80:19\n   |\n80 |     pstCtx.h[4] = 0x510e527fUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:81:19\n   |\n81 |     pstCtx.h[5] = 0x9b05688cUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:82:19\n   |\n82 |     pstCtx.h[6] = 0x1f83d9abUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:83:19\n   |\n83 |     pstCtx.h[7] = 0x5be0cd19UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"}, {"c_code": "static uint32_t vosSha256CtxPrepare(VOS_SHA256_CTX *pstCtx, uint32_t uiLen)\n    {\n        uint32_t uiCntFirst;\n        uint32_t uiCntSec;\n\n        uiCntFirst = (pstCtx->N[0] + (uiLen << SHIFTS_PER_BYTE)) & 0xffffffffUL;\n        if (uiCntFirst < pstCtx->N[0])\n        {\n            ++pstCtx->N[1];\n            if (pstCtx->N[1] == 0)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n        }\n\n        uiCntSec = pstCtx->N[1] + (uiLen >> (BITSIZE(uint32_t) - SHIFTS_PER_BYTE));\n        if (uiCntSec < pstCtx->N[1])\n        {\n            pstCtx->corrupted = 1;\n            return SHA256_ERROR;\n        }\n\n        pstCtx->N[1] = uiCntSec;\n        pstCtx->N[0] = uiCntFirst;\n        return SHA256_OK;\n    }", "rust_code": "pub fn vosSha256CtxPrepare(mut pstCtx: Ptr<VOS_SHA256_CTX>, mut uiLen: u32) -> u32 {\n    let mut uiCntFirst: u32;\n    let mut uiCntSec: u32;\n\n    uiCntFirst = (pstCtx.N[0] + (uiLen << SHIFTS_PER_BYTE!())) & 0xffffffffUL;\n    if (uiCntFirst < pstCtx.N[0]).as_bool() {\n        pstCtx.N[1].suffix_plus_plus();\n        if (pstCtx.N[1] == 0).as_bool() {\n            pstCtx.corrupted = 1;\n            return SHA256_ERROR!();\n        }\n    }\n\n    uiCntSec = pstCtx.N[1] + (uiLen >> (c_sizeof!(u32) * 8 - SHIFTS_PER_BYTE!()));\n    if (uiCntSec < pstCtx.N[1]).as_bool() {\n        pstCtx.corrupted = 1;\n        return SHA256_ERROR!();\n    }\n\n    pstCtx.N[1] = uiCntSec.cast();\n    pstCtx.N[0] = uiCntFirst.cast();\n    return SHA256_OK!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744103874073)\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:79:66\n   |\n79 |     uiCntFirst = (pstCtx.N[0] + (uiLen << SHIFTS_PER_BYTE!())) & 0xffffffffUL;\n   |                                                                  ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "static uint32_t vosSha256LastPadding(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx,\n                                         uint32_t *puiPaddingLen)\n    {\n        errno_t err;\n        uint32_t uiBlcLen = pstCtx->blocklen;\n        uint8_t *pucBlock = (uint8_t *)pstCtx->block;\n\n        if ((uiLen >= SHA256_BLOCK_SIZE) || (uiLen + uiBlcLen >= SHA256_BLOCK_SIZE))\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, SHA256_BLOCK_SIZE - uiBlcLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            *puiPaddingLen = SHA256_BLOCK_SIZE - uiBlcLen;\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n        }\n        else\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, uiLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            pstCtx->blocklen += (uint32_t)uiLen;\n            return SHA256_ERROR;\n        }\n\n        return SHA256_OK;\n    }", "rust_code": "pub fn vosSha256LastPadding(mut pucData: Ptr<u8>, mut uiLen: u32, mut pstCtx: Ptr<VOS_SHA256_CTX>, mut puiPaddingLen: Ptr<u32>) -> u32 {\n    let mut err: errno_t = Default::default();\n    let mut uiBlcLen: u32 = pstCtx.blocklen.cast();\n    let mut pucBlock: Ptr<u8> = pstCtx.block.cast::<Ptr<u8>>();\n\n    if (uiLen >= SHA256_BLOCK_SIZE!()).as_bool() || (uiLen + uiBlcLen >= SHA256_BLOCK_SIZE!()).as_bool() {\n        err = c_memcpy_s!(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE!() - uiBlcLen, pucData, SHA256_BLOCK_SIZE!() - uiBlcLen);\n        if (err != EOK!()).as_bool() {\n            pstCtx.corrupted = 1;\n            return SHA256_ERROR!();\n        }\n        vosSha256CompressMul(pstCtx.cast(), pucBlock.cast(), 1.cast());\n        *puiPaddingLen = (SHA256_BLOCK_SIZE!() - uiBlcLen).cast();\n        pstCtx.blocklen = 0;\n        c_memset_s!(pucBlock, SHA256_BLOCK_SIZE!(), 0, SHA256_BLOCK_SIZE!()).cast::<Void>();\n    } else {\n        err = c_memcpy_s!(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE!() - uiBlcLen, pucData, uiLen);\n        if (err != EOK!()).as_bool() {\n            pstCtx.corrupted = 1;\n            return SHA256_ERROR!();\n        }\n        pstCtx.blocklen += uiLen.cast();\n        return SHA256_ERROR!();\n    }\n\n    return SHA256_OK!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744103874221)\nerror[E0283]: type annotations needed\n   --> src/src/sha256_c.rs:101:34\n    |\n101 |         pstCtx.blocklen += uiLen.cast();\n    |                         --       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                         |\n    |                         type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `u32: std::ops::AddAssign<_>` found in the `core` crate:\n            - impl std::ops::AddAssign for u32;\n            - impl std::ops::AddAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n    |\n101 |         pstCtx.blocklen += uiLen.cast::<T>();\n    |                                      +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "static void vosSha256HashByBlcMulti(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        errno_t err;\n        uint32_t uiBlcLen;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        uiBlcLen = (uint32_t)(uiLenTmp / SHA256_BLOCK_SIZE);\n        if (uiBlcLen > 0)\n        {\n            vosSha256CompressMul(pstCtx, pucSrc, uiBlcLen);\n            uiBlcLen *= SHA256_BLOCK_SIZE;\n            pucSrc += uiBlcLen;\n            uiLenTmp -= uiBlcLen;\n        }\n\n        if (uiLenTmp != 0)\n        {\n            pstCtx->blocklen = (uint32_t)uiLenTmp;\n            err = memcpy_s((uint8_t *)pstCtx->block, SHA256_BLOCK_SIZE, pucSrc, uiLenTmp);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return;\n            }\n        }\n        return;\n    }", "rust_code": "pub fn vosSha256HashByBlcMulti(mut pucData: Ptr<u8>, mut uiLen: u32, mut pstCtx: Ptr<VOS_SHA256_CTX>) {\n    let mut err: errno_t = Default::default();\n    let mut uiBlcLen: u32;\n    let mut uiLenTmp: u32 = uiLen.cast();\n    let mut pucSrc: Ptr<u8> = pucData.cast();\n\n    uiBlcLen = (uiLenTmp / SHA256_BLOCK_SIZE!()).cast();\n    if (uiBlcLen > 0).as_bool() {\n        vosSha256CompressMul(pstCtx.cast(), pucSrc.cast(), uiBlcLen.cast());\n        uiBlcLen *= SHA256_BLOCK_SIZE!();\n        pucSrc += uiBlcLen;\n        uiLenTmp -= uiBlcLen;\n    }\n\n    if (uiLenTmp != 0).as_bool() {\n        pstCtx.blocklen = uiLenTmp.cast();\n        err = c_memcpy_s!(pstCtx.block.cast::<Ptr<u8>>(), SHA256_BLOCK_SIZE!(), pucSrc.cast(), uiLenTmp).cast();\n        if (err != EOK!()).as_bool() {\n            pstCtx.corrupted = 1;\n            return;\n        }\n    }\n    return;\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744103874375)\nerror[E0282]: type annotations needed\n   --> src/src/sha256_c.rs:101:88\n    |\n101 |         err = c_memcpy_s!(pstCtx.block.cast::<Ptr<u8>>(), SHA256_BLOCK_SIZE!(), pucSrc.cast(), uiLenTmp).cast();\n    |                                                                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n101 |         err = c_memcpy_s!(pstCtx.block.cast::<Ptr<u8>>(), SHA256_BLOCK_SIZE!(), pucSrc.cast::<T>(), uiLenTmp).cast();\n    |                                                                                            +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void VOS_Sha256Calc(const uint8_t *pucInput, uint32_t uiInputLen, uint8_t *pucOutput, uint32_t uiOutputLen)\n    {\n        VOS_SHA256_CTX stCtx;\n\n        vosSha256Begin(&stCtx);\n        vosSha256Hash(pucInput, uiInputLen, &stCtx);\n        vosSha256End(pucOutput, uiOutputLen, &stCtx);\n    }", "rust_code": "", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744103875193)\nerror[E0432]: unresolved import `crate::src::sha256_c::VOS_Sha256Calc`\n --> src/include/sha256_h.rs:3:9\n  |\n3 | pub use crate::src::sha256_c::VOS_Sha256Calc;\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `VOS_Sha256Calc` in `src::sha256_c`\n\nFor more information about this error, try `rustc --explain E0432`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}]}