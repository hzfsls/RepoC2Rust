{
    "All": 50,
    "Compilation Pass": 30,
    "Compilation Error": 20,
    "Pass Rate": 0.6,
    "Error Information": [
        {
            "c_code": "static inline int RapidlzIsLE(void)\n    {\n#if (defined(__GNUC__) || defined(__clang__))\n        return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n        int n = 1;\n        return *(char *)(&n);\n    }",
            "rust_code": "pub fn RapidlzIsLE() -> i32 {\n    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\", target_arch = \"arm\", target_arch = \"aarch64\"))]\n    {\n        return (__BYTE_ORDER__!() == __ORDER_LITTLE_ENDIAN__!()).cast();\n    }\n    #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\", target_arch = \"arm\", target_arch = \"aarch64\")))]\n    {\n        let mut n: i32 = 1;\n        return (*c_ref!(n).cast::<Ptr<u8>>()).cast();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104627816)\nerror: cannot find macro `__BYTE_ORDER__` in this scope\n   --> src/src/rapidlz_inner_h.rs:181:17\n    |\n181 |         return (__BYTE_ORDER__!() == __ORDER_LITTLE_ENDIAN__!()).cast();\n    |                 ^^^^^^^^^^^^^^\n\nerror: cannot find macro `__ORDER_LITTLE_ENDIAN__` in this scope\n   --> src/src/rapidlz_inner_h.rs:181:38\n    |\n181 |         return (__BYTE_ORDER__!() == __ORDER_LITTLE_ENDIAN__!()).cast();\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint8_t RapidlzHighBit64(uint64_t x)\n    {\n        RAPIDLZ_ASSERT(x != 0);\n\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return ((uint8_t)__builtin_clzll(x) ^ 63);\n#endif\n        uint8_t pos = 64;\n        uint64_t value = x;\n\n        if (value == 0)\n        {\n            return 0;\n        }\n        if ((value & 0xFFFFFFFF00000000) == 0)\n        {\n            value <<= 32;\n            pos -= 32;\n        }\n        if ((value & 0xFFFF000000000000) == 0)\n        {\n            value <<= 16;\n            pos -= 16;\n        }\n        if ((value & 0xFF00000000000000) == 0)\n        {\n            value <<= 8;\n            pos -= 8;\n        }\n        if ((value & 0xF000000000000000) == 0)\n        {\n            value <<= 4;\n            pos -= 4;\n        }\n        if ((value & 0xC000000000000000) == 0)\n        {\n            value <<= 2;\n            pos -= 2;\n        }\n        if ((value & 0x8000000000000000) == 0)\n        {\n            value <<= 1;\n            pos -= 1;\n        }\n\n        return pos - 1;\n    }",
            "rust_code": "pub fn RapidlzHighBit64(mut x: u64) -> u8 {\n    RAPIDLZ_ASSERT!(x != 0);\n\n    #[cfg(all(defined(__GNUC__), __GNUC__ >= 3))]\n    return (__builtin_clzll(x) ^ 63).cast::<u8>();\n\n    let mut pos: u8 = 64;\n    let mut value: u64 = x;\n\n    if (value == 0).as_bool() {\n        return 0;\n    }\n    if ((value & 0xFFFFFFFF00000000) == 0).as_bool() {\n        value <<= 32;\n        pos -= 32;\n    }\n    if ((value & 0xFFFF000000000000) == 0).as_bool() {\n        value <<= 16;\n        pos -= 16;\n    }\n    if ((value & 0xFF00000000000000) == 0).as_bool() {\n        value <<= 8;\n        pos -= 8;\n    }\n    if ((value & 0xF000000000000000) == 0).as_bool() {\n        value <<= 4;\n        pos -= 4;\n    }\n    if ((value & 0xC000000000000000) == 0).as_bool() {\n        value <<= 2;\n        pos -= 2;\n    }\n    if ((value & 0x8000000000000000) == 0).as_bool() {\n        value <<= 1;\n        pos -= 1;\n    }\n\n    return (pos - 1).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104628517)\nerror: expected unsuffixed literal, found `>=`\n   --> src/src/rapidlz_inner_h.rs:232:43\n    |\n232 |     #[cfg(all(defined(__GNUC__), __GNUC__ >= 3))]\n    |                                           ^^\n\nerror[E0425]: cannot find function `__builtin_clzll` in this scope\n   --> src/src/rapidlz_inner_h.rs:233:13\n    |\n233 |     return (__builtin_clzll(x) ^ 63).cast::<u8>();\n    |             ^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline void RapidlzCopy16Byte(void *dst, const void *src)\n    {\n#if defined(ARM_NEON)\n        vst1q_u8((uint8_t *)dst, vld1q_u8((const uint8_t *)src));\n#elif defined(X86_SSE2)\n    _mm_storeu_si128((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n#else\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 8, RAPIDLZ_READ64BIT((uint8_t *)src + 8));\n#endif\n    }",
            "rust_code": "pub fn RapidlzCopy16Byte(mut dst: Ptr<Void>, mut src: Ptr<Void>) {\n    #[cfg(ARM_NEON)]\n    {\n        vst1q_u8!(dst.cast::<Ptr<u8>>(), vld1q_u8!(src.cast::<Ptr<u8>>()));\n    }\n    #[cfg(X86_SSE2)]\n    {\n        _mm_storeu_si128!(dst.cast::<Ptr<__m128i>>(), _mm_loadu_si128!(src.cast::<Ptr<__m128i>>()));\n    }\n    #[cfg(not(any(ARM_NEON, X86_SSE2)))]\n    {\n        RAPIDLZ_WRITE64BIT!(dst.cast(), RAPIDLZ_READ64BIT!(src.cast()));\n        RAPIDLZ_WRITE64BIT!((dst.cast::<Ptr<u8>>() + 8).cast(), RAPIDLZ_READ64BIT!((src.cast::<Ptr<u8>>() + 8).cast()));\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104629052)\nerror[E0282]: type annotations needed\n   --> src/src/rapidlz_inner_h.rs:277:33\n    |\n277 |         RAPIDLZ_WRITE64BIT!(dst.cast(), RAPIDLZ_READ64BIT!(src.cast()));\n    |                                 ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n277 |         RAPIDLZ_WRITE64BIT!(dst.cast::<T>(), RAPIDLZ_READ64BIT!(src.cast()));\n    |                                     +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline const uint8_t *RapidlzCompressExpandBackward(const uint8_t *matchLimit, const uint8_t *matchPtr,\n                                                               const uint8_t *srcCurr)\n    {\n        uint64_t xorVal;\n        const uint8_t *loopEnd = matchLimit - 7;\n        const uint8_t *srcCurrMatchEnd = srcCurr;\n        const uint8_t *matchBegin = matchPtr;\n\n        while (srcCurrMatchEnd < loopEnd)\n        {\n            xorVal = RAPIDLZ_READ64BIT(matchBegin) ^ RAPIDLZ_READ64BIT(srcCurrMatchEnd);\n            if (RAPIDLZ_UNLIKELY(xorVal == 0))\n            {\n                srcCurrMatchEnd += sizeof(uint64_t);\n                matchBegin += sizeof(uint64_t);\n                continue;\n            }\n            srcCurrMatchEnd +=\n                RapidlzIsLE() ? (RapidlzCountTailZero64(xorVal) >> 3) : (RapidlzCountLeadZero64(xorVal) >> 3);\n            return srcCurrMatchEnd;\n        }\n\n        if (((srcCurrMatchEnd + 3) < matchLimit) &&\n            (RAPIDLZ_READ32BIT(srcCurrMatchEnd) == RAPIDLZ_READ32BIT(matchBegin)))\n        {\n            srcCurrMatchEnd += sizeof(uint32_t);\n            matchBegin += sizeof(uint32_t);\n        }\n\n        if (((srcCurrMatchEnd + 1) < matchLimit) &&\n            (RAPIDLZ_READ16BIT(srcCurrMatchEnd) == RAPIDLZ_READ16BIT(matchBegin)))\n        {\n            srcCurrMatchEnd += sizeof(uint16_t);\n            matchBegin += sizeof(uint16_t);\n        }\n\n        if ((srcCurrMatchEnd < matchLimit) && (srcCurrMatchEnd[0] == matchBegin[0]))\n        {\n            srcCurrMatchEnd++;\n        }\n        return srcCurrMatchEnd;\n    }",
            "rust_code": "pub fn RapidlzCompressExpandBackward(mut matchLimit: Ptr<u8>, mut matchPtr: Ptr<u8>, mut srcCurr: Ptr<u8>) -> Ptr<u8> {\n    let mut xorVal: u64;\n    let mut loopEnd: Ptr<u8> = (matchLimit - 7).cast();\n    let mut srcCurrMatchEnd: Ptr<u8> = srcCurr.cast();\n    let mut matchBegin: Ptr<u8> = matchPtr.cast();\n\n    while (srcCurrMatchEnd < loopEnd).as_bool() {\n        xorVal = RAPIDLZ_READ64BIT!(matchBegin) ^ RAPIDLZ_READ64BIT!(srcCurrMatchEnd);\n        if RAPIDLZ_UNLIKELY!(xorVal == 0).as_bool() {\n            srcCurrMatchEnd += c_sizeof!(u64);\n            matchBegin += c_sizeof!(u64);\n            continue;\n        }\n        srcCurrMatchEnd += if RapidlzIsLE().as_bool() {\n            (RapidlzCountTailZero64(xorVal) >> 3).cast()\n        } else {\n            (RapidlzCountLeadZero64(xorVal) >> 3).cast()\n        };\n        return srcCurrMatchEnd.cast();\n    }\n\n    if (((srcCurrMatchEnd + 3) < matchLimit).as_bool() &&\n        (RAPIDLZ_READ32BIT!(srcCurrMatchEnd) == RAPIDLZ_READ32BIT!(matchBegin)).as_bool() {\n        srcCurrMatchEnd += c_sizeof!(u32);\n        matchBegin += c_sizeof!(u32);\n    }\n\n    if (((srcCurrMatchEnd + 1) < matchLimit).as_bool() &&\n        (RAPIDLZ_READ16BIT!(srcCurrMatchEnd) == RAPIDLZ_READ16BIT!(matchBegin)).as_bool() {\n        srcCurrMatchEnd += c_sizeof!(u16);\n        matchBegin += c_sizeof!(u16);\n    }\n\n    if ((srcCurrMatchEnd < matchLimit).as_bool() && (srcCurrMatchEnd[0] == matchBegin[0]).as_bool() {\n        srcCurrMatchEnd += 1;\n    }\n    return srcCurrMatchEnd.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104630099)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_inner_h.rs:358:8\n    |\n325 | pub fn RapidlzCompressExpandBackward(mut matchLimit: Ptr<u8>, mut matchPtr: Ptr<u8>, mut srcCurr: Ptr<u8>) -> Ptr<u8> {\n    |                                                                                                                       - closing delimiter possibly meant for this\n...\n358 |     if ((srcCurrMatchEnd < matchLimit).as_bool() && (srcCurrMatchEnd[0] == matchBegin[0]).as_bool() {\n    |        ^ unclosed delimiter\n...\n362 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline int RapidlzZeroBytesEncode(char *dest, int destSize)\n    {\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(destSize <= 0), RAPIDLZ_ENC_NOT_OK);\n        dest[0] = 0;\n        return 1;\n    }",
            "rust_code": "pub fn RapidlzZeroBytesEncode(mut dest: Ptr<u8>, mut destSize: i32) -> i32 {\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(destSize <= 0).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    dest[0] = 0;\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104631646)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:286:5\n    |\n286 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(destSize <= 0).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:286:5\n    |\n286 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(destSize <= 0).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static int RapidlzEncLastLiterals(uint8_t *curSrcAnchor, uint8_t *srcEnd, uint8_t *curDest, uint8_t *destEnd,\n                                      char *destStart)\n    {\n        size_t lastLiteralsLen = (size_t)(srcEnd - curSrcAnchor);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_LITERAL_LEN_COPY_END(curDest, lastLiteralsLen) > destEnd),\n                                   RAPIDLZ_ENC_NOT_OK);\n        curDest += RapidlzStoreLiteralLen(lastLiteralsLen, curDest);\n        RAPIDLZ_RETURN_IF_NOT_EOK(memcpy_s(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen),\n                                  RAPIDLZ_ENC_NOT_OK);\n        curDest += lastLiteralsLen;\n        return (int)((void *)curDest - (void *)destStart);\n    }",
            "rust_code": "pub fn RapidlzEncLastLiterals(mut curSrcAnchor: Ptr<u8>, mut srcEnd: Ptr<u8>, mut curDest: Ptr<u8>, mut destEnd: Ptr<u8>, mut destStart: Ptr<u8>) -> i32 {\n    let mut lastLiteralsLen: usize = (srcEnd - curSrcAnchor).cast();\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(RAPIDLZ_LITERAL_LEN_COPY_END!(curDest, lastLiteralsLen) > destEnd).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    curDest += RapidlzStoreLiteralLen(lastLiteralsLen.cast(), curDest.cast()).cast();\n    RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen), RAPIDLZ_ENC_NOT_OK!());\n    curDest += lastLiteralsLen;\n    return (curDest.cast::<Ptr<Void>>() - destStart.cast::<Ptr<Void>>()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104631830)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:294:5\n    |\n294 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:294:5\n    |\n294 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:292:5\n    |\n292 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(RAPIDLZ_LITERAL_LEN_COPY_END!(curDest, lastLiteralsLen) > destEnd).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     ---------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:292:5\n    |\n292 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(RAPIDLZ_LITERAL_LEN_COPY_END!(curDest, lastLiteralsLen) > destEnd).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     ---------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `EOK`\n   --> src/src/rapidlz_dictionary_c.rs:102:26\n    |\n102 |         if $condition != EOK {\n    |                          ^^^ not a value\n...\n294 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline bool RapidlzStreamEncLiterals(uint8_t *curSrc, uint8_t *curSrcAnchor, uint8_t **curDest,\n                                                uint8_t *destEnd)\n    {\n        uint32_t litLen = curSrc - curSrcAnchor;\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_UNLIKELY(RAPIDLZ_LITERAL_LEN_COPY_END(*curDest, litLen) > destEnd)),\n                                   false);\n        *curDest += RapidlzStoreLiteralLen(litLen, *curDest);\n        RapidlzWildCopy8(curSrcAnchor, *curDest, *curDest + litLen);\n        *curDest += litLen;\n        return true;\n    }",
            "rust_code": "pub fn RapidlzStreamEncLiterals(mut curSrc: Ptr<u8>, mut curSrcAnchor: Ptr<u8>, mut curDest: Ptr<Ptr<u8>>, mut destEnd: Ptr<u8>) -> bool {\n    let mut litLen: u32 = (curSrc - curSrcAnchor).cast();\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(RAPIDLZ_UNLIKELY!(RAPIDLZ_LITERAL_LEN_COPY_END!(*curDest, litLen) > destEnd).as_bool()), false);\n    *curDest += RapidlzStoreLiteralLen(litLen.cast(), *curDest.cast()).cast();\n    RapidlzWildCopy8(curSrcAnchor.cast(), *curDest.cast(), (*curDest + litLen).cast());\n    *curDest += litLen;\n    return true;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104632015)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:297:5\n    |\n297 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(RAPIDLZ_UNLIKELY!(RAPIDLZ_LITERAL_LEN_COPY_END!(*curDest, litLen) > destEnd).as_bool()), false);\n    |     ----------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:297:5\n    |\n297 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(RAPIDLZ_UNLIKELY!(RAPIDLZ_LITERAL_LEN_COPY_END!(*curDest, litLen) > destEnd).as_bool()), false);\n    |     ----------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int RapidlzLoadDict(RapidlzStreamCtx *strmCtx, const char *dictionary, int dictSize)\n    {\n        const uint8_t *dictStart = (const uint8_t *)dictionary;\n        const uint8_t *dictEnd = (const uint8_t *)dictionary + dictSize;\n        RAPIDLZ_RETURN_IF_NOT_EOK(memset_s(strmCtx, sizeof(RapidlzStreamCtx), 0, sizeof(RapidlzStreamCtx)),\n                                  RAPIDLZ_ENC_NOT_OK);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES), RAPIDLZ_ENC_NOT_OK);\n\n        if (dictSize > RAPIDLZ_MAX_DICT_SIZE)\n        {\n            dictStart = dictEnd - RAPIDLZ_MAX_DICT_SIZE;\n        }\n\n        strmCtx->dict = (uint8_t *)dictStart;\n        strmCtx->dictSize = dictEnd - dictStart;\n        strmCtx->currentOffset = RAPIDLZ_MAX_DICT_SIZE;\n\n        uint32_t index32 = strmCtx->currentOffset - strmCtx->dictSize;\n\n        const uint8_t *curDict = dictStart;\n        while (curDict <= dictEnd - RAPIDLZ_STREAM_HASH_BYTES)\n        {\n            uint32_t hashValue = RapidlzHash4CalcValue(curDict);\n            RapidlzHash4PutPos(index32, hashValue, strmCtx->hashTable);\n            curDict += RAPIDLZ_DICT_HASH_MOVE_BYTES;\n            index32 += RAPIDLZ_DICT_HASH_MOVE_BYTES;\n        }\n\n        return (int)strmCtx->dictSize;\n    }",
            "rust_code": "pub fn RapidlzLoadDict(mut strmCtx: Ptr<RapidlzStreamCtx>, mut dictionary: Ptr<u8>, mut dictSize: i32) -> i32 {\n    let mut dictStart: Ptr<u8> = dictionary.cast::<Ptr<u8>>();\n    let mut dictEnd: Ptr<u8> = (dictionary + dictSize).cast::<Ptr<u8>>();\n    RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n\n    if (dictSize > RAPIDLZ_MAX_DICT_SIZE!()).as_bool() {\n        dictStart = (dictEnd - RAPIDLZ_MAX_DICT_SIZE!()).cast::<Ptr<u8>>();\n    }\n\n    strmCtx.dict = dictStart.cast();\n    strmCtx.dictSize = (dictEnd - dictStart).cast();\n    strmCtx.currentOffset = RAPIDLZ_MAX_DICT_SIZE!();\n\n    let mut index32: u32 = (strmCtx.currentOffset - strmCtx.dictSize).cast();\n\n    let mut curDict: Ptr<u8> = dictStart.cast();\n    while (curDict <= dictEnd - RAPIDLZ_STREAM_HASH_BYTES!()).as_bool() {\n        let mut hashValue: u32 = RapidlzHash4CalcValue(curDict.cast()).cast();\n        RapidlzHash4PutPos(index32.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n        curDict += RAPIDLZ_DICT_HASH_MOVE_BYTES!();\n        index32 += RAPIDLZ_DICT_HASH_MOVE_BYTES!();\n    }\n\n    return strmCtx.dictSize.cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104632194)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:304:5\n    |\n304 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     -------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:304:5\n    |\n304 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     -------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:303:5\n    |\n303 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:303:5\n    |\n303 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `EOK`\n   --> src/src/rapidlz_dictionary_c.rs:102:26\n    |\n102 |         if $condition != EOK {\n    |                          ^^^ not a value\n...\n303 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int RapidlzCompWithExternalDict(RapidlzStreamCtx *strmCtx, const char *src, char *dest, int srcSize, int destSize)\n    {\n\n        uint8_t *curSrc = (uint8_t *)src;\n        uint8_t *curSrcAnchor = (uint8_t *)curSrc;\n        uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + destSize;\n        if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH)\n        {\n            return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n        }\n\n        uint8_t *matchStartLimit = srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE + 1;\n        uint8_t *matchEndLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        uint32_t startIndex = strmCtx->currentOffset;\n        uint8_t *base = (uint8_t *)src - startIndex;\n\n        const uint8_t *dict, *dictBase, *dictEnd, *prefixDictStart;\n        uint32_t dictSize;\n        uint32_t offset = 0;\n\n        dict = strmCtx->dict;\n        dictSize = strmCtx->dictSize;\n        dictBase = dict + dictSize - strmCtx->currentOffset;\n        prefixDictStart = 0;\n        dictBase = dict + dictSize - strmCtx->currentOffset;\n        dictEnd = dict + dictSize;\n        strmCtx->dictSize += srcSize;\n\n        uint32_t prefixDictLimit = startIndex - dictSize;\n        strmCtx->currentOffset += (uint32_t)srcSize;\n\n        uint32_t hashValue = RapidlzHash4CalcValue(curSrc);\n        RapidlzHash4PutPos(startIndex, hashValue, strmCtx->hashTable);\n        curSrc++;\n        uint32_t forwardHashValue = RapidlzHash4CalcValue(curSrc);\n\n        const uint8_t *match;\n        uint8_t *token;\n        int acceleration = strmCtx->acceleration;\n        while (true)\n        {\n            uint8_t *forwardPos = curSrc;\n            int jumpStep = 1;\n            int searchMatchNb = acceleration << RAPIDLZ_STEP_FORWARD_BASE;\n            do\n            {\n                hashValue = forwardHashValue;\n                uint32_t current = (forwardPos - base);\n                uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n                curSrc = forwardPos;\n                forwardPos += jumpStep;\n                jumpStep = (searchMatchNb++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (RAPIDLZ_UNLIKELY(forwardPos > matchStartLimit))\n                {\n                    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n                }\n\n                if (matchOffset < startIndex)\n                {\n\n                    match = dictBase + matchOffset;\n                    prefixDictStart = dict;\n                }\n                else\n                {\n                    match = base + matchOffset;\n                    prefixDictStart = (uint8_t *)src;\n                }\n\n                forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n                RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n                RAPIDLZ_CONTINUE_IF_NOT_A_MATCH(matchOffset, prefixDictLimit, current);\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    offset = current - matchOffset;\n                    break;\n                }\n            } while (1);\n\n            RAPIDLZ_EXPAND_FORWARD(prefixDictStart, match, curSrc, curSrcAnchor);\n\n            token = curDest;\n            RAPIDLZ_RETURN_IF_NOT_TRUE(RapidlzStreamEncLiterals(curSrc, curSrcAnchor, &curDest, destEnd),\n                                       RAPIDLZ_ENC_NOT_OK);\n\n        _OFFSET_AND_MATCH:\n\n            RapidlzWriteLE16(curDest, offset);\n            curDest += 2;\n\n            uint32_t matchLen;\n            uint8_t *curSrcMatchEnd;\n\n            if (prefixDictStart == dict)\n            {\n                uint8_t *srcLimitOnlyWithDict = curSrc + (dictEnd - match);\n                if (srcLimitOnlyWithDict > matchEndLimit)\n                {\n                    srcLimitOnlyWithDict = matchEndLimit;\n                }\n                curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(\n                    srcLimitOnlyWithDict, match + RAPIDLZ_MIN_MATCH, curSrc + RAPIDLZ_MIN_MATCH);\n                matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n                curSrc = curSrcMatchEnd;\n\n                if (curSrc == srcLimitOnlyWithDict)\n                {\n                    curSrcMatchEnd =\n                        (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, (uint8_t *)src, srcLimitOnlyWithDict);\n                    matchLen += (curSrcMatchEnd - curSrc);\n                    curSrc = curSrcMatchEnd;\n                }\n            }\n            else\n            {\n                curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, match + RAPIDLZ_MIN_MATCH,\n                                                                          curSrc + RAPIDLZ_MIN_MATCH);\n                matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n                curSrc = curSrcMatchEnd;\n            }\n#ifdef RAPIDLZ_DEBUG\n            if (RAPIDLZ_UNLIKELY(RAPIDLZ_LIT_AND_MATCH_COPY_END(curDest, matchLen) > destEnd))\n            {\n                return RAPIDLZ_ENC_NOT_OK;\n            }\n#endif\n            curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n            curSrcAnchor = curSrc;\n            if (curSrc >= matchStartLimit)\n            {\n                break;\n            }\n            uint32_t hv2 = RapidlzHash4CalcValue(curSrc - 2);\n            uint32_t index = curSrc - 2 - base;\n            RapidlzHash4PutPos(index, hv2, strmCtx->hashTable);\n\n            hashValue = RapidlzHash4CalcValue(curSrc);\n            uint32_t current = (curSrc - base);\n            uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n            if (matchOffset < startIndex)\n            {\n\n                match = dictBase + matchOffset;\n                prefixDictStart = dict;\n            }\n            else\n            {\n                match = base + matchOffset;\n                prefixDictStart = (uint8_t *)src;\n            }\n\n            RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n\n            if ((matchOffset >= prefixDictLimit) && (matchOffset + RAPIDLZ_MAX_OFFSET >= current))\n            {\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    token = curDest++;\n                    *token = 0;\n                    offset = current - matchOffset;\n                    goto _OFFSET_AND_MATCH;\n                }\n            }\n            forwardHashValue = RapidlzHash4CalcValue(++curSrc);\n        }\n\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }",
            "rust_code": "pub fn RapidlzCompWithExternalDict(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut destSize: i32) -> i32 {\n    let mut curSrc: Ptr<u8> = src.cast();\n    let mut curSrcAnchor: Ptr<u8> = curSrc.cast();\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize).cast();\n    let mut curDest: Ptr<u8> = dest.cast();\n    let mut destEnd: Ptr<u8> = (curDest + destSize).cast();\n    if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH!()).as_bool() {\n        return RapidlzEncLastLiterals(curSrcAnchor.cast(), srcEnd.cast(), curDest.cast(), destEnd.cast(), dest.cast());\n    }\n\n    let mut matchStartLimit: Ptr<u8> = (srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE!() + 1).cast();\n    let mut matchEndLimit: Ptr<u8> = (srcEnd - RAPIDLZ_LAST_LITERALS!()).cast();\n    let mut startIndex: u32 = strmCtx.currentOffset.cast();\n    let mut base: Ptr<u8> = (src.cast::<Ptr<u8>>() - startIndex).cast();\n\n    let mut dict: Ptr<u8> = Default::default();\n    let mut dictBase: Ptr<u8> = Default::default();\n    let mut dictEnd: Ptr<u8> = Default::default();\n    let mut prefixDictStart: Ptr<u8> = Default::default();\n    let mut dictSize: u32 = Default::default();\n    let mut offset: u32 = 0;\n\n    dict = strmCtx.dict.cast();\n    dictSize = strmCtx.dictSize.cast();\n    dictBase = (dict + dictSize - strmCtx.currentOffset).cast();\n    prefixDictStart = 0.cast();\n    dictBase = (dict + dictSize - strmCtx.currentOffset).cast();\n    dictEnd = (dict + dictSize).cast();\n    strmCtx.dictSize += srcSize.cast();\n\n    let mut prefixDictLimit: u32 = (startIndex - dictSize).cast();\n    strmCtx.currentOffset += srcSize.cast::<u32>();\n\n    let mut hashValue: u32 = RapidlzHash4CalcValue(curSrc.cast()).cast();\n    RapidlzHash4PutPos(startIndex.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n    curSrc += 1;\n    let mut forwardHashValue: u32 = RapidlzHash4CalcValue(curSrc.cast()).cast();\n\n    let mut r#match: Ptr<u8> = Default::default();\n    let mut token: Ptr<u8> = Default::default();\n    let mut acceleration: i32 = strmCtx.acceleration.cast();\n    loop {\n        let mut forwardPos: Ptr<u8> = curSrc.cast();\n        let mut jumpStep: i32 = 1;\n        let mut searchMatchNb: i32 = acceleration << RAPIDLZ_STEP_FORWARD_BASE!();\n        loop {\n            hashValue = forwardHashValue.cast();\n            let mut current: u32 = (forwardPos - base).cast();\n            let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue.cast(), strmCtx.hashTable.cast()).cast();\n            curSrc = forwardPos.cast();\n            forwardPos += jumpStep;\n            jumpStep = (searchMatchNb >> RAPIDLZ_STEP_FORWARD_BASE!());\n            searchMatchNb += 1;\n\n            if RAPIDLZ_UNLIKELY!(forwardPos > matchStartLimit).as_bool() {\n                return RapidlzEncLastLiterals(curSrcAnchor.cast(), srcEnd.cast(), curDest.cast(), destEnd.cast(), dest.cast());\n            }\n\n            if (matchOffset < startIndex).as_bool() {\n                r#match = (dictBase + matchOffset).cast();\n                prefixDictStart = dict.cast();\n            } else {\n                r#match = (base + matchOffset).cast();\n                prefixDictStart = src.cast();\n            }\n\n            forwardHashValue = RapidlzHash4CalcValue(forwardPos.cast()).cast();\n            RapidlzHash4PutPos(current.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n            RAPIDLZ_CONTINUE_IF_NOT_A_MATCH!(matchOffset, prefixDictLimit, current);\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(r#match)).as_bool() {\n                offset = (current - matchOffset).cast();\n                break;\n            }\n        }\n\n        RAPIDLZ_EXPAND_FORWARD!(prefixDictStart, r#match, curSrc, curSrcAnchor);\n\n        token = curDest.cast();\n        if !RapidlzStreamEncLiterals(curSrc.cast(), curSrcAnchor.cast(), c_ref!(curDest).cast(), destEnd.cast()).as_bool() {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n\n        _OFFSET_AND_MATCH:\n\n        RapidlzWriteLE16(curDest.cast(), offset.cast());\n        curDest += 2;\n\n        let mut matchLen: u32;\n        let mut curSrcMatchEnd: Ptr<u8>;\n\n        if (prefixDictStart == dict).as_bool() {\n            let mut srcLimitOnlyWithDict: Ptr<u8> = (curSrc + (dictEnd - r#match)).cast();\n            if (srcLimitOnlyWithDict > matchEndLimit).as_bool() {\n                srcLimitOnlyWithDict = matchEndLimit.cast();\n            }\n            curSrcMatchEnd = RapidlzCompressExpandBackward(srcLimitOnlyWithDict.cast(), (r#match + RAPIDLZ_MIN_MATCH!()).cast(), (curSrc + RAPIDLZ_MIN_MATCH!()).cast()).cast();\n            matchLen = (curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH!()).cast::<u32>();\n            curSrc = curSrcMatchEnd.cast();\n\n            if (curSrc == srcLimitOnlyWithDict).as_bool() {\n                curSrcMatchEnd = RapidlzCompressExpandBackward(matchEndLimit.cast(), src.cast(), srcLimitOnlyWithDict.cast()).cast();\n                matchLen += (curSrcMatchEnd - curSrc).cast::<u32>();\n                curSrc = curSrcMatchEnd.cast();\n            }\n        } else {\n            curSrcMatchEnd = RapidlzCompressExpandBackward(matchEndLimit.cast(), (r#match + RAPIDLZ_MIN_MATCH!()).cast(), (curSrc + RAPIDLZ_MIN_MATCH!()).cast()).cast();\n            matchLen = (curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH!()).cast::<u32>();\n            curSrc = curSrcMatchEnd.cast();\n        }\n        #[cfg(RAPIDLZ_DEBUG)]\n        if RAPIDLZ_UNLIKELY!((RAPIDLZ_LIT_AND_MATCH_COPY_END!(curDest, matchLen) > destEnd).as_bool() {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n        curDest += RapidlzStoreMatchLen(matchLen.cast(), token.cast(), curDest.cast()).cast();\n        curSrcAnchor = curSrc.cast();\n        if (curSrc >= matchStartLimit).as_bool() {\n            break;\n        }\n        let mut hv2: u32 = RapidlzHash4CalcValue((curSrc - 2).cast()).cast();\n        let mut index: u32 = (curSrc - 2 - base).cast();\n        RapidlzHash4PutPos(index.cast(), hv2.cast(), strmCtx.hashTable.cast());\n\n        hashValue = RapidlzHash4CalcValue(curSrc.cast()).cast();\n        let mut current: u32 = (curSrc - base).cast();\n        let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue.cast(), strmCtx.hashTable.cast()).cast();\n        if (matchOffset < startIndex).as_bool() {\n            r#match = (dictBase + matchOffset).cast();\n            prefixDictStart = dict.cast();\n        } else {\n            r#match = (base + matchOffset).cast();\n            prefixDictStart = src.cast();\n        }\n\n        RapidlzHash4PutPos(current.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n\n        if (matchOffset >= prefixDictLimit).as_bool() && (matchOffset + RAPIDLZ_MAX_OFFSET!() >= current).as_bool() {\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(r#match)).as_bool() {\n                token = curDest.cast();\n                curDest += 1;\n                *token = 0;\n                offset = (current - matchOffset).cast();\n                goto!(_OFFSET_AND_MATCH);\n            }\n        }\n        forwardHashValue = RapidlzHash4CalcValue(curSrc.prefix_plus_plus().cast()).cast();\n    }\n\n    return RapidlzEncLastLiterals(curSrcAnchor.cast(), srcEnd.cast(), curDest.cast(), destEnd.cast(), dest.cast());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104632377)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:415:29\n    |\n346 |     loop {\n    |          - closing delimiter possibly meant for this\n...\n415 |         if RAPIDLZ_UNLIKELY!((RAPIDLZ_LIT_AND_MATCH_COPY_END!(curDest, matchLen) > destEnd).as_bool() {\n    |                             ^ unclosed delimiter\n...\n450 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int RapidlzCompWithPrefixDict(RapidlzStreamCtx *strmCtx, const char *src, char *dest, int srcSize, int destSize)\n    {\n        uint8_t *curSrc = (uint8_t *)src;\n        uint8_t *curSrcAnchor = (uint8_t *)curSrc;\n        uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + destSize;\n        if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH)\n        {\n            return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n        }\n        uint8_t *matchStartLimit = srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE + 1;\n        uint8_t *matchEndLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        uint32_t startIndex = strmCtx->currentOffset;\n        uint8_t *base = (uint8_t *)src - startIndex;\n\n        uint8_t *prefixDictStart;\n        uint32_t dictSize;\n        dictSize = strmCtx->dictSize;\n        prefixDictStart = (uint8_t *)src - dictSize;\n        strmCtx->dictSize += srcSize;\n        uint32_t prefixDictLimit = startIndex - dictSize;\n        strmCtx->currentOffset += (uint32_t)srcSize;\n\n        uint32_t hashValue = RapidlzHash4CalcValue(curSrc);\n        RapidlzHash4PutPos(startIndex, hashValue, strmCtx->hashTable);\n        curSrc++;\n        uint32_t forwardHashValue = RapidlzHash4CalcValue(curSrc);\n\n        uint8_t *match, *token;\n        int acceleration = strmCtx->acceleration;\n        while (true)\n        {\n            uint8_t *forwardPos = curSrc;\n            int step = 1;\n            int searchMatchNb = acceleration << RAPIDLZ_STEP_FORWARD_BASE;\n            do\n            {\n                hashValue = forwardHashValue;\n                uint32_t current = (forwardPos - base);\n                uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n                curSrc = forwardPos;\n                forwardPos += step;\n                step = (searchMatchNb++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (RAPIDLZ_UNLIKELY(forwardPos > matchStartLimit))\n                {\n                    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n                }\n\n                match = base + matchOffset;\n                forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n                RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n\n                if (matchOffset < prefixDictLimit)\n                {\n                    continue;\n                }\n                if ((matchOffset + RAPIDLZ_MAX_OFFSET) < current)\n                {\n                    continue;\n                }\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    break;\n                }\n            } while (1);\n\n            RAPIDLZ_EXPAND_FORWARD(prefixDictStart, match, curSrc, curSrcAnchor);\n\n            token = curDest;\n            RAPIDLZ_RETURN_IF_NOT_TRUE(RapidlzStreamEncLiterals(curSrc, curSrcAnchor, &curDest, destEnd),\n                                       RAPIDLZ_ENC_NOT_OK);\n\n        _OFFSET_AND_MATCH:\n\n            RapidlzWriteLE16(curDest, curSrc - match);\n            curDest += 2;\n\n            uint32_t matchLen;\n            uint8_t *curSrcMatchEnd;\n\n            curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, match + RAPIDLZ_MIN_MATCH,\n                                                                      curSrc + RAPIDLZ_MIN_MATCH);\n            matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n            curSrc = curSrcMatchEnd;\n#ifdef RAPIDLZ_DEBUG\n            if (RAPIDLZ_UNLIKELY(RAPIDLZ_LIT_AND_MATCH_COPY_END(curDest, matchLen) > destEnd))\n            {\n                return RAPIDLZ_ENC_NOT_OK;\n            }\n#endif\n            curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n\n            curSrcAnchor = curSrc;\n            if (curSrc >= matchStartLimit)\n            {\n                break;\n            }\n            uint32_t hv = RapidlzHash4CalcValue(curSrc - 2);\n            uint32_t index = curSrc - 2 - base;\n            RapidlzHash4PutPos(index, hv, strmCtx->hashTable);\n\n            hashValue = RapidlzHash4CalcValue(curSrc);\n            uint32_t current = (curSrc - base);\n            uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n\n            match = base + matchOffset;\n\n            RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n            if ((matchOffset >= prefixDictLimit) && ((matchOffset + RAPIDLZ_MAX_OFFSET) >= current))\n            {\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    token = curDest++;\n                    *token = 0;\n                    goto _OFFSET_AND_MATCH;\n                }\n            }\n            forwardHashValue = RapidlzHash4CalcValue(++curSrc);\n        }\n\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }",
            "rust_code": "pub fn RapidlzCompWithPrefixDict(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut destSize: i32) -> i32 {\n    let mut curSrc: Ptr<u8> = src.cast();\n    let mut curSrcAnchor: Ptr<u8> = curSrc.cast();\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize).cast();\n    let mut curDest: Ptr<u8> = dest.cast();\n    let mut destEnd: Ptr<u8> = (curDest + destSize).cast();\n    if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH!()).as_bool() {\n        return RapidlzEncLastLiterals(curSrcAnchor.cast(), srcEnd.cast(), curDest.cast(), destEnd.cast(), dest.cast());\n    }\n    let mut matchStartLimit: Ptr<u8> = (srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE!() + 1).cast();\n    let mut matchEndLimit: Ptr<u8> = (srcEnd - RAPIDLZ_LAST_LITERALS!()).cast();\n    let mut startIndex: u32 = strmCtx.currentOffset.cast();\n    let mut base: Ptr<u8> = (src.cast::<Ptr<u8>>() - startIndex).cast();\n\n    let mut prefixDictStart: Ptr<u8>;\n    let mut dictSize: u32;\n    dictSize = strmCtx.dictSize.cast();\n    prefixDictStart = (src.cast::<Ptr<u8>>() - dictSize).cast();\n    strmCtx.dictSize += srcSize.cast();\n    let mut prefixDictLimit: u32 = (startIndex - dictSize).cast();\n    strmCtx.currentOffset += srcSize.cast::<u32>();\n\n    let mut hashValue: u32 = RapidlzHash4CalcValue(curSrc.cast()).cast();\n    RapidlzHash4PutPos(startIndex.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n    curSrc += 1;\n    let mut forwardHashValue: u32 = RapidlzHash4CalcValue(curSrc.cast()).cast();\n\n    let mut match: Ptr<u8>;\n    let mut token: Ptr<u8>;\n    let mut acceleration: i32 = strmCtx.acceleration.cast();\n    loop {\n        let mut forwardPos: Ptr<u8> = curSrc.cast();\n        let mut step: i32 = 1;\n        let mut searchMatchNb: i32 = (acceleration << RAPIDLZ_STEP_FORWARD_BASE!()).cast();\n        loop {\n            hashValue = forwardHashValue.cast();\n            let mut current: u32 = (forwardPos - base).cast();\n            let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue.cast(), strmCtx.hashTable.cast()).cast();\n            curSrc = forwardPos.cast();\n            forwardPos += step;\n            step = (searchMatchNb.suffix_plus_plus() >> RAPIDLZ_STEP_FORWARD_BASE!()).cast();\n\n            if RAPIDLZ_UNLIKELY!(forwardPos > matchStartLimit).as_bool() {\n                return RapidlzEncLastLiterals(curSrcAnchor.cast(), srcEnd.cast(), curDest.cast(), destEnd.cast(), dest.cast());\n            }\n\n            match = (base + matchOffset).cast();\n            forwardHashValue = RapidlzHash4CalcValue(forwardPos.cast()).cast();\n            RapidlzHash4PutPos(current.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n\n            if (matchOffset < prefixDictLimit).as_bool() {\n                continue;\n            }\n            if ((matchOffset + RAPIDLZ_MAX_OFFSET!()) < current).as_bool() {\n                continue;\n            }\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(match)).as_bool() {\n                break;\n            }\n        }\n\n        RAPIDLZ_EXPAND_FORWARD!(prefixDictStart, match, curSrc, curSrcAnchor);\n\n        token = curDest.cast();\n        if !RapidlzStreamEncLiterals(curSrc.cast(), curSrcAnchor.cast(), c_ref!(curDest).cast(), destEnd.cast()).as_bool() {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n\n        _OFFSET_AND_MATCH:\n\n        RapidlzWriteLE16(curDest.cast(), (curSrc - match).cast());\n        curDest += 2;\n\n        let mut matchLen: u32;\n        let mut curSrcMatchEnd: Ptr<u8>;\n\n        curSrcMatchEnd = RapidlzCompressExpandBackward(matchEndLimit.cast(), (match + RAPIDLZ_MIN_MATCH!()).cast(), (curSrc + RAPIDLZ_MIN_MATCH!()).cast()).cast::<Ptr<u8>>();\n        matchLen = (curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH!()).cast();\n        curSrc = curSrcMatchEnd.cast();\n        #[cfg(RAPIDLZ_DEBUG)]\n        if RAPIDLZ_UNLIKELY!((RAPIDLZ_LIT_AND_MATCH_COPY_END!(curDest, matchLen) > destEnd).as_bool()) {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n        curDest += RapidlzStoreMatchLen(matchLen.cast(), token.cast(), curDest.cast()).cast();\n\n        curSrcAnchor = curSrc.cast();\n        if (curSrc >= matchStartLimit).as_bool() {\n            break;\n        }\n        let mut hv: u32 = RapidlzHash4CalcValue((curSrc - 2).cast()).cast();\n        let mut index: u32 = (curSrc - 2 - base).cast();\n        RapidlzHash4PutPos(index.cast(), hv.cast(), strmCtx.hashTable.cast());\n\n        hashValue = RapidlzHash4CalcValue(curSrc.cast()).cast();\n        let mut current: u32 = (curSrc - base).cast();\n        let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue.cast(), strmCtx.hashTable.cast()).cast();\n\n        match = (base + matchOffset).cast();\n\n        RapidlzHash4PutPos(current.cast(), hashValue.cast(), strmCtx.hashTable.cast());\n        if (matchOffset >= prefixDictLimit).as_bool() && ((matchOffset + RAPIDLZ_MAX_OFFSET!()) >= current).as_bool() {\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(match)).as_bool() {\n                token = curDest.suffix_plus_plus().cast();\n                *token = 0;\n                goto!(_OFFSET_AND_MATCH);\n            }\n        }\n        forwardHashValue = RapidlzHash4CalcValue(curSrc.prefix_plus_plus().cast()).cast();\n    }\n\n    return RapidlzEncLastLiterals(curSrcAnchor.cast(), srcEnd.cast(), curDest.cast(), destEnd.cast(), dest.cast());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104632446)\nerror: expected identifier, found keyword `match`\n   --> src/src/rapidlz_dictionary_c.rs:337:13\n    |\n337 |     let mut match: Ptr<u8>;\n    |             ^^^^^ expected identifier, found keyword\n    |\nhelp: escape `match` to use it as an identifier\n    |\n337 |     let mut r#match: Ptr<u8>;\n    |             ++\n\nerror: expected expression, found `=`\n   --> src/src/rapidlz_dictionary_c.rs:356:19\n    |\n356 |             match = (base + matchOffset).cast();\n    |             ----- ^ expected expression\n    |             |\n    |             while parsing this `match` expression\n\nerror: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n   --> src/src/rapidlz_dictionary_c.rs:380:33\n    |\n380 |         RapidlzWriteLE16(curDest.cast(), (curSrc - match).cast());\n    |                                 ^\n    |                                 |\n    |                                 expected one of 7 possible tokens\n    |                                 help: missing `,`\n\nerror: expected identifier, found `:`\n   --> src/src/rapidlz_dictionary_c.rs:378:26\n    |\n378 |         _OFFSET_AND_MATCH:\n    |                          ^ expected identifier\n\nerror: expected expression, found `,`\n   --> src/src/rapidlz_dictionary_c.rs:371:55\n    |\n371 |         RAPIDLZ_EXPAND_FORWARD!(prefixDictStart, match, curSrc, curSrcAnchor);\n    |                                                  -----^ expected expression\n    |                                                  |\n    |                                                  while parsing this `match` expression\n    |\n   ::: src/src/rapidlz_inner_h.rs:139:22\n    |\n139 |     ($srcBegin:expr, $matchBegin:expr, $srcCurr:expr, $srcAnchor:expr) => {\n    |                      ---------------- while parsing argument for this `expr` macro fragment\n\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline void RapidlzSafeCopyMatchFast(uint8_t *curDest, uint8_t *matchSrc, uint8_t *destEnd, uint16_t offset,\n                                                uint32_t len)\n    {\n        errno_t err;\n        uint8_t *curDestCopyEnd = curDest + len;\n        if (offset < RAPIDLZ_EIGHT_BYTE)\n        {\n            curDest[0] = matchSrc[0];\n            curDest[1] = matchSrc[1];\n            curDest[2] = matchSrc[2];\n            curDest[3] = matchSrc[3];\n            matchSrc += g_enc32table[offset];\n            err = memcpy_s(curDest + RAPIDLZ_FOUR_BYTE, RAPIDLZ_FOUR_BYTE, matchSrc, RAPIDLZ_FOUR_BYTE);\n            matchSrc -= g_dec64table[offset];\n        }\n        else\n        {\n            err = memcpy_s(curDest, RAPIDLZ_EIGHT_BYTE, matchSrc, RAPIDLZ_EIGHT_BYTE);\n            matchSrc += RAPIDLZ_EIGHT_BYTE;\n        }\n#ifdef RAPIDLZ_DEBUG\n        RAPIDLZ_RETURN_IF_NOT_EOK(err, RAPIDLZ_DEC_NOT_OK);\n#else\n    (void)err;\n#endif\n        curDest += RAPIDLZ_EIGHT_BYTE;\n        uint8_t *curDestLimit = destEnd - (RAPIDLZ_EIGHT_BYTE - 1);\n        if (curDest < curDestLimit)\n        {\n            RapidlzWildCopy8(matchSrc, curDest, curDestLimit);\n            matchSrc += (curDestLimit - curDest);\n            curDest = curDestLimit;\n        }\n        while (curDest < curDestCopyEnd)\n        {\n            *curDest++ = *matchSrc++;\n        }\n    }",
            "rust_code": "pub fn RapidlzSafeCopyMatchFast(mut curDest: Ptr<u8>, mut matchSrc: Ptr<u8>, mut destEnd: Ptr<u8>, mut offset: u16, mut len: u32) {\n    let mut err: errno_t = Default::default();\n    let mut curDestCopyEnd: Ptr<u8> = (curDest + len).cast();\n    if (offset < RAPIDLZ_EIGHT_BYTE!()).as_bool() {\n        curDest[0] = matchSrc[0].cast();\n        curDest[1] = matchSrc[1].cast();\n        curDest[2] = matchSrc[2].cast();\n        curDest[3] = matchSrc[3].cast();\n        matchSrc += (*g_enc32table.lock())[offset];\n        err = c_memcpy_s!((curDest + RAPIDLZ_FOUR_BYTE!()).cast(), RAPIDLZ_FOUR_BYTE!(), matchSrc.cast(), RAPIDLZ_FOUR_BYTE!());\n        matchSrc -= (*g_dec64table.lock())[offset];\n    } else {\n        err = c_memcpy_s!(curDest.cast(), RAPIDLZ_EIGHT_BYTE!(), matchSrc.cast(), RAPIDLZ_EIGHT_BYTE!());\n        matchSrc += RAPIDLZ_EIGHT_BYTE!();\n    }\n    #[cfg(RAPIDLZ_DEBUG)]\n    {\n        RAPIDLZ_RETURN_IF_NOT_EOK!(err, RAPIDLZ_DEC_NOT_OK!());\n    }\n    #[cfg(not(RAPIDLZ_DEBUG))]\n    {\n        err.cast::<Void>();\n    }\n    curDest += RAPIDLZ_EIGHT_BYTE!();\n    let mut curDestLimit: Ptr<u8> = (destEnd - (RAPIDLZ_EIGHT_BYTE!() - 1)).cast();\n    if (curDest < curDestLimit).as_bool() {\n        RapidlzWildCopy8(matchSrc.cast(), curDest.cast(), curDestLimit.cast());\n        matchSrc += (curDestLimit - curDest).cast::<usize>();\n        curDest = curDestLimit.cast();\n    }\n    while (curDest < curDestCopyEnd).as_bool() {\n        *curDest = *matchSrc;\n        curDest += 1;\n        matchSrc += 1;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104632810)\nerror[E0282]: type annotations needed\n   --> src/src/rapidlz_dictionary_c.rs:360:60\n    |\n360 |         err = c_memcpy_s!((curDest + RAPIDLZ_FOUR_BYTE!()).cast(), RAPIDLZ_FOUR_BYTE!(), matchSrc.cast(), RAPIDLZ_FOUR_BYTE!());\n    |                                                            ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n360 |         err = c_memcpy_s!((curDest + RAPIDLZ_FOUR_BYTE!()).cast::<T>(), RAPIDLZ_FOUR_BYTE!(), matchSrc.cast(), RAPIDLZ_FOUR_BYTE!());\n    |                                                                +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static int RapidlzDecWithPrefixDict(const char *const src, char *const dest, int srcSize, int outBufferSize,\n                                        const char *dictStart, int dictSize)\n    {\n        (void)dictStart;\n        (void)dictSize;\n#ifdef RAPIDLZ_DEBUG\n        dictSize = (dictSize > RAPIDLZ_MAX_DICT_SIZE) ? RAPIDLZ_MAX_DICT_SIZE : dictSize;\n        uint8_t *prefixDictStart = (uint8_t *)dest - dictSize;\n#endif\n        const uint8_t *curSrc = (const uint8_t *)src;\n        const uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + outBufferSize;\n\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *destEndFast = destEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n\n        uint32_t token, len;\n        uint16_t offset;\n        uint8_t *matchSrc;\n        uint32_t tmp = 0;\n        size_t leftSrcSize;\n        while (1)\n        {\n            token = *curSrc++;\n\n            len = token >> 4;\n            if (RAPIDLZ_LIKELY(len < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)))\n                {\n                    RapidlzCopy16Byte(curDest, curSrc);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, tmp);\n                if (RAPIDLZ_LIKELY((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)))\n                {\n                    RapidlzWildCopy16(curSrc, curDest, curDest + len);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n\n            offset = RapidlzReadLE16Bit(curSrc);\n            curSrc += 2;\n            matchSrc = curDest - offset;\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_UNLIKELY(matchSrc < prefixDictStart)), RAPIDLZ_DEC_NOT_OK);\n#endif\n\n            len = token & RAPIDLZ_MAX_4BIT_VALUE;\n\n            if (len < RAPIDLZ_MAX_4BIT_VALUE)\n            {\n                len += 4;\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, tmp);\n                len += 4;\n            }\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS), RAPIDLZ_DEC_NOT_OK);\n#endif\n\n            if (RAPIDLZ_LIKELY((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE + RAPIDLZ_LAST_LITERALS)))\n            {\n                RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                curDest += len;\n            }\n            else\n            {\n                if (RAPIDLZ_LIKELY(len < 1024))\n                {\n                    RAPIDLZ_FAST_SAFE_COPY_BY_BYTES(curDest, matchSrc, len);\n                }\n                else\n                {\n                    RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                    curDest += len;\n                }\n            }\n        }\n\n        return (int)((void *)curDest - (void *)(dest));\n    }",
            "rust_code": "pub fn RapidlzDecWithPrefixDict(mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut outBufferSize: i32, mut dictStart: Ptr<u8>, mut dictSize: i32) -> i32 {\n    dictStart.cast::<Void>();\n    dictSize.cast::<Void>();\n    #[cfg(RAPIDLZ_DEBUG)]\n    {\n        dictSize = if dictSize > RAPIDLZ_MAX_DICT_SIZE!() { RAPIDLZ_MAX_DICT_SIZE!() } else { dictSize };\n        let mut prefixDictStart: Ptr<u8> = (dest - dictSize).cast();\n    }\n    let mut curSrc: Ptr<u8> = src.cast();\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize).cast();\n    let mut curDest: Ptr<u8> = dest.cast();\n    let mut destEnd: Ptr<u8> = (curDest + outBufferSize).cast();\n\n    let mut srcEndFast: Ptr<u8> = (srcEnd - RAPIDLZ_COPY_PROTECT_SIZE!()).cast();\n    let mut destEndFast: Ptr<u8> = (destEnd - RAPIDLZ_COPY_PROTECT_SIZE!()).cast();\n\n    let mut token: u32;\n    let mut len: u32;\n    let mut offset: u16;\n    let mut matchSrc: Ptr<u8>;\n    let mut tmp: u32 = 0;\n    let mut leftSrcSize: usize;\n    loop {\n        token = (*curSrc).cast();\n        curSrc += 1;\n\n        len = token >> 4;\n        if RAPIDLZ_LIKELY!(len < RAPIDLZ_MAX_4BIT_VALUE!()).as_bool() {\n            if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast).as_bool() && (curDest + len <= destEndFast).as_bool() {\n                RapidlzCopy16Byte(curDest.cast(), curSrc.cast());\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc).cast();\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, tmp);\n            if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast).as_bool() && (curDest + len <= destEndFast).as_bool() {\n                RapidlzWildCopy16(curSrc.cast(), curDest.cast(), (curDest + len).cast());\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc).cast();\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        }\n\n        offset = RapidlzReadLE16Bit(curSrc.cast());\n        curSrc += 2;\n        matchSrc = (curDest - offset).cast();\n        #[cfg(RAPIDLZ_DEBUG)]\n        {\n            RAPIDLZ_RETURN_IF_NOT_TRUE!(!RAPIDLZ_UNLIKELY!(matchSrc < prefixDictStart).as_bool(), RAPIDLZ_DEC_NOT_OK!());\n        }\n\n        len = token & RAPIDLZ_MAX_4BIT_VALUE!();\n\n        if len < RAPIDLZ_MAX_4BIT_VALUE!() {\n            len += 4;\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, tmp);\n            len += 4;\n        }\n        #[cfg(RAPIDLZ_DEBUG)]\n        {\n            RAPIDLZ_RETURN_IF_NOT_TRUE!(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS!()).as_bool(), RAPIDLZ_DEC_NOT_OK!());\n        }\n\n        if RAPIDLZ_LIKELY!((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE!() + RAPIDLZ_LAST_LITERALS!()).as_bool() {\n            RapidlzCopyMatchFast(curDest.cast(), matchSrc.cast(), offset.cast(), len.cast());\n            curDest += len;\n        } else {\n            if RAPIDLZ_LIKELY!(len < 1024).as_bool() {\n                RAPIDLZ_FAST_SAFE_COPY_BY_BYTES!(curDest, matchSrc, len);\n            } else {\n                RapidlzSafeCopyMatchFast(curDest.cast(), matchSrc.cast(), destEnd.cast(), offset.cast(), len.cast());\n                curDest += len;\n            }\n        }\n    }\n\n    return (curDest.cast::<Ptr<Void>>() - dest.cast::<Ptr<Void>>()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104632991)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:384:31\n    |\n383 |         if RAPIDLZ_LIKELY!(len < RAPIDLZ_MAX_4BIT_VALUE!()).as_bool() {\n    |                                                                       - closing delimiter possibly meant for this\n384 |             if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast).as_bool() && (curDest + len <= destEndFast).as_bool() {\n    |                               ^ unclosed delimiter\n...\n391 |         } else {\n    |         ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:393:31\n    |\n391 |         } else {\n    |                - closing delimiter possibly meant for this\n392 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, tmp);\n393 |             if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast).as_bool() && (curDest + len <= destEndFast).as_bool() {\n    |                               ^ unclosed delimiter\n...\n400 |         }\n    |         ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:423:27\n    |\n378 |     loop {\n    |          - closing delimiter possibly meant for this\n...\n423 |         if RAPIDLZ_LIKELY!((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE!() + RAPIDLZ_LAST_LITERALS!()).as_bool() {\n    |                           ^ unclosed delimiter\n...\n434 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "static int RapidlzDecWithExternalDict(const char *const src, char *const dest, int srcSize, int outBufferSize,\n                                          const char *dictStart, int dictSize)\n    {\n        const uint8_t *curSrc = (const uint8_t *)src;\n        const uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + outBufferSize;\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *destEndFast = destEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *dictEnd = (uint8_t *)dictStart + dictSize;\n\n        uint32_t token, len;\n        uint16_t offset;\n        uint8_t *matchSrc;\n        uint32_t temp = 0;\n        size_t leftSrcSize;\n        while (1)\n        {\n            token = *curSrc++;\n\n            len = token >> 4;\n            if (RAPIDLZ_LIKELY(len < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY(RAPIDLZ_DICT_FAST_COPY_AVAIL(curSrc, len, srcEndFast, curDest, destEndFast)))\n                {\n                    RapidlzCopy16Byte(curDest, curSrc);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, temp);\n                if (RAPIDLZ_LIKELY(RAPIDLZ_DICT_FAST_COPY_AVAIL(curSrc, len, srcEndFast, curDest, destEndFast)))\n                {\n                    RapidlzWildCopy16(curSrc, curDest, curDest + len);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n\n            offset = RapidlzReadLE16Bit(curSrc);\n            curSrc += 2;\n            matchSrc = curDest - offset;\n\n            len = token & RAPIDLZ_MAX_4BIT_VALUE;\n\n            RAPIDLZ_GET_MATCH_LEN(len, curSrc, srcEnd, temp);\n\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS), RAPIDLZ_DEC_NOT_OK);\n#endif\n            if (matchSrc >= (uint8_t *)dest)\n            {\n                if (RAPIDLZ_LIKELY((curDest + len) <=\n                                   (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE + RAPIDLZ_LAST_LITERALS)))\n                {\n                    RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                    curDest += len;\n                }\n                else\n                {\n                    if (RAPIDLZ_LIKELY(len < 1024))\n                    {\n                        RAPIDLZ_FAST_SAFE_COPY_BY_BYTES(curDest, matchSrc, len);\n                    }\n                    else\n                    {\n                        RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                        curDest += len;\n                    }\n                }\n            }\n            else\n            {\n                errno_t err;\n                if ((int)len <= ((uint8_t *)dest - matchSrc))\n                {\n                    err = memmove_s(curDest, destEnd - curDest, dictEnd - ((uint8_t *)dest - matchSrc), len);\n                    curDest += len;\n                }\n                else\n                {\n                    size_t externCopySize = (size_t)((uint8_t *)dest - matchSrc);\n                    size_t innerCopySize = len - externCopySize;\n                    err = memcpy_s(curDest, destEnd - curDest, dictEnd - externCopySize, externCopySize);\n                    curDest += externCopySize;\n                    if (innerCopySize > (size_t)(curDest - (uint8_t *)dest))\n                    {\n                        const uint8_t *copySrc = (uint8_t *)dest;\n                        while ((innerCopySize--) != 0)\n                        {\n                            *curDest++ = *copySrc++;\n                        }\n                    }\n                    else\n                    {\n                        err = memcpy_s(curDest, destEnd - curDest, (uint8_t *)dest, innerCopySize);\n                        curDest += innerCopySize;\n                    }\n                }\n#ifdef RAPIDLZ_DEBUG\n                RAPIDLZ_RETURN_IF_NOT_EOK(err, RAPIDLZ_DEC_NOT_OK);\n#else\n            (void)err;\n#endif\n            }\n        }\n\n        return (int)((void *)curDest - (void *)(dest));\n    }",
            "rust_code": "pub fn RapidlzDecWithExternalDict(mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut outBufferSize: i32, mut dictStart: Ptr<u8>, mut dictSize: i32) -> i32 {\n    let mut curSrc: Ptr<u8> = src.cast();\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize).cast();\n    let mut curDest: Ptr<u8> = dest.cast();\n    let mut destEnd: Ptr<u8> = (curDest + outBufferSize).cast();\n    let mut srcEndFast: Ptr<u8> = (srcEnd - RAPIDLZ_COPY_PROTECT_SIZE!()).cast();\n    let mut destEndFast: Ptr<u8> = (destEnd - RAPIDLZ_COPY_PROTECT_SIZE!()).cast();\n    let mut dictEnd: Ptr<u8> = (dictStart + dictSize).cast();\n\n    let mut token: u32;\n    let mut len: u32;\n    let mut offset: u16;\n    let mut matchSrc: Ptr<u8>;\n    let mut temp: u32 = 0;\n    let mut leftSrcSize: usize;\n    loop {\n        token = (*curSrc).cast();\n        curSrc += 1;\n\n        len = token >> 4;\n        if RAPIDLZ_LIKELY!(len < RAPIDLZ_MAX_4BIT_VALUE!()).as_bool() {\n            if RAPIDLZ_LIKELY!(RAPIDLZ_DICT_FAST_COPY_AVAIL!(curSrc, len, srcEndFast, curDest, destEndFast)).as_bool() {\n                RapidlzCopy16Byte(curDest.cast(), curSrc.cast());\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc).cast();\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, temp);\n            if RAPIDLZ_LIKELY!(RAPIDLZ_DICT_FAST_COPY_AVAIL!(curSrc, len, srcEndFast, curDest, destEndFast)).as_bool() {\n                RapidlzWildCopy16(curSrc.cast(), curDest.cast(), (curDest + len).cast());\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc).cast();\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        }\n\n        offset = RapidlzReadLE16Bit(curSrc.cast());\n        curSrc += 2;\n        matchSrc = (curDest - offset).cast();\n\n        len = token & RAPIDLZ_MAX_4BIT_VALUE!();\n\n        RAPIDLZ_GET_MATCH_LEN!(len, curSrc, srcEnd, temp);\n\n        #[cfg(RAPIDLZ_DEBUG)]\n        RAPIDLZ_RETURN_IF_NOT_TRUE!(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS!()), RAPIDLZ_DEC_NOT_OK!());\n\n        if (matchSrc >= dest.cast::<Ptr<u8>>()).as_bool() {\n            if RAPIDLZ_LIKELY!((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE!() + RAPIDLZ_LAST_LITERALS!())).as_bool() {\n                RapidlzCopyMatchFast(curDest.cast(), matchSrc.cast(), offset.cast(), len.cast());\n                curDest += len;\n            } else {\n                if RAPIDLZ_LIKELY!(len < 1024).as_bool() {\n                    RAPIDLZ_FAST_SAFE_COPY_BY_BYTES!(curDest, matchSrc, len);\n                } else {\n                    RapidlzSafeCopyMatchFast(curDest.cast(), matchSrc.cast(), destEnd.cast(), offset.cast(), len.cast());\n                    curDest += len;\n                }\n            }\n        } else {\n            let mut err: errno_t;\n            if (len.cast::<i32>() <= (dest.cast::<Ptr<u8>>() - matchSrc).cast::<i32>()).as_bool() {\n                err = c_memmove_s!(curDest, (destEnd - curDest).cast(), (dictEnd - (dest.cast::<Ptr<u8>>() - matchSrc)).cast(), len);\n                curDest += len;\n            } else {\n                let mut externCopySize: usize = (dest.cast::<Ptr<u8>>() - matchSrc).cast();\n                let mut innerCopySize: usize = (len - externCopySize).cast();\n                err = c_memcpy_s!(curDest, (destEnd - curDest).cast(), (dictEnd - externCopySize).cast(), externCopySize);\n                curDest += externCopySize;\n                if (innerCopySize > (curDest - dest.cast::<Ptr<u8>>()).cast::<usize>()).as_bool() {\n                    let mut copySrc: Ptr<u8> = dest.cast();\n                    while (innerCopySize.suffix_minus_minus() != 0).as_bool() {\n                        *curDest = *copySrc;\n                        curDest += 1;\n                        copySrc += 1;\n                    }\n                } else {\n                    err = c_memcpy_s!(curDest, (destEnd - curDest).cast(), dest.cast(), innerCopySize);\n                    curDest += innerCopySize;\n                }\n            }\n            #[cfg(RAPIDLZ_DEBUG)]\n            RAPIDLZ_RETURN_IF_NOT_EOK!(err, RAPIDLZ_DEC_NOT_OK!());\n            #[cfg(not(RAPIDLZ_DEBUG))]\n            err.cast::<Void>();\n        }\n    }\n\n    return (curDest.cast::<Ptr<Void>>() - dest.cast::<Ptr<Void>>()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104633062)\nerror: no rules expected `$`\n   --> src/src/rapidlz_dictionary_c.rs:136:38\n    |\n136 |             return $curDest - c_ref!($dest).cast::<Ptr<u8>>();\n    |                                      ^^^^^ no rules expected this token in macro call\n...\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/c_alignment/operators/c_ref.rs:17:1\n    |\n17  | macro_rules! c_ref {\n    | ------------------ when calling this macro\n    |\nnote: while trying to match meta-variable `$ptr:expr`\n   --> src/translation_utils/c_alignment/operators/c_ref.rs:18:6\n    |\n18  |     ($ptr:expr) => {\n    |      ^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: no rules expected `$`\n   --> src/src/rapidlz_dictionary_c.rs:136:38\n    |\n136 |             return $curDest - c_ref!($dest).cast::<Ptr<u8>>();\n    |                                      ^^^^^ no rules expected this token in macro call\n...\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/c_alignment/operators/c_ref.rs:17:1\n    |\n17  | macro_rules! c_ref {\n    | ------------------ when calling this macro\n    |\nnote: while trying to match meta-variable `$ptr:expr`\n   --> src/translation_utils/c_alignment/operators/c_ref.rs:18:6\n    |\n18  |     ($ptr:expr) => {\n    |      ^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:396:17\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:396:17\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:387:17\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:387:17\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `EOK`\n   --> src/src/rapidlz_dictionary_c.rs:122:118\n    |\n122 |         if RAPIDLZ_UNLIKELY!($litLen > $leftSrcSize || memmove_s($curDest, $destEnd - $curDest, $curSrc, $litLen) != EOK) {\n    |                                                                                                                      ^^^ not a value\n...\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `RAPIDLZ_DST_SIZE_SMALL`\n   --> src/src/rapidlz_dictionary_c.rs:123:26\n    |\n123 |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL, cstr!(\"litLen:%u dstEnd - dst:%zu\\n\"), $litLen, $leftSrcSize);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `RAPIDLZ_ERROR_OUTPUT`\n   --> src/src/rapidlz_dictionary_c.rs:124:20\n    |\n124 |             return RAPIDLZ_ERROR_OUTPUT;\n    |                    ^^^^^^^^^^^^^^^^^^^^ not a value\n...\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `EOK`\n   --> src/src/rapidlz_dictionary_c.rs:122:118\n    |\n122 |         if RAPIDLZ_UNLIKELY!($litLen > $leftSrcSize || memmove_s($curDest, $destEnd - $curDest, $curSrc, $litLen) != EOK) {\n    |                                                                                                                      ^^^ not a value\n...\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `RAPIDLZ_DST_SIZE_SMALL`\n   --> src/src/rapidlz_dictionary_c.rs:123:26\n    |\n123 |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL, cstr!(\"litLen:%u dstEnd - dst:%zu\\n\"), $litLen, $leftSrcSize);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `RAPIDLZ_ERROR_OUTPUT`\n   --> src/src/rapidlz_dictionary_c.rs:124:20\n    |\n124 |             return RAPIDLZ_ERROR_OUTPUT;\n    |                    ^^^^^^^^^^^^^^^^^^^^ not a value\n...\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 ----------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:387:53\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                                     ^^^^^^^^^^^                    --- expected because this is `u32`\n    |                                                     |\n    |                                                     expected `u32`, found `usize`\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize.try_into().unwrap(), curDest, destEnd, len);\n    |                                                                ++++++++++++++++++++\n\nerror[E0308]: arguments to this function are incorrect\n   --> src/src/rapidlz_dictionary_c.rs:122:56\n    |\n122 |         if RAPIDLZ_UNLIKELY!($litLen > $leftSrcSize || memmove_s($curDest, $destEnd - $curDest, $curSrc, $litLen) != EOK) {\n    |                                                        ^^^^^^^^^\n...\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 -----------------------------------------------------------------------\n    |                 |                                                                  |\n    |                 |                                                                  expected `usize`, found `u32`\n    |                 in this macro invocation\n    |\nnote: expected `&mut _`, found `Ptr<u8>`\n   --> src/src/rapidlz_dictionary_c.rs:387:66\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                                                  ^^^^^^^\n    = note: expected mutable reference `&mut _`\n                          found struct `memory::ptr::Ptr<u8>`\nnote: expected `&_`, found `Ptr<u8>`\n   --> src/src/rapidlz_dictionary_c.rs:387:45\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                             ^^^^^^\n    = note: expected reference `&_`\n                  found struct `memory::ptr::Ptr<u8>`\nnote: function defined here\n   --> src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:7:8\n    |\n7   | pub fn memmove_s<T2, T1: CMemmoveS<T2>>(\n    |        ^^^^^^^^^\n8   |     dst: &mut T1,\n    |     ------------\n9   |     dst_size: usize,\n    |     ---------------\n10  |     src: &T2,\n    |     --------\n11  |     count: usize,\n    |     ------------\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider mutably borrowing here\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, &mut curDest, destEnd, len);\n    |                                                                  ++++\nhelp: consider borrowing here\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(&curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                             +\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len.try_into().unwrap());\n    |                                                                                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:387:84\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                                     -----------                    ^^^ expected `usize`, found `u32`\n    |                                                     |\n    |                                                     expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n387 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len.try_into().unwrap());\n    |                                                                                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_inner_h.rs:152:21\n    |\n152 |             $temp = *$srcCurr.plus_plus();\n    |                     ^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:374:19\n    |\n374 |     let mut temp: u32 = 0;\n    |                   --- expected due to this type\n...\n390 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, temp);\n    |             -------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_inner_h.rs:156:21\n    |\n156 |             $temp = *$srcCurr.plus_plus();\n    |                     ^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:374:19\n    |\n374 |     let mut temp: u32 = 0;\n    |                   --- expected due to this type\n...\n390 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, temp);\n    |             -------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:396:53\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                                     ^^^^^^^^^^^                    --- expected because this is `u32`\n    |                                                     |\n    |                                                     expected `u32`, found `usize`\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize.try_into().unwrap(), curDest, destEnd, len);\n    |                                                                ++++++++++++++++++++\n\nerror[E0308]: arguments to this function are incorrect\n   --> src/src/rapidlz_dictionary_c.rs:122:56\n    |\n122 |         if RAPIDLZ_UNLIKELY!($litLen > $leftSrcSize || memmove_s($curDest, $destEnd - $curDest, $curSrc, $litLen) != EOK) {\n    |                                                        ^^^^^^^^^\n...\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                 -----------------------------------------------------------------------\n    |                 |                                                                  |\n    |                 |                                                                  expected `usize`, found `u32`\n    |                 in this macro invocation\n    |\nnote: expected `&mut _`, found `Ptr<u8>`\n   --> src/src/rapidlz_dictionary_c.rs:396:66\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                                                  ^^^^^^^\n    = note: expected mutable reference `&mut _`\n                          found struct `memory::ptr::Ptr<u8>`\nnote: expected `&_`, found `Ptr<u8>`\n   --> src/src/rapidlz_dictionary_c.rs:396:45\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                             ^^^^^^\n    = note: expected reference `&_`\n                  found struct `memory::ptr::Ptr<u8>`\nnote: function defined here\n   --> src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:7:8\n    |\n7   | pub fn memmove_s<T2, T1: CMemmoveS<T2>>(\n    |        ^^^^^^^^^\n8   |     dst: &mut T1,\n    |     ------------\n9   |     dst_size: usize,\n    |     ---------------\n10  |     src: &T2,\n    |     --------\n11  |     count: usize,\n    |     ------------\n    = note: this error originates in the macro `RAPIDLZ_SAFE_LIT_COPY` which comes from the expansion of the macro `RAPIDLZ_SAFE_COPY_TILL_END` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider mutably borrowing here\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, &mut curDest, destEnd, len);\n    |                                                                  ++++\nhelp: consider borrowing here\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(&curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                             +\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len.try_into().unwrap());\n    |                                                                                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:396:84\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n    |                                                     -----------                    ^^^ expected `usize`, found `u32`\n    |                                                     |\n    |                                                     expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n396 |                 RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len.try_into().unwrap());\n    |                                                                                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_inner_h.rs:152:21\n    |\n152 |             $temp = *$srcCurr.plus_plus();\n    |                     ^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:374:19\n    |\n374 |     let mut temp: u32 = 0;\n    |                   --- expected due to this type\n...\n406 |         RAPIDLZ_GET_MATCH_LEN!(len, curSrc, srcEnd, temp);\n    |         ------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` which comes from the expansion of the macro `RAPIDLZ_GET_MATCH_LEN` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_inner_h.rs:156:21\n    |\n156 |             $temp = *$srcCurr.plus_plus();\n    |                     ^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:374:19\n    |\n374 |     let mut temp: u32 = 0;\n    |                   --- expected due to this type\n...\n406 |         RAPIDLZ_GET_MATCH_LEN!(len, curSrc, srcEnd, temp);\n    |         ------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` which comes from the expansion of the macro `RAPIDLZ_GET_MATCH_LEN` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:430:55\n    |\n430 |                 let mut innerCopySize: usize = (len - externCopySize).cast();\n    |                                                       ^^^^^^^^^^^^^^ expected `u32`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `u32`\n   --> src/src/rapidlz_dictionary_c.rs:430:53\n    |\n430 |                 let mut innerCopySize: usize = (len - externCopySize).cast();\n    |                                                     ^ no implementation for `u32 - usize`\n    |\n    = help: the trait `std::ops::Sub<usize>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&u32` implements `std::ops::Sub<u32>`\n              `&u32` implements `std::ops::Sub`\n              `u32` implements `std::ops::Sub<&u32>`\n              `u32` implements `std::ops::Sub<types::num::Num>`\n              `u32` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308, E0423.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 24 previous errors\n"
        },
        {
            "c_code": "int RapidlzCompressStream(RapidlzStreamCtx *strmCtx, const char *src, char *dst, int srcSize, int dstSize)\n    {\n        RapidlzCompressFunc rapidlzEncFunc = NULL;\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE), RAPIDLZ_ENC_NOT_OK);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!((src == NULL && srcSize != 0) || (dstSize <= 0) || (dst == NULL)),\n                                   RAPIDLZ_ENC_NOT_OK);\n        if (srcSize == 0)\n        {\n            return RapidlzZeroBytesEncode(dst, dstSize);\n        }\n        char *dictEnd = (strmCtx->dictSize != 0) ? (char *)strmCtx->dict + strmCtx->dictSize : NULL;\n        int cSize;\n        if (dictEnd == src)\n        {\n            rapidlzEncFunc = RapidlzCompWithPrefixDict;\n        }\n        else\n        {\n            if (strmCtx->strmCtxSpecific != NULL)\n            {\n                RAPIDLZ_RETURN_IF_NOT_EOK(\n                    memcpy_s(strmCtx, sizeof(RapidlzStreamCtx), strmCtx->strmCtxSpecific, sizeof(RapidlzStreamCtx)),\n                    RAPIDLZ_ENC_NOT_OK);\n            }\n            rapidlzEncFunc = RapidlzCompWithExternalDict;\n        }\n        RapidlzStrmCtxNorm(strmCtx, (char *)src, srcSize, dictEnd);\n        cSize = rapidlzEncFunc(strmCtx, src, dst, srcSize, dstSize);\n        strmCtx->dictSize = srcSize;\n        strmCtx->dict = (uint8_t *)src;\n        return cSize;\n    }",
            "rust_code": "pub fn RapidlzCompressStream(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dst: Ptr<u8>, mut srcSize: i32, mut dstSize: i32) -> i32 {\n    let mut rapidlzEncFunc: RapidlzCompressFunc = NULL!();\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!((src == NULL!()).as_bool() && (srcSize != 0).as_bool() || (dstSize <= 0).as_bool() || (dst == NULL!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    if (srcSize == 0).as_bool() {\n        return RapidlzZeroBytesEncode(dst.cast(), dstSize.cast());\n    }\n    let mut dictEnd: Ptr<u8> = if (strmCtx.dictSize != 0).as_bool() { (strmCtx.dict.cast::<Ptr<u8>>() + strmCtx.dictSize).cast() } else { NULL!() };\n    let mut cSize: i32;\n    if (dictEnd == src).as_bool() {\n        rapidlzEncFunc = RapidlzCompWithPrefixDict;\n    } else {\n        if (strmCtx.strmCtxSpecific != NULL!()).as_bool() {\n            RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), strmCtx.strmCtxSpecific, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n        }\n        rapidlzEncFunc = RapidlzCompWithExternalDict;\n    }\n    RapidlzStrmCtxNorm(strmCtx.cast(), src.cast(), srcSize.cast(), dictEnd.cast());\n    cSize = rapidlzEncFunc(strmCtx.cast(), src.cast(), dst.cast(), srcSize.cast(), dstSize.cast());\n    strmCtx.dictSize = srcSize.cast();\n    strmCtx.dict = src.cast::<Ptr<u8>>();\n    return cSize.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104633277)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:369:32\n    |\n366 | pub fn RapidlzCompressStream(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dst: Ptr<u8>, mut srcSize: i32, mut dstSize: i32) -> i32 {\n    |                                                                                                                                                 - closing delimiter possibly meant for this\n...\n369 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!((src == NULL!()).as_bool() && (srcSize != 0).as_bool() || (dstSize <= 0).as_bool() || (dst == NULL!()).as_bool(), ...\n    |                                ^ unclosed delimiter\n...\n388 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int RapidlzDecompressSafeUsingDict(const char *src, char *dst, int compressedSize, int dstSize,\n                                       const char *dictStart, int dictSize)\n    {\n        if ((src == NULL) || (compressedSize == 0) || (dst == NULL) || (dstSize < 0))\n        {\n            return RAPIDLZ_ERROR_PARAM_UNSUPPORTED;\n        }\n        if (RAPIDLZ_UNLIKELY(dstSize == 0))\n        {\n            return RapidlzZeroBytesDecode(src, compressedSize);\n        }\n        RapidlzDecompressFunc rapidlzDecFunc;\n        if ((dictSize == 0) || (dictStart + dictSize == dst))\n        {\n            rapidlzDecFunc = RapidlzDecWithPrefixDict;\n        }\n        else\n        {\n            rapidlzDecFunc = RapidlzDecWithExternalDict;\n        }\n        return rapidlzDecFunc(src, dst, compressedSize, dstSize, dictStart, dictSize);\n    }",
            "rust_code": "pub fn RapidlzDecompressSafeUsingDict(mut src: Ptr<u8>, mut dst: Ptr<u8>, mut compressedSize: i32, mut dstSize: i32, mut dictStart: Ptr<u8>, mut dictSize: i32) -> i32 {\n    if (src == NULL!()).as_bool() || (compressedSize == 0).as_bool() || (dst == NULL!()).as_bool() || (dstSize < 0).as_bool() {\n        return RAPIDLZ_ERROR_PARAM_UNSUPPORTED!();\n    }\n    if RAPIDLZ_UNLIKELY!(dstSize == 0).as_bool() {\n        return RapidlzZeroBytesDecode(src.cast(), compressedSize.cast());\n    }\n    let mut rapidlzDecFunc: RapidlzDecompressFunc;\n    if (dictSize == 0).as_bool() || (dictStart + dictSize == dst).as_bool() {\n        rapidlzDecFunc = RapidlzDecWithPrefixDict;\n    } else {\n        rapidlzDecFunc = RapidlzDecWithExternalDict;\n    }\n    return rapidlzDecFunc(src.cast(), dst.cast(), compressedSize.cast(), dstSize.cast(), dictStart.cast(), dictSize.cast());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104633345)\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:380:26\n    |\n378 |     let mut rapidlzDecFunc: RapidlzDecompressFunc;\n    |                             --------------------- expected due to this type\n379 |     if (dictSize == 0).as_bool() || (dictStart + dictSize == dst).as_bool() {\n380 |         rapidlzDecFunc = RapidlzDecWithPrefixDict;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `FuncPtr<fn(..., ..., ..., ..., ..., ...) -> ...>`, found fn item\n    |\n    = note: expected struct `func_ptr::FuncPtr<fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32>`\n              found fn item `fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32 {RapidlzDecWithPrefixDict}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n380 |         *rapidlzDecFunc = RapidlzDecWithPrefixDict;\n    |         +\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:382:26\n    |\n378 |     let mut rapidlzDecFunc: RapidlzDecompressFunc;\n    |                             --------------------- expected due to this type\n...\n382 |         rapidlzDecFunc = RapidlzDecWithExternalDict;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FuncPtr<fn(..., ..., ..., ..., ..., ...) -> ...>`, found fn item\n    |\n    = note: expected struct `func_ptr::FuncPtr<fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32>`\n              found fn item `fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32 {RapidlzDecWithExternalDict}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n382 |         *rapidlzDecFunc = RapidlzDecWithExternalDict;\n    |         +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "size_t RapidlzDecompress(const void *src, void *dst, size_t srcSize, size_t dstSize)\n    {\n        if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n            return 0;\n        }\n\n        uint8_t token, temp = 0;\n        register uint16_t offset;\n        register uint32_t litLen, matchLen;\n        uint8_t *matchSrc;\n        const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n        const uint8_t *srcCurr = (const uint8_t *)src;\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n        uint8_t *dstCurr = (uint8_t *)dst;\n        uint8_t *dstEndFast = dstEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n\n        while (srcCurr < srcEnd)\n        {\n            token = *srcCurr++;\n            litLen = (token >> 4);\n\n            if (RAPIDLZ_LIKELY(litLen < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n                {\n                    RapidlzCopy16Byte(dstCurr, srcCurr);\n                    dstCurr += litLen;\n                    srcCurr += litLen;\n                    goto READ_MATCH;\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(litLen, srcCurr, srcEnd, temp);\n                if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n                {\n                    RapidlzWildCopy16(srcCurr, dstCurr, dstCurr + litLen);\n                    dstCurr += litLen;\n                    srcCurr += litLen;\n                    goto READ_MATCH;\n                }\n            }\n\n            size_t leftSrcSize = srcEnd - srcCurr;\n            if (RAPIDLZ_UNLIKELY(litLen > leftSrcSize || memmove_s(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"litLen:%u dstEnd - dst:%zu\\n\", litLen, leftSrcSize);\n                return 0;\n            }\n\n            dstCurr += litLen;\n            srcCurr += litLen;\n\n            if (leftSrcSize == litLen)\n            {\n                return dstCurr - (uint8_t *)(dst);\n            }\n\n        READ_MATCH:\n            if (RAPIDLZ_UNLIKELY(srcCurr > srcEnd - 2))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n                return 0;\n            }\n            offset = RapidlzReadLE16Bit(srcCurr);\n            srcCurr += 2;\n            matchSrc = dstCurr - offset;\n            if (RAPIDLZ_UNLIKELY((void *)matchSrc < dst))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n                return 0;\n            }\n\n            matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE) + RAPIDLZ_MIN_MATCH;\n            if (matchLen == RAPIDLZ_MAX_4BIT_MATCH)\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(matchLen, srcCurr, srcEnd, temp);\n            }\n\n            if (RAPIDLZ_LIKELY(dstCurr + matchLen <= dstEndFast))\n            {\n                RapidlzCopyMatchFast(dstCurr, matchSrc, offset, matchLen);\n                dstCurr += matchLen;\n            }\n            else\n            {\n                if (dstCurr + matchLen > dstEnd)\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCurr:%zu matchLen:%u\\n\", dstEnd - dstCurr,\n                                matchLen);\n                    return 0;\n                }\n\n                SAFE_COPY_MATCH(dstCurr, matchSrc, matchLen);\n            }\n        }\n\n        return dstCurr - (uint8_t *)dst;\n    }",
            "rust_code": "pub fn RapidlzDecompress(mut src: Ptr<Void>, mut dst: Ptr<Void>, mut srcSize: usize, mut dstSize: usize) -> usize {\n    if (src == NULL!()).as_bool() || (dst == NULL!()).as_bool() || (srcSize == 0).as_bool() || (dstSize == 0).as_bool() {\n        RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n        return 0;\n    }\n\n    let mut token: u8 = Default::default();\n    let mut temp: u8 = 0;\n    let mut offset: u16 = Default::default();\n    let mut litLen: u32 = Default::default();\n    let mut matchLen: u32 = Default::default();\n    let mut matchSrc: Ptr<u8> = Default::default();\n    let mut srcEnd: Ptr<u8> = (src.cast::<Ptr<u8>>() + srcSize).cast();\n    let mut srcCurr: Ptr<u8> = src.cast::<Ptr<u8>>();\n    let mut srcEndFast: Ptr<u8> = (srcEnd - RAPIDLZ_COPY_PROTECT_SIZE!()).cast();\n    let mut dstEnd: Ptr<u8> = (dst.cast::<Ptr<u8>>() + dstSize).cast();\n    let mut dstCurr: Ptr<u8> = dst.cast::<Ptr<u8>>();\n    let mut dstEndFast: Ptr<u8> = (dstEnd - RAPIDLZ_COPY_PROTECT_SIZE!()).cast();\n\n    while (srcCurr < srcEnd).as_bool() {\n        token = *srcCurr;\n        srcCurr += 1;\n        litLen = (token >> 4).cast();\n\n        if RAPIDLZ_LIKELY!(litLen < RAPIDLZ_MAX_4BIT_VALUE!()).as_bool() {\n            if RAPIDLZ_LIKELY!((srcCurr + litLen) <= srcEndFast && (dstCurr + litLen) <= dstEndFast).as_bool() {\n                RapidlzCopy16Byte(dstCurr.cast(), srcCurr.cast());\n                dstCurr += litLen;\n                srcCurr += litLen;\n                goto!(READ_MATCH);\n            }\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n            if RAPIDLZ_LIKELY!((srcCurr + litLen) <= srcEndFast && (dstCurr + litLen) <= dstEndFast).as_bool() {\n                RapidlzWildCopy16(srcCurr.cast(), dstCurr.cast(), (dstCurr + litLen).cast());\n                dstCurr += litLen;\n                srcCurr += litLen;\n                goto!(READ_MATCH);\n            }\n        }\n\n        let mut leftSrcSize: usize = (srcEnd - srcCurr).cast();\n        if RAPIDLZ_UNLIKELY!(litLen > leftSrcSize || c_memmove_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK!()).as_bool() {\n            RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"litLen:{} dstEnd - dst:{}\\n\"), litLen, leftSrcSize);\n            return 0;\n        }\n\n        dstCurr += litLen;\n        srcCurr += litLen;\n\n        if (leftSrcSize == litLen).as_bool() {\n            return (dstCurr - dst.cast::<Ptr<u8>>()).cast();\n        }\n\n        label!(READ_MATCH);\n        if RAPIDLZ_UNLIKELY!(srcCurr > (srcEnd - 2)).as_bool() {\n            RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n            return 0;\n        }\n        offset = RapidlzReadLE16Bit(srcCurr.cast());\n        srcCurr += 2;\n        matchSrc = (dstCurr - offset).cast();\n        if RAPIDLZ_UNLIKELY!(matchSrc.cast::<Ptr<Void>>() < dst).as_bool() {\n            RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n            return 0;\n        }\n\n        matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE!()).cast::<u32>() + RAPIDLZ_MIN_MATCH!();\n        if (matchLen == RAPIDLZ_MAX_4BIT_MATCH!()).as_bool() {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n        }\n\n        if RAPIDLZ_LIKELY!((dstCurr + matchLen) <= dstEndFast).as_bool() {\n            RapidlzCopyMatchFast(dstCurr.cast(), matchSrc.cast(), offset.cast(), matchLen.cast());\n            dstCurr += matchLen;\n        } else {\n            if (dstCurr + matchLen > dstEnd).as_bool() {\n                RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCurr:{} matchLen:{}\\n\"), (dstEnd - dstCurr).cast(), matchLen);\n                return 0;\n            }\n\n            SAFE_COPY_MATCH!(dstCurr, matchSrc, matchLen);\n        }\n    }\n\n    return (dstCurr - dst.cast::<Ptr<u8>>()).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104633919)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:11:9\n    |\n11  |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:11:9\n    |\n11  |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `goto` in this scope\n  --> src/src/rapidlz_decompress_c.rs:38:17\n   |\n38 |                 goto!(READ_MATCH);\n   |                 ^^^^\n\nerror: cannot find macro `goto` in this scope\n  --> src/src/rapidlz_decompress_c.rs:46:17\n   |\n46 |                 goto!(READ_MATCH);\n   |                 ^^^^\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:52:13\n    |\n52  |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"litLen:{} dstEnd - dst:{}\\n\"), litLen, leftSrcSize);\n    |             -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:52:13\n    |\n52  |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"litLen:{} dstEnd - dst:{}\\n\"), litLen, leftSrcSize);\n    |             -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `label` in this scope\n  --> src/src/rapidlz_decompress_c.rs:63:9\n   |\n63 |         label!(READ_MATCH);\n   |         ^^^^^\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:65:13\n    |\n65  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:65:13\n    |\n65  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:72:13\n    |\n72  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:72:13\n    |\n72  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:86:17\n    |\n86  |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCurr:{} matchLen:{}\\n\"), (dstEnd - dstCurr).cast(), matchLen);\n    |                 ------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:86:17\n    |\n86  |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCurr:{} matchLen:{}\\n\"), (dstEnd - dstCurr).cast(), matchLen);\n    |                 ------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:41:68\n   |\n41 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n   |                                                                    ^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:153:18\n    |\n153 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:41:13\n    |\n41  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n    |             ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:157:18\n    |\n157 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:41:13\n    |\n41  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n    |             ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:51:39\n   |\n51 |         if RAPIDLZ_UNLIKELY!(litLen > leftSrcSize || c_memmove_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK!()).as_bool() {\n   |                              ------   ^^^^^^^^^^^ expected `u32`, found `usize`\n   |                              |\n   |                              expected because this is `u32`\n   |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n   |\n51 |         if RAPIDLZ_UNLIKELY!(litLen > leftSrcSize.try_into().unwrap() || c_memmove_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK!()).as_bool() {\n   |                                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:59:28\n   |\n59 |         if (leftSrcSize == litLen).as_bool() {\n   |             -----------    ^^^^^^ expected `usize`, found `u32`\n   |             |\n   |             expected because this is `usize`\n   |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n59 |         if (leftSrcSize == litLen.try_into().unwrap()).as_bool() {\n   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:78:70\n   |\n78 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n   |                                                                      ^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:153:18\n    |\n153 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:78:13\n    |\n78  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n    |             -------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:157:18\n    |\n157 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:78:13\n    |\n78  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n    |             -------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 21 previous errors\n"
        },
        {
            "c_code": "size_t RapidlzCompressBound(size_t srcSize)\n    {\n\n        return RAPIDLZ_COMPRESSBOUND(srcSize);\n    }",
            "rust_code": "pub fn RapidlzCompressBound(mut srcSize: usize) -> usize {\n    return RAPIDLZ_COMPRESSBOUND!(srcSize);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104634328)\nerror[E0423]: expected value, found macro `RAPIDLZ_MAX_INPUT_SIZE`\n  --> src/src/rapidlz_compress_c.rs:49:29\n   |\n49 |         if ($size as u32) > RAPIDLZ_MAX_INPUT_SIZE { 0 } else { $size + ($size / 255) + 16 } \n   |                             ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n61 |     return RAPIDLZ_COMPRESSBOUND!(srcSize);\n   |            ------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `RAPIDLZ_COMPRESSBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint8_t *RapidlzStoreLastLiterals(uint8_t *dst, uint8_t *dstEnd, const uint8_t *srcCurr,\n                                                    uint32_t litLength, uint8_t bufferLimit)\n    {\n        uint8_t *dstCurr = dst;\n\n        if (bufferLimit != 0)\n        {\n            const uint32_t litTokSize = 1 + litLength + (litLength / RAPIDLZ_MAX_BYTE_VALUE);\n            if (dstCurr + litTokSize > dstEnd)\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu litTokSize:%u\\n\", dstEnd - dstCurr,\n                            litTokSize);\n                return NULL;\n            }\n        }\n\n        uint8_t token = (uint8_t)(((litLength < RAPIDLZ_MAX_4BIT_VALUE) ? (litLength) : (RAPIDLZ_MAX_4BIT_VALUE)) << 4);\n        *dstCurr = token;\n        dstCurr++;\n\n        if (litLength >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            dstCurr = RapidlzCompressStoreOptionalLength(dstCurr, litLength - RAPIDLZ_MAX_4BIT_VALUE);\n        }\n\n        if (memcpy_s(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_SECUREC_ERROR, \"dstEnd - dstCurr:%zu litLength%u\\n\", dstEnd - dstCurr, litLength);\n            return NULL;\n        }\n\n        return dstCurr + litLength;\n    }",
            "rust_code": "pub fn RapidlzStoreLastLiterals(mut dst: Ptr<u8>, mut dstEnd: Ptr<u8>, mut srcCurr: Ptr<u8>, mut litLength: u32, mut bufferLimit: u8) -> Ptr<u8> {\n    let mut dstCurr: Ptr<u8> = dst.cast();\n\n    if (bufferLimit != 0).as_bool() {\n        let mut litTokSize: u32 = 1 + litLength + (litLength / RAPIDLZ_MAX_BYTE_VALUE!());\n        if (dstCurr + litTokSize > dstEnd).as_bool() {\n            RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu litTokSize:%u\\n\"), dstEnd - dstCurr, litTokSize);\n            return NULL!();\n        }\n    }\n\n    let mut token: u8 = if litLength < RAPIDLZ_MAX_4BIT_VALUE!() { litLength } else { RAPIDLZ_MAX_4BIT_VALUE!() }.cast::<u8>() << 4;\n    *dstCurr = token.cast();\n    dstCurr += 1;\n\n    if (litLength >= RAPIDLZ_MAX_4BIT_VALUE!()).as_bool() {\n        dstCurr = RapidlzCompressStoreOptionalLength(dstCurr.cast(), (litLength - RAPIDLZ_MAX_4BIT_VALUE!()).cast()).cast();\n    }\n\n    if c_memcpy_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK!() {\n        RAPIDLZ_LOG!(RAPIDLZ_SECUREC_ERROR!(), cstr!(\"dstEnd - dstCurr:%zu litLength%u\\n\"), dstEnd - dstCurr, litLength);\n        return NULL!();\n    }\n\n    return (dstCurr + litLength).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104635303)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:121:13\n    |\n121 |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu litTokSize:%u\\n\"), dstEnd - dstCurr, litTokSize);\n    |             ------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:121:13\n    |\n121 |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu litTokSize:%u\\n\"), dstEnd - dstCurr, litTokSize);\n    |             ------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:135:9\n    |\n135 |         RAPIDLZ_LOG!(RAPIDLZ_SECUREC_ERROR!(), cstr!(\"dstEnd - dstCurr:%zu litLength%u\\n\"), dstEnd - dstCurr, litLength);\n    |         ---------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:135:9\n    |\n135 |         RAPIDLZ_LOG!(RAPIDLZ_SECUREC_ERROR!(), cstr!(\"dstEnd - dstCurr:%zu litLength%u\\n\"), dstEnd - dstCurr, litLength);\n    |         ---------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "static size_t RapidlzCompressProcess(void *dst, size_t dstSize, const void *src, size_t srcSize, RapidlzCCtx *cCtx)\n    {\n        uint32_t hashValue, matchLength, literalLength;\n        uint32_t step = 1;\n        uint16_t offset;\n        uint8_t *hashTable = cCtx->hashTable;\n        const uint8_t *srcBegin = (const uint8_t *)src;\n        const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n        const uint8_t *srcCurr = srcBegin + 1;\n        const uint8_t *srcCurrMatchEnd;\n        const uint8_t *srcAnchor = srcBegin;\n        const uint8_t *matchBegin;\n        const uint8_t *matchLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        const uint8_t *srcLimit = srcEnd - RAPIDLZ_MIN_COMPRESS_SIZE;\n        uint8_t *dstBegin = (uint8_t *)dst;\n        uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n        uint8_t *dstCurr = dstBegin;\n        uint8_t hashType = cCtx->hashType;\n        uint8_t hashBits = cCtx->hashBits;\n        uint32_t searchMatchNb = cCtx->step << RAPIDLZ_STEP_FORWARD_BASE;\n        uint32_t searchMatchNbTmp = searchMatchNb;\n        uint8_t bufferLimit = cCtx->bufferLimit;\n\n        while (RAPIDLZ_LIKELY(srcCurr <= srcLimit))\n        {\n            for (;;)\n            {\n                hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n                matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n                RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n                if ((RAPIDLZ_READ32BIT(srcCurr) == RAPIDLZ_READ32BIT(matchBegin)) &&\n                    RAPIDLZ_LIKELY((srcCurr - matchBegin) <= RAPIDLZ_MAX_OFFSET))\n                {\n                    break;\n                }\n\n                srcCurr += step;\n                step = (searchMatchNbTmp++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (srcCurr > srcLimit)\n                {\n                    dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n                    if (dstCurr == NULL)\n                    {\n                        return 0;\n                    }\n                    return dstCurr - dstBegin;\n                }\n            }\n            step = 1;\n            searchMatchNbTmp = searchMatchNb;\n\n            srcCurrMatchEnd =\n                RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n            RAPIDLZ_EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor);\n            matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n            offset = (uint16_t)(srcCurr - matchBegin);\n            literalLength = srcCurr - srcAnchor;\n            if (bufferLimit != 0)\n            {\n                uint32_t writeSize = literalLength + 8 + (literalLength + matchLength / RAPIDLZ_MAX_BYTE_VALUE);\n                if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                                writeSize);\n                    return 0;\n                }\n            }\n            dstCurr = RapidlzStoreSequence(dstCurr, srcAnchor, literalLength, matchLength, offset);\n            srcCurr = srcCurrMatchEnd;\n            srcAnchor = srcCurr;\n            hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n            RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n\n            if (RAPIDLZ_UNLIKELY(srcCurr > srcLimit))\n            {\n                break;\n            }\n\n            hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n            matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n            RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n            if ((RAPIDLZ_READ32BIT(srcCurr) != RAPIDLZ_READ32BIT(matchBegin)) ||\n                RAPIDLZ_UNLIKELY((srcCurr - matchBegin) > RAPIDLZ_MAX_OFFSET))\n            {\n                srcCurr++;\n                continue;\n            }\n\n            srcCurrMatchEnd =\n                RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n            matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n            offset = (uint16_t)(srcCurr - matchBegin);\n            if (bufferLimit != 0)\n            {\n                const uint32_t writeSize = 8 + matchLength / RAPIDLZ_MAX_BYTE_VALUE;\n                if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                                writeSize);\n                    return 0;\n                }\n            }\n            *dstCurr = 0;\n            dstCurr = RapidlzStoreOffMatch(dstCurr + 1, dstCurr, matchLength, offset);\n\n            srcCurr = srcCurrMatchEnd;\n            srcAnchor = srcCurr;\n\n            hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n            RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n        }\n\n        if (srcAnchor < srcEnd)\n        {\n            dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n            if (dstCurr == NULL)\n            {\n                return 0;\n            }\n        }\n\n        return dstCurr - dstBegin;\n    }",
            "rust_code": "pub fn RapidlzCompressProcess(mut dst: Ptr<Void>, mut dstSize: usize, mut src: Ptr<Void>, mut srcSize: usize, mut cCtx: Ptr<RapidlzCCtx>) -> usize {\n    let mut hashValue: u32;\n    let mut matchLength: u32;\n    let mut literalLength: u32;\n    let mut step: u32 = 1;\n    let mut offset: u16;\n    let mut hashTable: Ptr<u8> = cCtx.hashTable.cast();\n    let mut srcBegin: Ptr<u8> = src.cast::<Ptr<u8>>();\n    let mut srcEnd: Ptr<u8> = src.cast::<Ptr<u8>>() + srcSize;\n    let mut srcCurr: Ptr<u8> = srcBegin + 1;\n    let mut srcCurrMatchEnd: Ptr<u8>;\n    let mut srcAnchor: Ptr<u8> = srcBegin.cast();\n    let mut matchBegin: Ptr<u8>;\n    let mut matchLimit: Ptr<u8> = srcEnd - RAPIDLZ_LAST_LITERALS!();\n    let mut srcLimit: Ptr<u8> = srcEnd - RAPIDLZ_MIN_COMPRESS_SIZE!();\n    let mut dstBegin: Ptr<u8> = dst.cast::<Ptr<u8>>();\n    let mut dstEnd: Ptr<u8> = dst.cast::<Ptr<u8>>() + dstSize;\n    let mut dstCurr: Ptr<u8> = dstBegin.cast();\n    let mut hashType: u8 = cCtx.hashType;\n    let mut hashBits: u8 = cCtx.hashBits;\n    let mut searchMatchNb: u32 = cCtx.step << RAPIDLZ_STEP_FORWARD_BASE!();\n    let mut searchMatchNbTmp: u32 = searchMatchNb;\n    let mut bufferLimit: u8 = cCtx.bufferLimit;\n\n    while RAPIDLZ_LIKELY!(srcCurr <= srcLimit).as_bool() {\n        loop {\n            hashValue = RapidlzCalcHashValue(srcCurr.cast(), hashType.cast(), hashBits.cast()).cast();\n            matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue.cast(), hashTable.cast(), hashType.cast()).cast();\n            RapidlzPutPosOnTable((srcCurr - srcBegin).cast(), hashValue.cast(), hashTable.cast(), hashType.cast());\n\n            if (RAPIDLZ_READ32BIT!(srcCurr) == RAPIDLZ_READ32BIT!(matchBegin)).as_bool() &&\n                RAPIDLZ_LIKELY!((srcCurr - matchBegin) <= RAPIDLZ_MAX_OFFSET!()).as_bool() {\n                break;\n            }\n\n            srcCurr += step;\n            step = (searchMatchNbTmp >> RAPIDLZ_STEP_FORWARD_BASE!()).cast();\n            searchMatchNbTmp += 1;\n\n            if (srcCurr > srcLimit).as_bool() {\n                dstCurr = RapidlzStoreLastLiterals(dstCurr.cast(), dstEnd.cast(), srcAnchor.cast(), (srcEnd - srcAnchor).cast(), bufferLimit.cast()).cast();\n                if (dstCurr == NULL!()).as_bool() {\n                    return 0;\n                }\n                return (dstCurr - dstBegin).cast();\n            }\n        }\n        step = 1;\n        searchMatchNbTmp = searchMatchNb;\n\n        srcCurrMatchEnd = RapidlzCompressExpandBackward(matchLimit.cast(), (matchBegin + RAPIDLZ_MIN_MATCH!()).cast(), (srcCurr + RAPIDLZ_MIN_MATCH!()).cast()).cast();\n        RAPIDLZ_EXPAND_FORWARD!(srcBegin, matchBegin, srcCurr, srcAnchor);\n        matchLength = (srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH!()).cast();\n        offset = (srcCurr - matchBegin).cast::<u16>();\n        literalLength = (srcCurr - srcAnchor).cast();\n        if (bufferLimit != 0).as_bool() {\n            let mut writeSize: u32 = literalLength + 8 + (literalLength + matchLength / RAPIDLZ_MAX_BYTE_VALUE!());\n            if RAPIDLZ_UNLIKELY!((dstCurr + writeSize) > dstEnd).as_bool() {\n                RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu writeSize:%u\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n                return 0;\n            }\n        }\n        dstCurr = RapidlzStoreSequence(dstCurr.cast(), srcAnchor.cast(), literalLength.cast(), matchLength.cast(), offset.cast()).cast();\n        srcCurr = srcCurrMatchEnd.cast();\n        srcAnchor = srcCurr.cast();\n        hashValue = RapidlzCalcHashValue((srcCurr - 2).cast(), hashType.cast(), hashBits.cast()).cast();\n        RapidlzPutPosOnTable((srcCurr - 2 - srcBegin).cast(), hashValue.cast(), hashTable.cast(), hashType.cast());\n\n        if RAPIDLZ_UNLIKELY!(srcCurr > srcLimit).as_bool() {\n            break;\n        }\n\n        hashValue = RapidlzCalcHashValue(srcCurr.cast(), hashType.cast(), hashBits.cast()).cast();\n        matchBegin = (srcBegin + RapidlzGetPosOnTable(hashValue.cast(), hashTable.cast(), hashType.cast())).cast();\n        RapidlzPutPosOnTable((srcCurr - srcBegin).cast(), hashValue.cast(), hashTable.cast(), hashType.cast());\n\n        if (RAPIDLZ_READ32BIT!(srcCurr) != RAPIDLZ_READ32BIT!(matchBegin)).as_bool() ||\n            RAPIDLZ_UNLIKELY!((srcCurr - matchBegin) > RAPIDLZ_MAX_OFFSET!()).as_bool() {\n            srcCurr += 1;\n            continue;\n        }\n\n        srcCurrMatchEnd = RapidlzCompressExpandBackward(matchLimit.cast(), (matchBegin + RAPIDLZ_MIN_MATCH!()).cast(), (srcCurr + RAPIDLZ_MIN_MATCH!()).cast()).cast();\n        matchLength = (srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH!()).cast();\n        offset = (srcCurr - matchBegin).cast::<u16>();\n        if (bufferLimit != 0).as_bool() {\n            let mut writeSize: u32 = 8 + matchLength / RAPIDLZ_MAX_BYTE_VALUE!();\n            if RAPIDLZ_UNLIKELY!((dstCurr + writeSize) > dstEnd).as_bool() {\n                RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu writeSize:%u\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n                return 0;\n            }\n        }\n        *dstCurr = 0;\n        dstCurr = RapidlzStoreOffMatch((dstCurr + 1).cast(), dstCurr.cast(), matchLength.cast(), offset.cast()).cast();\n\n        srcCurr = srcCurrMatchEnd.cast();\n        srcAnchor = srcCurr.cast();\n\n        hashValue = RapidlzCalcHashValue((srcCurr - 2).cast(), hashType.cast(), hashBits.cast()).cast();\n        RapidlzPutPosOnTable((srcCurr - 2 - srcBegin).cast(), hashValue.cast(), hashTable.cast(), hashType.cast());\n    }\n\n    if (srcAnchor < srcEnd).as_bool() {\n        dstCurr = RapidlzStoreLastLiterals(dstCurr.cast(), dstEnd.cast(), srcAnchor.cast(), (srcEnd - srcAnchor).cast(), bufferLimit.cast()).cast();\n        if (dstCurr == NULL!()).as_bool() {\n            return 0;\n        }\n    }\n\n    return (dstCurr - dstBegin).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104635905)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:232:17\n    |\n232 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu writeSize:%u\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 -------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:232:17\n    |\n232 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu writeSize:%u\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 -------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:262:17\n    |\n262 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu writeSize:%u\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 -------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:262:17\n    |\n262 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:%zu writeSize:%u\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 -------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:194:34\n    |\n194 |     let mut searchMatchNb: u32 = cCtx.step << RAPIDLZ_STEP_FORWARD_BASE!();\n    |                            ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |                            |\n    |                            expected due to this\n    |\nhelp: you can convert a `u8` to a `u32`\n    |\n194 |     let mut searchMatchNb: u32 = (cCtx.step << RAPIDLZ_STEP_FORWARD_BASE!()).into();\n    |                                  +                                         ++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "size_t RapidlzCompress(const void *src, void *dst, size_t srcSize, size_t dstSize, int acceleration)\n    {\n        if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n            return 0;\n        }\n\n        if (acceleration < 1 || acceleration > RAPIDLZ_ACCELERATION_MAX)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"acceleration:%d\\n\", acceleration);\n            return 0;\n        }\n\n        RapidlzCCtx *cCtx = (RapidlzCCtx *)malloc(sizeof(RapidlzCCtx));\n        if (cCtx == NULL)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"cCtx malloc failed\\n\");\n            return 0;\n        }\n\n        cCtx->hashBits = RAPIDLZ_MIN_HASH_BIT;\n        size_t totalHashSize;\n        if (srcSize <= RAPIDLZ_SRC_SIZE_THRESHOLD)\n        {\n            cCtx->hashType = RAPIDLZ_HASH_TYPE_4;\n            if (srcSize >= 64)\n            {\n                cCtx->hashBits = (RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT) ? (RAPIDLZ_MAX_HASH_BIT + 1)\n                                                                                    : RapidlzHighBit64(srcSize);\n            }\n            totalHashSize = sizeof(uint16_t) * (uint32_t)(1 << cCtx->hashBits);\n        }\n        else\n        {\n            cCtx->hashType = RAPIDLZ_HASH_TYPE_5;\n            cCtx->hashBits = RAPIDLZ_MAX_HASH_BIT;\n            totalHashSize = sizeof(uint32_t) * (uint32_t)(1 << cCtx->hashBits);\n        }\n\n        uint8_t *table = (uint8_t *)malloc(totalHashSize);\n        if (table == NULL)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"hash table malloc failed\\n\");\n            free(cCtx);\n            return 0;\n        }\n        (void)memset_s(table, totalHashSize, 0, totalHashSize);\n        cCtx->hashTable = table;\n        cCtx->step = (uint8_t)acceleration;\n        cCtx->bufferLimit = dstSize < RapidlzCompressBound(srcSize);\n\n        size_t cSize = RapidlzCompressProcess(dst, dstSize, src, srcSize, cCtx);\n        RapidlzCCtxFree(cCtx);\n        return cSize;\n    }",
            "rust_code": "pub fn RapidlzCompress(mut src: Ptr<Void>, mut dst: Ptr<Void>, mut srcSize: usize, mut dstSize: usize, mut acceleration: i32) -> usize {\n    if (src == NULL!()).as_bool() || (dst == NULL!()).as_bool() || (srcSize == 0).as_bool() || (dstSize == 0).as_bool() {\n        RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n        return 0;\n    }\n\n    if (acceleration < 1).as_bool() || (acceleration > RAPIDLZ_ACCELERATION_MAX!()).as_bool() {\n        RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"acceleration:{}\\n\"), acceleration);\n        return 0;\n    }\n\n    let mut cCtx: Ptr<RapidlzCCtx> = c_malloc!(c_sizeof!(RapidlzCCtx));\n    if (cCtx == NULL!()).as_bool() {\n        RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"cCtx malloc failed\\n\"));\n        return 0;\n    }\n\n    cCtx.hashBits = RAPIDLZ_MIN_HASH_BIT!();\n    let mut totalHashSize: usize;\n    if (srcSize <= RAPIDLZ_SRC_SIZE_THRESHOLD!()).as_bool() {\n        cCtx.hashType = RAPIDLZ_HASH_TYPE_4!();\n        if (srcSize >= 64).as_bool() {\n            cCtx.hashBits = if RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize) };\n        }\n        totalHashSize = c_sizeof!(u16) * (1 << cCtx.hashBits).cast::<u32>();\n    } else {\n        cCtx.hashType = RAPIDLZ_HASH_TYPE_5!();\n        cCtx.hashBits = RAPIDLZ_MAX_HASH_BIT!();\n        totalHashSize = c_sizeof!(u32) * (1 << cCtx.hashBits).cast::<u32>();\n    }\n\n    let mut table: Ptr<u8> = c_malloc!(totalHashSize);\n    if (table == NULL!()).as_bool() {\n        RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"hash table malloc failed\\n\"));\n        c_free!(cCtx);\n        return 0;\n    }\n    c_memset_s!(table, totalHashSize, 0, totalHashSize).cast::<Void>();\n    cCtx.hashTable = table;\n    cCtx.step = acceleration.cast::<u8>();\n    cCtx.bufferLimit = (dstSize < RapidlzCompressBound(srcSize)).as_bool();\n\n    let mut cSize: usize = RapidlzCompressProcess(dst.cast(), dstSize.cast(), src.cast(), srcSize.cast(), cCtx.cast());\n    RapidlzCCtxFree(cCtx.cast());\n    return cSize.cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744104636327)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:192:9\n    |\n192 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:192:9\n    |\n192 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:197:9\n    |\n197 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"acceleration:{}\\n\"), acceleration);\n    |         -------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:197:9\n    |\n197 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"acceleration:{}\\n\"), acceleration);\n    |         -------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:203:9\n    |\n203 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"cCtx malloc failed\\n\"));\n    |         --------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:203:9\n    |\n203 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"cCtx malloc failed\\n\"));\n    |         --------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:223:9\n    |\n223 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"hash table malloc failed\\n\"));\n    |         --------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:223:9\n    |\n223 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"hash table malloc failed\\n\"));\n    |         --------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:212:49\n    |\n212 | ...   cCtx.hashBits = if RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcS...\n    |                          ---------------- ^^^^^^^ expected `u64`, found `usize`\n    |                          |\n    |                          arguments to this function are incorrect\n    |\nnote: function defined here\n   --> src/src/rapidlz_inner_h.rs:229:8\n    |\n229 | pub fn RapidlzHighBit64(mut x: u64) -> u8 {\n    |        ^^^^^^^^^^^^^^^^ ----------\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n    |\n212 |             cCtx.hashBits = if RapidlzHighBit64(srcSize.try_into().unwrap()) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize) };\n    |                                                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:212:140\n    |\n212 | ... RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize) };\n    |                                          ---------------- ^^^^^^^ expected `u64`, found `usize`\n    |                                          |\n    |                                          arguments to this function are incorrect\n    |\nnote: function defined here\n   --> src/src/rapidlz_inner_h.rs:229:8\n    |\n229 | pub fn RapidlzHighBit64(mut x: u64) -> u8 {\n    |        ^^^^^^^^^^^^^^^^ ----------\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n    |\n212 |             cCtx.hashBits = if RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize.try_into().unwrap()) };\n    |                                                                                                                                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:214:25\n    |\n208 |     let mut totalHashSize: usize;\n    |                            ----- expected due to this type\n...\n214 |         totalHashSize = c_sizeof!(u16) * (1 << cCtx.hashBits).cast::<u32>();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:218:25\n    |\n208 |     let mut totalHashSize: usize;\n    |                            ----- expected due to this type\n...\n218 |         totalHashSize = c_sizeof!(u32) * (1 << cCtx.hashBits).cast::<u32>();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:230:24\n    |\n230 |     cCtx.bufferLimit = (dstSize < RapidlzCompressBound(srcSize)).as_bool();\n    |     ----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `bool`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
        }
    ]
}