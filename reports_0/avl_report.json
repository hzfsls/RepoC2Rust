{"All": 33, "Compilation Pass": 32, "Compilation Error": 1, "Pass Rate": 0.9696969696969697, "Error Information": [{"c_code": "void *VOS_AVL_Insert_Or_Find(AVL_TREE *pstTree, AVL_NODE *pstNode)\n{\n    AVL_NODE *pstParentNode;\n    int iResult;\n\n    if ((pstTree == AVL_NULL_PTR) || (pstNode == AVL_NULL_PTR) || (VOS_AVL_IN_TREE(*pstNode)))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    pstNode->sRHeight = 0;\n    pstNode->sLHeight = 0;\n\n    if (pstTree->pstRoot == AVL_NULL_PTR)\n    {\n        pstTree->pstRoot = pstNode;\n        pstTree->pstFirst = pstNode;\n        pstTree->pstLast = pstNode;\n        return AVL_NULL_PTR;\n    }\n\n    for (pstParentNode = pstTree->pstRoot; pstParentNode != AVL_NULL_PTR;)\n    {\n\n        iResult = pstTree->pfnCompare(pstNode->pKey, pstParentNode->pKey);\n        if (iResult > 0)\n        {\n\n            if (pstParentNode->pstRight != AVL_NULL_PTR)\n            {\n\n                pstParentNode = pstParentNode->pstRight;\n                continue;\n            }\n\n            VosAvlNodeRightInsert((AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot)), (AVLBASE_NODE_S *)pstParentNode,\n                                  (AVLBASE_NODE_S *)pstNode);\n\n            break;\n        }\n        else if (iResult < 0)\n        {\n\n            if (pstParentNode->pstLeft != AVL_NULL_PTR)\n            {\n\n                pstParentNode = pstParentNode->pstLeft;\n                continue;\n            }\n\n            VosAvlNodeLeftInsert((AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot)), (AVLBASE_NODE_S *)pstParentNode,\n                                 (AVLBASE_NODE_S *)pstNode);\n\n            break;\n        }\n\n        pstNode->sRHeight = -1;\n        pstNode->sLHeight = -1;\n        return pstParentNode->pSelf;\n    }\n\n    if (pstParentNode != AVL_NULL_PTR)\n    {\n        VosAvlBalanceTree((AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot)), (AVLBASE_NODE_S *)pstParentNode);\n    }\n\n    return AVL_NULL_PTR;\n}", "rust_code": "pub fn VOS_AVL_Insert_Or_Find(mut pstTree: Ptr<AVL_TREE>, mut pstNode: Ptr<AVL_NODE>) -> Ptr<Void> {\n    let mut pstParentNode: Ptr<AVL_NODE> = Default::default();\n    let mut iResult: i32 = Default::default();\n\n    if (pstTree == AVL_NULL_PTR!()).as_bool() || (pstNode == AVL_NULL_PTR!()).as_bool() || (VOS_AVL_IN_TREE!(*pstNode)).as_bool() {\n        return AVL_NULL_PTR!();\n    }\n\n    pstNode.sRHeight = 0;\n    pstNode.sLHeight = 0;\n\n    if (pstTree.pstRoot == AVL_NULL_PTR!()).as_bool() {\n        pstTree.pstRoot = pstNode.cast();\n        pstTree.pstFirst = pstNode.cast();\n        pstTree.pstLast = pstNode.cast();\n        return AVL_NULL_PTR!();\n    }\n\n    pstParentNode = pstTree.pstRoot.cast();\n    while (pstParentNode != AVL_NULL_PTR!()).as_bool() {\n        iResult = (pstTree.pfnCompare)(pstNode.pKey.cast(), pstParentNode.pKey.cast()).cast();\n        if iResult > 0 {\n            if (pstParentNode.pstRight != AVL_NULL_PTR!()).as_bool() {\n                pstParentNode = pstParentNode.pstRight.cast();\n                continue;\n            }\n\n            VosAvlNodeRightInsert((c_ref!(pstTree.pstRoot).cast::<Ptr<AVLBASE_TREE_S>>(), pstParentNode.cast::<Ptr<AVLBASE_NODE_S>>(), pstNode.cast::<Ptr<AVLBASE_NODE_S>>());\n            break;\n        } else if iResult < 0 {\n            if (pstParentNode.pstLeft != AVL_NULL_PTR!()).as_bool() {\n                pstParentNode = pstParentNode.pstLeft.cast();\n                continue;\n            }\n\n            VosAvlNodeLeftInsert((c_ref!(pstTree.pstRoot).cast::<Ptr<AVLBASE_TREE_S>>()), pstParentNode.cast::<Ptr<AVLBASE_NODE_S>>(), pstNode.cast::<Ptr<AVLBASE_NODE_S>>());\n            break;\n        }\n\n        pstNode.sRHeight = -1;\n        pstNode.sLHeight = -1;\n        return pstParentNode.pSelf.cast();\n    }\n\n    if (pstParentNode != AVL_NULL_PTR!()).as_bool() {\n        VosAvlBalanceTree((c_ref!(pstTree.pstRoot).cast::<Ptr<AVLBASE_TREE_S>>()), pstParentNode.cast::<Ptr<AVLBASE_NODE_S>>());\n    }\n\n    return AVL_NULL_PTR!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/avl_1744103819759)\nerror: mismatched closing delimiter: `}`\n  --> src/src/v_avlpub_c.rs:32:34\n   |\n26 | ...   if iResult > 0 {\n   |                      - closing delimiter possibly meant for this\n...\n32 | ...       VosAvlNodeRightInsert((c_ref!(pstTree.pstRoot).cast::<Ptr<AVLBASE_TREE_S>>(), pstParentNode.cast::<Ptr<AVLBASE_NODE_S>>(), pstN...\n   |                                ^ unclosed delimiter\n33 | ...       break;\n34 | ...   } else if iResult < 0 {\n   |       ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}]}