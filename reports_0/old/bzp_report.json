{
    "All": 92,
    "Compilation Pass": 78,
    "Compilation Error": 14,
    "Pass Rate": 0.8478260869565217,
    "Error Information": [
        {
            "c_code": "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
            "rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman);\n    BzpHeapInit(huffman);\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1) {\n        idx1 = huffman.heap[1];\n        let tmp0 = 1;\n        huffman.heap[tmp0];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        idx2 = huffman.heap[1];\n        huffman.heap[1] = huffman.heap[huffman.nHeap];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        let tmp0 = huffman.nWeight;\n        let tmp1 = idx1;\n        huffman.weight[tmp0] = BzpHuffmanWeightAdd(huffman.weight[tmp1]);\n        huffman.parent[idx1] = huffman.nWeight;\n        huffman.parent[idx2] = huffman.nWeight;\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight;\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604669690)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:40\n   |\n81 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                           -------     -^^^^^^^-------\n   |                           |           ||\n   |                           |           |immutable borrow occurs here\n   |                           |           mutable borrow later used here\n   |                           mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:40\n   |\n81 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:39\n   |\n81 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                       ^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:40\n   |\n85 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                           -------     -^^^^^^^-------\n   |                           |           ||\n   |                           |           |immutable borrow occurs here\n   |                           |           mutable borrow later used here\n   |                           mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:40\n   |\n85 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:39\n   |\n85 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                       ^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:24\n   |\n88 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:24\n   |\n88 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:23\n   |\n88 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:24\n   |\n91 |         huffman.parent[huffman.nWeight] = -1;\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:24\n   |\n91 |         huffman.parent[huffman.nWeight] = -1;\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:23\n   |\n91 |         huffman.parent[huffman.nWeight] = -1;\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:22\n   |\n93 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |         -------     -^^^^^^^-------\n   |         |           ||\n   |         |           |immutable borrow occurs here\n   |         |           mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:22\n   |\n93 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                      ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:21\n   |\n93 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                     ^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "void BzpGenerateSelectMTF(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t list[nGroups];\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            list[i] = i;\n        }\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = 0;\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                if (huffman->select[i] == list[j])\n                {\n                    pos = j;\n                    break;\n                }\n            }\n            for (int32_t j = pos; j > 0; j--)\n            {\n                list[j] = list[j - 1];\n            }\n            list[0] = huffman->select[i];\n            huffman->selectMTF[i] = pos;\n        }\n    }",
            "rust_code": "pub fn BzpGenerateSelectMTF(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups;\n    let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        list[i] = i;\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut pos: i32 = 0;\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            if (huffman.select[i] == list[j]) {\n                pos = j;\n                break;\n            }\n        });\n        c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n            list[j] = list[j - 1];\n        });\n        let tmp0 = 0;\n        list[tmp0];\n        huffman.selectMTF[i] = pos;\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604684400)\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:227:32\n    |\n227 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n226 |     const nGroups: i32 = huffman.nGroups.cast();\n    |     ~~~~~\n\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:227:53\n    |\n227 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                                     ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n226 |     const nGroups: i32 = huffman.nGroups.cast();\n    |     ~~~~~\n\nFor more information about this error, try `rustc --explain E0435`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "void BzpInitLenArray(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t npart = nGroups;\n        int32_t AllFreqNum = huffman->nBlock;\n        int32_t st = 0, ed;\n\n        while (npart > 0)\n        {\n            int32_t NowFreqNum = 0;\n            int32_t FreqNumLimit = AllFreqNum / npart;\n\n            ed = st - 1;\n            while (ed < huffman->alphaSize - 1 && NowFreqNum < FreqNumLimit)\n            {\n                ed++;\n                NowFreqNum += huffman->mtfFreq[ed];\n            }\n\n            if (ed > st && npart != nGroups && npart != 1 && ((nGroups - npart) & 1))\n            {\n                NowFreqNum -= huffman->mtfFreq[ed];\n                ed--;\n            }\n\n            for (int32_t i = 0; i < huffman->alphaSize; i++)\n            {\n                if (i >= st && i <= ed)\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = 0;\n                }\n                else\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST;\n                }\n            }\n            npart--;\n            st = ed + 1;\n            AllFreqNum -= NowFreqNum;\n        }\n    }",
            "rust_code": "pub fn BzpInitLenArray(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups;\n    let mut npart: i32 = nGroups;\n    let mut AllFreqNum: i32 = huffman.nBlock;\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    while (npart > 0) {\n        let mut NowFreqNum: i32 = 0;\n        let mut FreqNumLimit: i32 = AllFreqNum / npart;\n\n        ed = st - 1;\n        while (ed < huffman.alphaSize - 1) && (NowFreqNum < FreqNumLimit) {\n            ed += 1;\n            NowFreqNum += huffman.mtfFreq[ed];\n        }\n\n        if (ed > st) && (npart != nGroups) && (npart != 1) && ((nGroups - npart) & 1).as_bool() {\n            NowFreqNum -= huffman.mtfFreq[ed];\n            ed -= 1;\n        }\n\n        c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n            if (i >= st) && (i <= ed) {\n                let tmp0 = npart - 1;\n                huffman.huffmanGroups[tmp0] = 0;\n            } else {\n                huffman.huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST!();\n            }\n        });\n        npart -= 1;\n        st = ed + 1;\n        AllFreqNum -= NowFreqNum;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604687276)\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:244:47\n    |\n244 |             NowFreqNum += huffman.mtfFreq[ed].cast();\n    |                        --                     ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                        |\n    |                        type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `i32: std::ops::AddAssign<_>` found in the `core` crate:\n            - impl std::ops::AddAssign for i32;\n            - impl std::ops::AddAssign<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n244 |             NowFreqNum += huffman.mtfFreq[ed].cast::<T>();\n    |                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed)\n    {\n        (void)memset_s(huffman->cost, sizeof(huffman->cost), 0, sizeof(huffman->cost));\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = st; k <= ed; k++)\n        {\n            for (int32_t t = 0; t < nGroups; t++)\n            {\n                huffman->cost[t] += huffman->huffmanGroups[t].len[huffman->block[k]];\n            }\n        }\n    }",
            "rust_code": "pub fn BzpCalculateCost(mut huffman: Ptr<BzpHuffmanGroups>, mut st: i32, mut ed: i32) {\n    c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n        c_for!(let mut t: i32 = 0; t < nGroups; t.suffix_plus_plus(); {\n            let tmp0 = t;\n            let tmp1 = huffman.block[k;\n            huffman.cost[tmp0].len[tmp1]];\n        });\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604692468)\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:240:79\n    |\n240 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n    |                             -- type must be known at this point               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\n    = note: multiple `impl`s satisfying `i32: std::ops::AddAssign<_>` found in the `core` crate:\n            - impl std::ops::AddAssign for i32;\n            - impl std::ops::AddAssign<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n240 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast::<T>();\n    |                                                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }",
            "rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        let tmp0 = k;\n        if (huffman.cost[tmp0]) {\n            id = k;\n        }\n    });\n    huffman.select[huffman.nSelect] = id;\n    huffman.nSelect += 1;\n    return id;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604694556)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_huffman_encode_c.rs:248:20\n    |\n248 |     huffman.select[huffman.nSelect] = id.cast();\n    |     -------       -^^^^^^^---------\n    |     |             ||\n    |     |             |immutable borrow occurs here\n    |     |             mutable borrow later used here\n    |     mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_huffman_encode_c.rs:248:20\n    |\n248 |     huffman.select[huffman.nSelect] = id.cast();\n    |                    ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_huffman_encode_c.rs:248:19\n    |\n248 |     huffman.select[huffman.nSelect] = id.cast();\n    |                   ^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void BzpHuffmanMain(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n        huffman->nGroups = nGroups;\n\n        BzpInitLenArray(huffman);\n        int32_t st = 0, ed;\n\n        for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++)\n        {\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                (void)memset_s(huffman->huffmanGroups[j].weight, sizeof(huffman->huffmanGroups[j].weight), 0,\n                               sizeof(huffman->huffmanGroups[j].weight));\n            }\n\n            st = 0;\n            huffman->nSelect = 0;\n            while (st < huffman->nBlock)\n            {\n                ed = BZP_MIN_FUN(huffman->nBlock, st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) - 1;\n\n                BzpCalculateCost(huffman, st, ed);\n\n                int32_t id = BzpSelectTree(huffman);\n\n                for (int32_t k = st; k <= ed; k++)\n                {\n                    huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n                }\n                st = ed + 1;\n            }\n\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n            }\n        }\n\n        BzpGenerateSelectMTF(huffman);\n\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n        }\n    }",
            "rust_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock);\n    huffman.nGroups = nGroups;\n\n    BzpInitLenArray(huffman);\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0, c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock) {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman, st, ed);\n\n            let mut id: i32 = BzpSelectTree(huffman);\n\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]));\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman);\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]));\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604697017)\nerror[E0284]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:261:82\n    |\n261 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\n    = note: cannot satisfy `<i32 as std::ops::Add<_>>::Output == i32`\nhelp: consider specifying the generic argument\n    |\n261 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:261:82\n    |\n261 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\nnote: multiple `impl`s satisfying `i32: std::ops::Add<_>` found\n   --> src/translation_utils/types/num.rs:112:1\n    |\n112 | impl Add<Num> for i32 {\n    | ^^^^^^^^^^^^^^^^^^^^^\n    = note: and more `impl`s found in the following crates: `core`:\n            - impl std::ops::Add for i32;\n            - impl std::ops::Add<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n261 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "uint32_t BzpReadBits(int32_t nBit, InDeComdata *inData)\n    {\n        uint32_t res = 0;\n\n        while (inData->nBuf < nBit)\n        {\n            if (inData->input->nBuf == inData->input->pos)\n            {\n                inData->input->nBuf =\n                    fread(inData->input->buf, sizeof(char), sizeof(inData->input->buf), inData->input->filePtr);\n                inData->input->pos = 0;\n            }\n            int32_t data = ((uint32_t)(inData->input->buf[inData->input->pos]));\n\n            inData->buf = (inData->buf << BZP_BITS8) | data;\n            inData->input->pos++;\n            inData->nBuf += BZP_BITS8;\n        }\n        res = inData->buf >> (inData->nBuf - nBit);\n        res = res & ((1 << nBit) - 1);\n        inData->nBuf -= nBit;\n        return res;\n    }",
            "rust_code": "pub fn BzpReadBits(mut nBit: i32, mut inData: Ptr<InDeComdata>) -> u32 {\n    let mut res: u32 = 0;\n\n    while (inData.nBuf < nBit) {\n        if (inData.input.nBuf == inData.input.pos) {\n            inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr);\n            inData.input.pos = 0;\n        }\n        let tmp0 = inData.input.pos;\n        let mut data: i32 = (inData.input.buf[tmp0]).cast::<u32>();\n\n        inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n        inData.input.pos.suffix_plus_plus();\n        inData.nBuf += BZP_BITS8!();\n    }\n    res = (inData.buf >> (inData.nBuf - nBit));\n    res = res & ((1 << nBit) - 1);\n    inData.nBuf -= nBit;\n    return res;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604727541)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/memory/file_ptr.rs:368:9\n    |\n368 |         fread($ptr.cast(), $size.cast(), $count.cast(), &mut $file).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:35:33\n    |\n35  |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n    |                                 ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `c_fread` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/public/bzp_decompress_stream_c.rs:38:29\n   |\n38 |         let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>();\n   |                       ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`\n   |                       |\n   |                       expected due to this\n   |\nhelp: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n   |\n38 |         let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>().try_into().unwrap();\n   |                                                                               ++++++++++++++++++++\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }",
            "rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8;\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i];\n        if (inData.num == BZP_RLC_NUM_4!()) {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData);\n            });\n            inData.lasChar = BZP_ASCII_SIZE!();\n            inData.num = 0;\n        } else if (ch == inData.lasChar) {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()) {\n            break;\n        }\n    });\n    return ret;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604751776)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:228:17\n    |\n228 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:228:17\n    |\n228 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:228:17\n    |\n228 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:228:17\n    |\n228 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:233:26\n    |\n233 |         } else if (ch == inData.lasChar).as_bool() {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n233 |         } else if (i32::from(ch) == inData.lasChar).as_bool() {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:234:13\n    |\n234 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:234:13\n    |\n234 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:234:13\n    |\n234 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:234:13\n    |\n234 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:238:13\n    |\n238 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:238:13\n    |\n238 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:238:13\n    |\n238 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:238:13\n    |\n238 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
        },
        {
            "c_code": "int32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n\n        int32_t ret = BZP_OK;\n        BzpCheckFileHead(inData);\n        uint32_t blockCRC = BzpReadUInt32(inData);\n\n        (void)BzpReadBits(BZP_BIT, inData);\n\n        int32_t oriPtr = BzpReadUInt24(inData);\n        if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        int32_t ninUse = BzpGetDictionaryList(inData);\n        huffman->alphaSize = ninUse + BZP_EXTRA_CHARS_NUM;\n        huffman->nGroups = BzpReadBits(BZP_BITS3, inData);\n        if (huffman->nGroups < BZP_NGROUPS_NUM_0 || huffman->nGroups > BZP_NGROUPS_NUM_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        huffman->nSelect = BzpReadBits(BZP_BITS15, inData);\n\n        int32_t nSelectUpperLimit = (inData->blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP + 1);\n        if (huffman->nSelect < 1 || huffman->nSelect > nSelectUpperLimit)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        ret |= BzpDeHuffmanSelect(inData, huffman);\n\n        ret |= BzpDeHuffmanLen(inData, huffman);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n\n        BzpGenerateDecodeTable(huffman);\n\n        debwt->oriPtr = oriPtr;\n        ret = BzpMTFDeCode(inData, huffman, debwt);\n        if (ret != BZP_OK || debwt->nBlock >= BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        BzpBwtDecode(debwt);\n\n        ret = BzpDeCodeToStream(inData, debwt);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        inData->blockCRC = ~(inData->blockCRC);\n\n        if (blockCRC != inData->blockCRC)\n        {\n            ret = BZP_ERROR_DATA;\n        }\n\n        return ret;\n    }",
            "rust_code": "pub fn BzpDeCompressOneBlock(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    BzpCheckFileHead(inData);\n    let mut blockCRC: u32 = BzpReadUInt32(inData);\n    BzpReadBits(BZP_BIT!(), inData).cast::<Void>();\n    let mut oriPtr: i32 = BzpReadUInt24(inData);\n    if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE!() * inData.blockSize) {\n        return BZP_ERROR_DATA!();\n    }\n    let mut ninUse: i32 = BzpGetDictionaryList(inData);\n    huffman.alphaSize = (ninUse + BZP_EXTRA_CHARS_NUM!());\n    huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData).cast();\n    if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()) {\n        return BZP_ERROR_DATA!();\n    }\n    huffman.nSelect = BzpReadBits(BZP_BITS15!(), inData).cast();\n    let mut nSelectUpperLimit: i32 = (inData.blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!() + 1);\n    if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit) {\n        return BZP_ERROR_DATA!();\n    }\n    ret |= BzpDeHuffmanSelect(inData, huffman);\n    ret |= BzpDeHuffmanLen(inData, huffman);\n    if (ret != BZP_OK!()) {\n        return ret;\n    }\n    BzpGenerateDecodeTable(huffman);\n    debwt.oriPtr = oriPtr;\n    ret = BzpMTFDeCode(inData, huffman, debwt);\n    if (ret != BZP_OK!() || debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize) {\n        return BZP_ERROR_DATA!();\n    }\n    BzpBwtDecode(debwt);\n    ret = BzpDeCodeToStream(inData, debwt);\n    if (ret != BZP_OK!()) {\n        return ret;\n    }\n    inData.blockCRC = !(inData.blockCRC);\n    if (blockCRC != inData.blockCRC) {\n        ret = BZP_ERROR_DATA!();\n    }\n    return ret;\n}",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604759443)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:254:27\n    |\n254 |     let mut oriPtr: i32 = BzpReadUInt24(inData.cast());\n    |                     ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`\n    |                     |\n    |                     expected due to this\n    |\nhelp: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n    |\n254 |     let mut oriPtr: i32 = BzpReadUInt24(inData.cast()).try_into().unwrap();\n    |                                                       ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int32_t BZPDeCompressData(InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        uint32_t caltotalCRC = 0;\n        uint8_t ch;\n        ret = BzpReadFileHead(inData);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpHuffmanDecode *huffman = BzpHuffmanDecodeInit(inData->blockSize);\n        BzpBwtDecodeInfo *debwt = BzpBwtDecodeInit(inData->blockSize);\n\n        while ((ch = BzpReadBits(BZP_BITS8, inData)) != BZP_FILE_END_0)\n        {\n            if (ch != BZP_BLOCK_HEAD_0)\n            {\n                ret = BZP_ERROR_DATA;\n                break;\n            }\n            BzpHuffmanDecodeReset(huffman);\n            inData->blockCRC = BZP_INIT_BLOCK_CRC;\n\n            ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n\n            caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n            caltotalCRC ^= inData->blockCRC;\n        }\n        if (ret == BZP_OK)\n        {\n            ret = BZPReadFileEnd(inData, caltotalCRC);\n        }\n        BzpHuffmanDecodeFinish(huffman);\n        BzpBwtDecodeFinish(debwt);\n        return ret;\n    }",
            "rust_code": "pub fn BZPDeCompressData(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut caltotalCRC: u32 = 0;\n    let mut ch: u8;\n    ret = BzpReadFileHead(inData);\n    if (ret != BZP_OK!()) {\n        return ret;\n    }\n    let mut huffman: Ptr<BzpHuffmanDecode> = BzpHuffmanDecodeInit(inData.blockSize);\n    let mut debwt: Ptr<BzpBwtDecodeInfo> = BzpBwtDecodeInit(inData.blockSize);\n\n    while {\n        ch = BzpReadBits(BZP_BITS8!(), inData);\n        ch != BZP_FILE_END_0!()\n    } {\n        if (ch != BZP_BLOCK_HEAD_0!()) {\n            ret = BZP_ERROR_DATA!();\n            break;\n        }\n        BzpHuffmanDecodeReset(huffman);\n        inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n\n        ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n        if (ret != BZP_OK!()) {\n            break;\n        }\n\n        caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n        caltotalCRC ^= inData.blockCRC;\n    }\n    if (ret == BZP_OK!()) {\n        ret = BZPReadFileEnd(inData, caltotalCRC);\n    }\n    BzpHuffmanDecodeFinish(huffman);\n    BzpBwtDecodeFinish(debwt);\n    return ret;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604775448)\nerror[E0283]: type annotations needed\n   --> src/src/public/bzp_decompress_stream_c.rs:336:40\n    |\n336 |         caltotalCRC ^= inData.blockCRC.cast();\n    |                     --                 ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                     |\n    |                     type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `u32: BitXorAssign<_>` found in the `core` crate:\n            - impl BitXorAssign for u32;\n            - impl BitXorAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n    |\n336 |         caltotalCRC ^= inData.blockCRC.cast::<T>();\n    |                                            +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }",
            "rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()) || (num > BZP_RLC_NUM_UPPER_LIMIT!()) {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!());\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            let tmp0 = bwt.nBlock.suffix_plus_plus();\n            bwt.block[tmp0] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()) {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604795637)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:334:18\n    |\n334 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "void BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata)\n    {\n\n        while (!BZP_BLOCK_FULL(bwt) && !BZP_BUFF_READ_EMPTY(bzpf))\n        {\n            int32_t pos = bzpf->input->pos;\n            uint8_t ch = (uint8_t)bzpf->input->buf[pos];\n            uint8_t lasch = (uint8_t)bzpf->lasChar;\n            if (ch != lasch || bzpf->num == BZP_RLC_NUM_UPPER_LIMIT)\n            {\n                BzpAddCharToBlock(lasch, bzpf->num, bwt);\n                bzpf->lasChar = ch;\n                bzpf->num = 1;\n            }\n            else\n            {\n                bzpf->num++;\n            }\n\n            bzpf->input->pos++;\n        }\n\n        if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n        {\n\n            BzpAddCharToBlock(bzpf->lasChar, bzpf->num, bwt);\n            bzpf->lasChar = BZP_ASCII_SIZE;\n            bzpf->num = 0;\n        }\n    }",
            "rust_code": "pub fn BzpBuffToBlockRLC(mut bzpf: Ptr<BzpFile>, mut bwt: Ptr<BzpBwtInfo>, mut IsLastdata: bool) {\n    while (!BZP_BLOCK_FULL!(bwt) && !BZP_BUFF_READ_EMPTY!(bzpf)) {\n        let mut pos: i32 = bzpf.input.pos;\n        let mut ch: u8 = bzpf.input.buf[pos].cast::<u8>();\n        let mut lasch: u8 = bzpf.lasChar.cast::<u8>();\n        if (ch != lasch) || (bzpf.num == BZP_RLC_NUM_UPPER_LIMIT!()) {\n            BzpAddCharToBlock(lasch, bzpf.num, bwt);\n            bzpf.lasChar = ch.cast();\n            bzpf.num = 1;\n        } else {\n            bzpf.num += 1;\n        }\n        bzpf.input.pos += 1;\n    }\n    if (IsLastdata && BZP_BUFF_READ_EMPTY!(bzpf)) {\n        BzpAddCharToBlock(bzpf.lasChar.cast(), bzpf.num, bwt);\n        bzpf.lasChar = BZP_ASCII_SIZE!();\n        bzpf.num = 0;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604799883)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:331:48\n    |\n331 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:331:48\n    |\n331 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:33\n    |\n344 |     if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                 -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:33\n    |\n344 |     if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                 -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "int32_t BzpProcessData(BzpAlgorithmInfo *bzpInfo, bool IsLastdata)\n    {\n        BzpFile *bzpf = bzpInfo->compressFile;\n        BzpOutComdata *outData = bzpInfo->outData;\n        BzpBwtInfo *bwt = bzpInfo->bwt;\n\n        bzpf->state = BZP_INPUT_COMPRESS;\n        int32_t ret = BZP_OK;\n        while (bzpf->state != BZP_RETUEN_COMPRESS)\n        {\n            if (bzpf->state == BZP_OUTPUT_COMPRESS)\n            {\n\n                ret = BzpBuffToStream(bzpf, outData);\n\n                BzpResetCompress(bwt, outData);\n                bzpf->state = BZP_INPUT_COMPRESS;\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (bzpf->state == BZP_INPUT_COMPRESS)\n            {\n\n                BzpBuffToBlockRLC(bzpf, bwt, IsLastdata);\n\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n\n                    BzpWriteFileEnd(outData, bwt->combinedCRC);\n                    BzpFlushbuf(outData);\n\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else if (BZP_BLOCK_FULL(bwt))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (ret != BZP_OK)\n            {\n                return ret;\n            }\n        }\n        return ret;\n    }",
            "rust_code": "pub fn BzpProcessData(mut bzpInfo: Ptr<BzpAlgorithmInfo>, mut IsLastdata: bool) -> i32 {\n    let mut bzpf: Ptr<BzpFile> = bzpInfo.compressFile;\n    let mut outData: Ptr<BzpOutComdata> = bzpInfo.outData;\n    let mut bwt: Ptr<BzpBwtInfo> = bzpInfo.bwt;\n\n    bzpf.state = BZP_INPUT_COMPRESS!();\n    let mut ret: i32 = BZP_OK!();\n    while (bzpf.state != BZP_RETUEN_COMPRESS!()) {\n        if (bzpf.state == BZP_OUTPUT_COMPRESS!()) {\n            ret = BzpBuffToStream(bzpf, outData);\n\n            BzpResetCompress(bwt, outData);\n            bzpf.state = BZP_INPUT_COMPRESS!();\n            if IsLastdata && BZP_BUFF_READ_EMPTY!(bzpf) {\n                bzpf.state = BZP_RETUEN_COMPRESS!();\n            }\n        }\n        if (bzpf.state == BZP_INPUT_COMPRESS!()) {\n            BzpBuffToBlockRLC(bzpf, bwt, IsLastdata);\n\n            if IsLastdata && BZP_BUFF_READ_EMPTY!(bzpf) {\n                ret = BzpCompressOneBlock(bzpInfo, outData);\n\n                BzpWriteFileEnd(outData, bwt.combinedCRC.cast());\n                BzpFlushbuf(outData);\n\n                bzpf.state = BZP_OUTPUT_COMPRESS!();\n            } else if BZP_BLOCK_FULL!(bwt) {\n                ret = BzpCompressOneBlock(bzpInfo, outData);\n                bzpf.state = BZP_OUTPUT_COMPRESS!();\n            } else {\n                bzpf.state = BZP_RETUEN_COMPRESS!();\n            }\n        }\n        if (ret != BZP_OK!()) {\n            return ret;\n        }\n    }\n    return ret;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604808329)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:359:40\n    |\n359 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:359:40\n    |\n359 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:366:40\n    |\n366 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:366:40\n    |\n366 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "void BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t)\n    {\n        int32_t vec = 0, cnt = 0;\n        int32_t mi = huffman->len[t][0], mx = huffman->len[t][0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[t][i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[t][i]);\n        }\n        huffman->minLens[t] = mi;\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[t][j] == i)\n                {\n                    huffman->perm[t][cnt++] = j;\n                }\n            }\n        }\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->base[t][huffman->len[t][i] + 1]++;\n        }\n\n        for (int32_t i = 1; i <= mx + 1; i++)\n        {\n            huffman->base[t][i] += huffman->base[t][i - 1];\n        }\n\n        for (int32_t i = mi; i <= mx; i++)\n        {\n\n            vec += (huffman->base[t][i + 1] - huffman->base[t][i]);\n\n            huffman->limit[t][i] = vec - 1;\n            vec <<= 1;\n        }\n        for (int32_t i = mi + 1; i <= mx; i++)\n        {\n            huffman->base[t][i] = ((huffman->limit[t][i - 1] + 1) << 1) - huffman->base[t][i];\n        }\n    }",
            "rust_code": "pub fn BzpGetOneTable(mut huffman: Ptr<BzpHuffmanDecode>, mut t: i32) {\n    let mut vec: i32 = 0;\n    let mut cnt: i32 = 0;\n    let mut mi: i32 = huffman.len[t][0];\n    let mut mx: i32 = huffman.len[t][0];\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        mi = BZP_MIN_FUN!(mi, huffman.len[t][i]);\n        mx = BZP_MAX_FUN!(mx, huffman.len[t][i]);\n    });\n    huffman.minLens[t] = mi;\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            if (huffman.len[t][j] == i) {\n                huffman.perm[t][cnt] = j;\n                cnt += 1;\n            }\n        });\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.base[t][huffman.len[t][i] + 1] += 1;\n    });\n    c_for!(let mut i: i32 = 1; i <= mx + 1; i.suffix_plus_plus(); {\n        let tmp0 = t;\n        huffman.base[tmp0][i - 1];\n    });\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        vec += (huffman.base[t][i + 1] - huffman.base[t][i]);\n        huffman.limit[t][i] = (vec - 1);\n        vec <<= 1;\n    });\n    c_for!(let mut i: i32 = mi + 1; i <= mx; i.suffix_plus_plus(); {\n        huffman.base[t][i] = (((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i]);\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744604828054)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/decompress/bzp_huffman_decode_c.rs:55:25\n   |\n55 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |         -------        -^^^^^^^---------------\n   |         |              ||\n   |         |              |immutable borrow occurs here\n   |         |              mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/decompress/bzp_huffman_decode_c.rs:55:25\n   |\n55 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                         ^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/decompress/bzp_huffman_decode_c.rs:55:24\n   |\n55 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        }
    ]
}