{"All": 9, "Compilation Pass": 6, "Compilation Error": 3, "Pass Rate": 0.6666666666666667, "Error Information": [{"c_code": "void vosSha256Begin(VOS_SHA256_CTX *pstCtx)\n    {\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n        pstCtx->h[0] = 0x6a09e667UL;\n        pstCtx->h[1] = 0xbb67ae85UL;\n        pstCtx->h[2] = 0x3c6ef372UL;\n        pstCtx->h[3] = 0xa54ff53aUL;\n        pstCtx->h[4] = 0x510e527fUL;\n        pstCtx->h[5] = 0x9b05688cUL;\n        pstCtx->h[6] = 0x1f83d9abUL;\n        pstCtx->h[7] = 0x5be0cd19UL;\n        pstCtx->outlen = SHA256_DIGEST_SIZE;\n    }", "rust_code": "pub fn vosSha256Begin(mut pstCtx: Ptr<VOS_SHA256_CTX>) {\n    if (pstCtx == NULL!()) {\n        return;\n    }\n\n    c_memset_s!(pstCtx, c_sizeof!(VOS_SHA256_CTX), 0, c_sizeof!(VOS_SHA256_CTX)).cast::<Void>();\n    pstCtx.h[0] = 0x6a09e667UL;\n    pstCtx.h[1] = 0xbb67ae85UL;\n    pstCtx.h[2] = 0x3c6ef372UL;\n    pstCtx.h[3] = 0xa54ff53aUL;\n    pstCtx.h[4] = 0x510e527fUL;\n    pstCtx.h[5] = 0x9b05688cUL;\n    pstCtx.h[6] = 0x1f83d9abUL;\n    pstCtx.h[7] = 0x5be0cd19UL;\n    pstCtx.outlen = SHA256_DIGEST_SIZE!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744605542128)\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:76:19\n   |\n76 |     pstCtx.h[0] = 0x6a09e667UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:77:19\n   |\n77 |     pstCtx.h[1] = 0xbb67ae85UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:78:19\n   |\n78 |     pstCtx.h[2] = 0x3c6ef372UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:79:19\n   |\n79 |     pstCtx.h[3] = 0xa54ff53aUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:80:19\n   |\n80 |     pstCtx.h[4] = 0x510e527fUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:81:19\n   |\n81 |     pstCtx.h[5] = 0x9b05688cUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:82:19\n   |\n82 |     pstCtx.h[6] = 0x1f83d9abUL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `UL` for number literal\n  --> src/src/sha256_c.rs:83:19\n   |\n83 |     pstCtx.h[7] = 0x5be0cd19UL;\n   |                   ^^^^^^^^^^^^ invalid suffix `UL`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"}, {"c_code": "static uint32_t vosSha256CtxPrepare(VOS_SHA256_CTX *pstCtx, uint32_t uiLen)\n    {\n        uint32_t uiCntFirst;\n        uint32_t uiCntSec;\n\n        uiCntFirst = (pstCtx->N[0] + (uiLen << SHIFTS_PER_BYTE)) & 0xffffffffUL;\n        if (uiCntFirst < pstCtx->N[0])\n        {\n            ++pstCtx->N[1];\n            if (pstCtx->N[1] == 0)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n        }\n\n        uiCntSec = pstCtx->N[1] + (uiLen >> (BITSIZE(uint32_t) - SHIFTS_PER_BYTE));\n        if (uiCntSec < pstCtx->N[1])\n        {\n            pstCtx->corrupted = 1;\n            return SHA256_ERROR;\n        }\n\n        pstCtx->N[1] = uiCntSec;\n        pstCtx->N[0] = uiCntFirst;\n        return SHA256_OK;\n    }", "rust_code": "pub fn vosSha256CtxPrepare(mut pstCtx: Ptr<VOS_SHA256_CTX>, mut uiLen: u32) -> u32 {\n    let mut uiCntFirst: u32;\n    let mut uiCntSec: u32;\n\n    uiCntFirst = (pstCtx.N[0] + (uiLen << SHIFTS_PER_BYTE!())) & 0xffffffff;\n    if (uiCntFirst < pstCtx.N[0]) {\n        pstCtx.N[1] += 1;\n        if (pstCtx.N[1] == 0) {\n            pstCtx.corrupted = 1;\n            return SHA256_ERROR!();\n        }\n    }\n\n    uiCntSec = pstCtx.N[1] + (uiLen >> (BITSIZE!(u32) - SHIFTS_PER_BYTE!()));\n    if (uiCntSec < pstCtx.N[1]) {\n        pstCtx.corrupted = 1;\n        return SHA256_ERROR!();\n    }\n\n    pstCtx.N[1] = uiCntSec;\n    pstCtx.N[0] = uiCntFirst;\n    return SHA256_OK!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744605543460)\nerror[E0423]: expected value, found macro `BITS_PRE_BYTE`\n  --> src/src/sha256_c.rs:32:53\n   |\n32 | macro_rules! BITSIZE { ($t:ty) => { c_sizeof!($t) * BITS_PRE_BYTE } }\n   |                                                     ^^^^^^^^^^^^^ not a value\n...\n88 |     uiCntSec = pstCtx.N[1] + (uiLen >> (BITSIZE!(u32) - SHIFTS_PER_BYTE!()));\n   |                                         ------------- in this macro invocation\n   |\n   = note: this error originates in the macro `BITSIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void vosSha256Hash(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiBlcLen = 0;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        if ((pucSrc == NULL) || (uiLenTmp == 0) || (pstCtx == NULL) || (pstCtx->corrupted == 1) ||\n            (pstCtx->computed == 1) || (vosSha256CtxPrepare(pstCtx, uiLenTmp) != SHA256_OK))\n        {\n            return;\n        }\n\n        if (pstCtx->blocklen != 0)\n        {\n            if (vosSha256LastPadding(pucSrc, uiLenTmp, pstCtx, &uiBlcLen) == SHA256_OK)\n            {\n                pucSrc += uiBlcLen;\n                uiLenTmp -= uiBlcLen;\n            }\n            else\n            {\n                return;\n            }\n        }\n\n        vosSha256HashByBlcMulti(pucSrc, uiLenTmp, pstCtx);\n        return;\n    }", "rust_code": "pub fn vosSha256Hash(mut pucData: Ptr<u8>, mut uiLen: u32, mut pstCtx: Ptr<VOS_SHA256_CTX>) {\n    let mut uiBlcLen: u32 = 0;\n    let mut uiLenTmp: u32 = uiLen;\n    let mut pucSrc: Ptr<u8> = pucData;\n\n    if (pucSrc == NULL!()) || (uiLenTmp == 0) || (pstCtx == NULL!()) || (pstCtx.corrupted == 1) ||\n        (pstCtx.computed == 1) || (vosSha256CtxPrepare(pstCtx, uiLenTmp) != SHA256_OK!()) {\n        return;\n    }\n\n    if (pstCtx.blocklen != 0) {\n        if (vosSha256LastPadding(pucSrc, uiLenTmp, pstCtx, c_ref!(uiBlcLen)) == SHA256_OK!() {\n            pucSrc += uiBlcLen;\n            uiLenTmp -= uiBlcLen;\n        } else {\n            return;\n        }\n    }\n\n    vosSha256HashByBlcMulti(pucSrc, uiLenTmp, pstCtx);\n    return;\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/sha256_1744605550878)\nerror: mismatched closing delimiter: `}`\n   --> src/src/sha256_c.rs:146:12\n    |\n145 |     if (pstCtx.blocklen != 0).as_bool() {\n    |                                         - closing delimiter possibly meant for this\n146 |         if (vosSha256LastPadding(pucSrc.cast(), uiLenTmp.cast(), pstCtx.cast(), c_ref!(uiBlcLen).cast()) == SHA256_OK!() {\n    |            ^ unclosed delimiter\n...\n152 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}]}