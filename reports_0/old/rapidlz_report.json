{
    "All": 50,
    "Compilation Pass": 29,
    "Compilation Error": 21,
    "Pass Rate": 0.5800000000000001,
    "Error Information": [
        {
            "c_code": "static inline uint8_t RapidlzCountTailZero64(uint64_t x)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return (uint8_t)__builtin_ctzll(x);\n#endif\n        if (x == 0)\n        {\n            return 0;\n        }\n        uint64_t val = x;\n        uint8_t num = 0;\n        while ((val & 1) == 0)\n        {\n            val >>= 1;\n            num++;\n        }\n        return num;\n    }",
            "rust_code": "pub fn RapidlzCountTailZero64(mut x: u64) -> u8 {\n    #[cfg(all(defined(__GNUC__), __GNUC__ >= 3))]\n    return __builtin_ctzll!(x).cast::<u8>();\n    if (x == 0) {\n        return 0;\n    }\n    let mut val: u64 = x;\n    let mut num: u8 = 0;\n    while ((val & 1) == 0) {\n        val >>= 1;\n        num += 1;\n    }\n    return num;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605193904)\nerror: expected unsuffixed literal, found `>=`\n   --> src/src/rapidlz_inner_h.rs:202:43\n    |\n202 |     #[cfg(all(defined(__GNUC__), __GNUC__ >= 3))]\n    |                                           ^^\n\nerror: cannot find macro `__builtin_ctzll` in this scope\n   --> src/src/rapidlz_inner_h.rs:203:12\n    |\n203 |     return __builtin_ctzll!(x).cast::<u8>();\n    |            ^^^^^^^^^^^^^^^\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint8_t RapidlzCountLeadZero64(uint64_t x)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return (uint8_t)__builtin_clzll(x);\n#endif\n        if (x == 0)\n        {\n            return 0;\n        }\n        uint8_t num = 0;\n        uint64_t val = x;\n        while ((val & 0x8000000000000000ULL) == 0)\n        {\n            val <<= 1;\n            num++;\n        }\n        return num;\n    }",
            "rust_code": "pub fn RapidlzCountLeadZero64(mut x: u64) -> u8 {\n    #[cfg(all(defined(__GNUC__), __GNUC__ >= 3))]\n    return __builtin_clzll!(x).cast::<u8>();\n    if (x == 0) {\n        return 0;\n    }\n    let mut num: u8 = 0;\n    let mut val: u64 = x;\n    while (val & 0x8000000000000000u64 == 0) {\n        val <<= 1;\n        num += 1;\n    }\n    return num;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605195809)\nerror: expected unsuffixed literal, found `>=`\n   --> src/src/rapidlz_inner_h.rs:207:43\n    |\n207 |     #[cfg(all(defined(__GNUC__), __GNUC__ >= 3))]\n    |                                           ^^\n\nerror: cannot find macro `__builtin_clzll` in this scope\n   --> src/src/rapidlz_inner_h.rs:208:12\n    |\n208 |     return __builtin_clzll!(x).cast::<u8>();\n    |            ^^^^^^^^^^^^^^^\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint8_t RapidlzHighBit64(uint64_t x)\n    {\n        RAPIDLZ_ASSERT(x != 0);\n\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return ((uint8_t)__builtin_clzll(x) ^ 63);\n#endif\n        uint8_t pos = 64;\n        uint64_t value = x;\n\n        if (value == 0)\n        {\n            return 0;\n        }\n        if ((value & 0xFFFFFFFF00000000) == 0)\n        {\n            value <<= 32;\n            pos -= 32;\n        }\n        if ((value & 0xFFFF000000000000) == 0)\n        {\n            value <<= 16;\n            pos -= 16;\n        }\n        if ((value & 0xFF00000000000000) == 0)\n        {\n            value <<= 8;\n            pos -= 8;\n        }\n        if ((value & 0xF000000000000000) == 0)\n        {\n            value <<= 4;\n            pos -= 4;\n        }\n        if ((value & 0xC000000000000000) == 0)\n        {\n            value <<= 2;\n            pos -= 2;\n        }\n        if ((value & 0x8000000000000000) == 0)\n        {\n            value <<= 1;\n            pos -= 1;\n        }\n\n        return pos - 1;\n    }",
            "rust_code": "pub fn RapidlzHighBit64(mut x: u64) -> u8 {\n    RAPIDLZ_ASSERT!(x != 0);\n\n    #[cfg(all(defined(__GNUC__), __GNUC__ >= 3)]\n    return (__builtin_clzll!(x) ^ 63).cast::<u8>();\n\n    let mut pos: u8 = 64;\n    let mut value: u64 = x;\n\n    if (value == 0) {\n        return 0;\n    }\n    if ((value & 0xFFFFFFFF00000000) == 0) {\n        value <<= 32;\n        pos -= 32;\n    }\n    if ((value & 0xFFFF000000000000) == 0) {\n        value <<= 16;\n        pos -= 16;\n    }\n    if ((value & 0xFF00000000000000) == 0) {\n        value <<= 8;\n        pos -= 8;\n    }\n    if ((value & 0xF000000000000000) == 0) {\n        value <<= 4;\n        pos -= 4;\n    }\n    if ((value & 0xC000000000000000) == 0) {\n        value <<= 2;\n        pos -= 2;\n    }\n    if ((value & 0x8000000000000000) == 0) {\n        value <<= 1;\n        pos -= 1;\n    }\n\n    return (pos - 1);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605197579)\nerror: mismatched closing delimiter: `]`\n   --> src/src/rapidlz_inner_h.rs:214:10\n    |\n214 |     #[cfg(all(defined(__GNUC__), __GNUC__ >= 3)]\n    |      -   ^                                     ^ mismatched closing delimiter\n    |      |   |\n    |      |   unclosed delimiter\n    |      closing delimiter possibly meant for this\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void RapidlzCopy16Byte(void *dst, const void *src)\n    {\n#if defined(ARM_NEON)\n        vst1q_u8((uint8_t *)dst, vld1q_u8((const uint8_t *)src));\n#elif defined(X86_SSE2)\n    _mm_storeu_si128((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n#else\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 8, RAPIDLZ_READ64BIT((uint8_t *)src + 8));\n#endif\n    }",
            "rust_code": "pub fn RapidlzCopy16Byte(mut dst: Ptr<Void>, mut src: Ptr<Void>) {\n    #[cfg(ARM_NEON)]\n    {\n        vst1q_u8!(dst.cast::<Ptr<u8>>(), vld1q_u8!(src.cast::<Ptr<u8>>()));\n    }\n    #[cfg(X86_SSE2)]\n    {\n        _mm_storeu_si128!(dst.cast::<Ptr<__m128i>>(), _mm_loadu_si128!(src.cast::<Ptr<__m128i>>()));\n    }\n    #[cfg(not(any(ARM_NEON, X86_SSE2))]\n    {\n        RAPIDLZ_WRITE64BIT!(dst, RAPIDLZ_READ64BIT!(src));\n        RAPIDLZ_WRITE64BIT!((dst.cast::<Ptr<u8>>() + 8), RAPIDLZ_READ64BIT!((src.cast::<Ptr<u8>>() + 8)));\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605199080)\nerror: mismatched closing delimiter: `]`\n   --> src/src/rapidlz_inner_h.rs:257:10\n    |\n257 |     #[cfg(not(any(ARM_NEON, X86_SSE2))]\n    |      -   ^                            ^ mismatched closing delimiter\n    |      |   |\n    |      |   unclosed delimiter\n    |      closing delimiter possibly meant for this\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static int RapidlzEncLastLiterals(uint8_t *curSrcAnchor, uint8_t *srcEnd, uint8_t *curDest, uint8_t *destEnd,\n                                      char *destStart)\n    {\n        size_t lastLiteralsLen = (size_t)(srcEnd - curSrcAnchor);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_LITERAL_LEN_COPY_END(curDest, lastLiteralsLen) > destEnd),\n                                   RAPIDLZ_ENC_NOT_OK);\n        curDest += RapidlzStoreLiteralLen(lastLiteralsLen, curDest);\n        RAPIDLZ_RETURN_IF_NOT_EOK(memcpy_s(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen),\n                                  RAPIDLZ_ENC_NOT_OK);\n        curDest += lastLiteralsLen;\n        return (int)((void *)curDest - (void *)destStart);\n    }",
            "rust_code": "pub fn RapidlzEncLastLiterals(mut curSrcAnchor: Ptr<u8>, mut srcEnd: Ptr<u8>, mut curDest: Ptr<u8>, mut destEnd: Ptr<u8>, mut destStart: Ptr<u8>) -> i32 {\n    let mut lastLiteralsLen: usize = (srcEnd - curSrcAnchor);\n    if (RAPIDLZ_LITERAL_LEN_COPY_END!(curDest, lastLiteralsLen) > destEnd) {\n        return RAPIDLZ_ENC_NOT_OK!();\n    }\n    curDest += RapidlzStoreLiteralLen(lastLiteralsLen, curDest);\n    if c_memcpy_s!(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen) != 0 {\n        return RAPIDLZ_ENC_NOT_OK!();\n    }\n    curDest += lastLiteralsLen;\n    return (curDest.cast::<Ptr<Void>>() - destStart.cast::<Ptr<Void>>()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605202784)\nerror[E0283]: type annotations needed\n   --> src/src/rapidlz_dictionary_c.rs:300:79\n    |\n300 |     curDest += RapidlzStoreLiteralLen(lastLiteralsLen.cast(), curDest.cast()).cast();\n    |             -- type must be known at this point                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\n    = note: cannot satisfy `_: integer::Integer`\n    = help: the following types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<u8>` to implement `std::ops::AddAssign<_>`\n   --> src/translation_utils/memory/ptr.rs:133:21\n    |\n133 | impl<T, I: Integer> AddAssign<I> for Ptr<T> {\n    |            -------  ^^^^^^^^^^^^     ^^^^^^\n    |            |\n    |            unsatisfied trait bound introduced here\nhelp: consider specifying the generic argument\n    |\n300 |     curDest += RapidlzStoreLiteralLen(lastLiteralsLen.cast(), curDest.cast()).cast::<T>();\n    |                                                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline bool RapidlzStreamEncLiterals(uint8_t *curSrc, uint8_t *curSrcAnchor, uint8_t **curDest,\n                                                uint8_t *destEnd)\n    {\n        uint32_t litLen = curSrc - curSrcAnchor;\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_UNLIKELY(RAPIDLZ_LITERAL_LEN_COPY_END(*curDest, litLen) > destEnd)),\n                                   false);\n        *curDest += RapidlzStoreLiteralLen(litLen, *curDest);\n        RapidlzWildCopy8(curSrcAnchor, *curDest, *curDest + litLen);\n        *curDest += litLen;\n        return true;\n    }",
            "rust_code": "pub fn RapidlzStreamEncLiterals(mut curSrc: Ptr<u8>, mut curSrcAnchor: Ptr<u8>, mut curDest: Ptr<Ptr<u8>>, mut destEnd: Ptr<u8>) -> bool {\n    let mut litLen: u32 = (curSrc - curSrcAnchor).cast();\n    if (RAPIDLZ_UNLIKELY!(RAPIDLZ_LITERAL_LEN_COPY_END!(*curDest, litLen) > destEnd)) {\n        return false;\n    }\n    *curDest += RapidlzStoreLiteralLen(litLen, *curDest);\n    RapidlzWildCopy8(curSrcAnchor, *curDest.cast(), (*curDest + litLen));\n    *curDest += litLen;\n    return true;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605205030)\nerror[E0282]: type annotations needed\n   --> src/src/rapidlz_dictionary_c.rs:305:64\n    |\n305 |     *curDest += RapidlzStoreLiteralLen(litLen.cast(), *curDest.cast()).cast();\n    |                                                                ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n305 |     *curDest += RapidlzStoreLiteralLen(litLen.cast(), *curDest.cast::<T>()).cast();\n    |                                                                    +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int RapidlzLoadDict(RapidlzStreamCtx *strmCtx, const char *dictionary, int dictSize)\n    {\n        const uint8_t *dictStart = (const uint8_t *)dictionary;\n        const uint8_t *dictEnd = (const uint8_t *)dictionary + dictSize;\n        RAPIDLZ_RETURN_IF_NOT_EOK(memset_s(strmCtx, sizeof(RapidlzStreamCtx), 0, sizeof(RapidlzStreamCtx)),\n                                  RAPIDLZ_ENC_NOT_OK);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES), RAPIDLZ_ENC_NOT_OK);\n\n        if (dictSize > RAPIDLZ_MAX_DICT_SIZE)\n        {\n            dictStart = dictEnd - RAPIDLZ_MAX_DICT_SIZE;\n        }\n\n        strmCtx->dict = (uint8_t *)dictStart;\n        strmCtx->dictSize = dictEnd - dictStart;\n        strmCtx->currentOffset = RAPIDLZ_MAX_DICT_SIZE;\n\n        uint32_t index32 = strmCtx->currentOffset - strmCtx->dictSize;\n\n        const uint8_t *curDict = dictStart;\n        while (curDict <= dictEnd - RAPIDLZ_STREAM_HASH_BYTES)\n        {\n            uint32_t hashValue = RapidlzHash4CalcValue(curDict);\n            RapidlzHash4PutPos(index32, hashValue, strmCtx->hashTable);\n            curDict += RAPIDLZ_DICT_HASH_MOVE_BYTES;\n            index32 += RAPIDLZ_DICT_HASH_MOVE_BYTES;\n        }\n\n        return (int)strmCtx->dictSize;\n    }",
            "rust_code": "pub fn RapidlzLoadDict(mut strmCtx: Ptr<RapidlzStreamCtx>, mut dictionary: Ptr<u8>, mut dictSize: i32) -> i32 {\n    let mut dictStart: Ptr<u8> = dictionary;\n    let mut dictEnd: Ptr<u8> = (dictionary + dictSize);\n    RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES!()), RAPIDLZ_ENC_NOT_OK!());\n\n    if (dictSize > RAPIDLZ_MAX_DICT_SIZE!()) {\n        dictStart = (dictEnd - RAPIDLZ_MAX_DICT_SIZE!());\n    }\n\n    strmCtx.dict = dictStart;\n    strmCtx.dictSize = (dictEnd - dictStart).cast();\n    strmCtx.currentOffset = RAPIDLZ_MAX_DICT_SIZE!();\n\n    let mut index32: u32 = (strmCtx.currentOffset - strmCtx.dictSize);\n\n    let mut curDict: Ptr<u8> = dictStart;\n    while (curDict <= dictEnd - RAPIDLZ_STREAM_HASH_BYTES!()) {\n        let mut hashValue: u32 = RapidlzHash4CalcValue(curDict);\n        RapidlzHash4PutPos(index32, hashValue, strmCtx.hashTable.cast());\n        curDict += RAPIDLZ_DICT_HASH_MOVE_BYTES!();\n        index32 += RAPIDLZ_DICT_HASH_MOVE_BYTES!();\n    }\n\n    return strmCtx.dictSize.cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605209009)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:309:5\n    |\n309 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     -------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:309:5\n    |\n309 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     -------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:308:5\n    |\n308 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:308:5\n    |\n308 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `EOK`\n   --> src/src/rapidlz_dictionary_c.rs:102:26\n    |\n102 |         if $condition != EOK {\n    |                          ^^^ not a value\n...\n308 |     RAPIDLZ_RETURN_IF_NOT_EOK!(c_memset_s!(strmCtx, c_sizeof!(RapidlzStreamCtx), 0, c_sizeof!(RapidlzStreamCtx)), RAPIDLZ_ENC_NOT_OK!());\n    |     ------------------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int RapidlzCompWithExternalDict(RapidlzStreamCtx *strmCtx, const char *src, char *dest, int srcSize, int destSize)\n    {\n\n        uint8_t *curSrc = (uint8_t *)src;\n        uint8_t *curSrcAnchor = (uint8_t *)curSrc;\n        uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + destSize;\n        if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH)\n        {\n            return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n        }\n\n        uint8_t *matchStartLimit = srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE + 1;\n        uint8_t *matchEndLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        uint32_t startIndex = strmCtx->currentOffset;\n        uint8_t *base = (uint8_t *)src - startIndex;\n\n        const uint8_t *dict, *dictBase, *dictEnd, *prefixDictStart;\n        uint32_t dictSize;\n        uint32_t offset = 0;\n\n        dict = strmCtx->dict;\n        dictSize = strmCtx->dictSize;\n        dictBase = dict + dictSize - strmCtx->currentOffset;\n        prefixDictStart = 0;\n        dictBase = dict + dictSize - strmCtx->currentOffset;\n        dictEnd = dict + dictSize;\n        strmCtx->dictSize += srcSize;\n\n        uint32_t prefixDictLimit = startIndex - dictSize;\n        strmCtx->currentOffset += (uint32_t)srcSize;\n\n        uint32_t hashValue = RapidlzHash4CalcValue(curSrc);\n        RapidlzHash4PutPos(startIndex, hashValue, strmCtx->hashTable);\n        curSrc++;\n        uint32_t forwardHashValue = RapidlzHash4CalcValue(curSrc);\n\n        const uint8_t *match;\n        uint8_t *token;\n        int acceleration = strmCtx->acceleration;\n        while (true)\n        {\n            uint8_t *forwardPos = curSrc;\n            int jumpStep = 1;\n            int searchMatchNb = acceleration << RAPIDLZ_STEP_FORWARD_BASE;\n            do\n            {\n                hashValue = forwardHashValue;\n                uint32_t current = (forwardPos - base);\n                uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n                curSrc = forwardPos;\n                forwardPos += jumpStep;\n                jumpStep = (searchMatchNb++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (RAPIDLZ_UNLIKELY(forwardPos > matchStartLimit))\n                {\n                    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n                }\n\n                if (matchOffset < startIndex)\n                {\n\n                    match = dictBase + matchOffset;\n                    prefixDictStart = dict;\n                }\n                else\n                {\n                    match = base + matchOffset;\n                    prefixDictStart = (uint8_t *)src;\n                }\n\n                forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n                RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n                RAPIDLZ_CONTINUE_IF_NOT_A_MATCH(matchOffset, prefixDictLimit, current);\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    offset = current - matchOffset;\n                    break;\n                }\n            } while (1);\n\n            RAPIDLZ_EXPAND_FORWARD(prefixDictStart, match, curSrc, curSrcAnchor);\n\n            token = curDest;\n            RAPIDLZ_RETURN_IF_NOT_TRUE(RapidlzStreamEncLiterals(curSrc, curSrcAnchor, &curDest, destEnd),\n                                       RAPIDLZ_ENC_NOT_OK);\n\n        _OFFSET_AND_MATCH:\n\n            RapidlzWriteLE16(curDest, offset);\n            curDest += 2;\n\n            uint32_t matchLen;\n            uint8_t *curSrcMatchEnd;\n\n            if (prefixDictStart == dict)\n            {\n                uint8_t *srcLimitOnlyWithDict = curSrc + (dictEnd - match);\n                if (srcLimitOnlyWithDict > matchEndLimit)\n                {\n                    srcLimitOnlyWithDict = matchEndLimit;\n                }\n                curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(\n                    srcLimitOnlyWithDict, match + RAPIDLZ_MIN_MATCH, curSrc + RAPIDLZ_MIN_MATCH);\n                matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n                curSrc = curSrcMatchEnd;\n\n                if (curSrc == srcLimitOnlyWithDict)\n                {\n                    curSrcMatchEnd =\n                        (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, (uint8_t *)src, srcLimitOnlyWithDict);\n                    matchLen += (curSrcMatchEnd - curSrc);\n                    curSrc = curSrcMatchEnd;\n                }\n            }\n            else\n            {\n                curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, match + RAPIDLZ_MIN_MATCH,\n                                                                          curSrc + RAPIDLZ_MIN_MATCH);\n                matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n                curSrc = curSrcMatchEnd;\n            }\n#ifdef RAPIDLZ_DEBUG\n            if (RAPIDLZ_UNLIKELY(RAPIDLZ_LIT_AND_MATCH_COPY_END(curDest, matchLen) > destEnd))\n            {\n                return RAPIDLZ_ENC_NOT_OK;\n            }\n#endif\n            curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n            curSrcAnchor = curSrc;\n            if (curSrc >= matchStartLimit)\n            {\n                break;\n            }\n            uint32_t hv2 = RapidlzHash4CalcValue(curSrc - 2);\n            uint32_t index = curSrc - 2 - base;\n            RapidlzHash4PutPos(index, hv2, strmCtx->hashTable);\n\n            hashValue = RapidlzHash4CalcValue(curSrc);\n            uint32_t current = (curSrc - base);\n            uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n            if (matchOffset < startIndex)\n            {\n\n                match = dictBase + matchOffset;\n                prefixDictStart = dict;\n            }\n            else\n            {\n                match = base + matchOffset;\n                prefixDictStart = (uint8_t *)src;\n            }\n\n            RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n\n            if ((matchOffset >= prefixDictLimit) && (matchOffset + RAPIDLZ_MAX_OFFSET >= current))\n            {\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    token = curDest++;\n                    *token = 0;\n                    offset = current - matchOffset;\n                    goto _OFFSET_AND_MATCH;\n                }\n            }\n            forwardHashValue = RapidlzHash4CalcValue(++curSrc);\n        }\n\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }",
            "rust_code": "pub fn RapidlzCompWithExternalDict(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut destSize: i32) -> i32 {\n    let mut curSrc: Ptr<u8> = src;\n    let mut curSrcAnchor: Ptr<u8> = curSrc;\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize);\n    let mut curDest: Ptr<u8> = dest;\n    let mut destEnd: Ptr<u8> = (curDest + destSize);\n    if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH!()) {\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }\n\n    let mut matchStartLimit: Ptr<u8> = (srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE!() + 1);\n    let mut matchEndLimit: Ptr<u8> = (srcEnd - RAPIDLZ_LAST_LITERALS!());\n    let mut startIndex: u32 = strmCtx.currentOffset;\n    let mut base: Ptr<u8> = (src - startIndex);\n\n    let mut dict: Ptr<u8> = Default::default();\n    let mut dictBase: Ptr<u8> = Default::default();\n    let mut dictEnd: Ptr<u8> = Default::default();\n    let mut prefixDictStart: Ptr<u8> = Default::default();\n    let mut dictSize: u32 = Default::default();\n    let mut offset: u32 = 0;\n\n    dict = strmCtx.dict;\n    dictSize = strmCtx.dictSize;\n    dictBase = (dict + dictSize - strmCtx.currentOffset);\n    prefixDictStart = 0;\n    dictBase = (dict + dictSize - strmCtx.currentOffset);\n    dictEnd = (dict + dictSize);\n    strmCtx.dictSize += srcSize;\n\n    let mut prefixDictLimit: u32 = (startIndex - dictSize);\n    strmCtx.currentOffset += srcSize.cast::<u32>();\n\n    let mut hashValue: u32 = RapidlzHash4CalcValue(curSrc);\n    RapidlzHash4PutPos(startIndex, hashValue, strmCtx.hashTable.cast());\n    curSrc += 1;\n    let mut forwardHashValue: u32 = RapidlzHash4CalcValue(curSrc);\n\n    let mut r#match: Ptr<u8> = Default::default();\n    let mut token: Ptr<u8> = Default::default();\n    let mut acceleration: i32 = strmCtx.acceleration;\n    loop {\n        let mut forwardPos: Ptr<u8> = curSrc;\n        let mut jumpStep: i32 = 1;\n        let mut searchMatchNb: i32 = (acceleration << RAPIDLZ_STEP_FORWARD_BASE!());\n        loop {\n            hashValue = forwardHashValue;\n            let mut current: u32 = (forwardPos - base).cast();\n            let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue, strmCtx.hashTable.cast());\n            curSrc = forwardPos;\n            forwardPos += jumpStep;\n            jumpStep = (searchMatchNb >> RAPIDLZ_STEP_FORWARD_BASE!());\n            searchMatchNb += 1;\n\n            if RAPIDLZ_UNLIKELY!(forwardPos > matchStartLimit) {\n                return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n            }\n\n            if (matchOffset < startIndex) {\n                r#match = (dictBase + matchOffset);\n                prefixDictStart = dict;\n            } else {\n                r#match = (base + matchOffset);\n                prefixDictStart = src;\n            }\n\n            forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n            RapidlzHash4PutPos(current, hashValue, strmCtx.hashTable.cast());\n            RAPIDLZ_CONTINUE_IF_NOT_A_MATCH!(matchOffset, prefixDictLimit, current);\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(r#match)) {\n                offset = (current - matchOffset);\n                break;\n            }\n        }\n\n        RAPIDLZ_EXPAND_FORWARD!(prefixDictStart, r#match, curSrc, curSrcAnchor);\n\n        token = curDest;\n        if !RapidlzStreamEncLiterals(curSrc, curSrcAnchor, c_ref!(curDest), destEnd) {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n\n        _OFFSET_AND_MATCH:\n\n        RapidlzWriteLE16(curDest, offset);\n        curDest += 2;\n\n        let mut matchLen: u32 = Default::default();\n        let mut curSrcMatchEnd: Ptr<u8> = Default::default();\n\n        if (prefixDictStart == dict) {\n            let mut srcLimitOnlyWithDict: Ptr<u8> = (curSrc + (dictEnd - r#match));\n            if (srcLimitOnlyWithDict > matchEndLimit) {\n                srcLimitOnlyWithDict = matchEndLimit;\n            }\n            curSrcMatchEnd = RapidlzCompressExpandBackward(srcLimitOnlyWithDict, (r#match + RAPIDLZ_MIN_MATCH!()), (curSrc + RAPIDLZ_MIN_MATCH!()));\n            matchLen = (curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH!()).cast::<u32>();\n            curSrc = curSrcMatchEnd;\n\n            if (curSrc == srcLimitOnlyWithDict) {\n                curSrcMatchEnd = RapidlzCompressExpandBackward(matchEndLimit, src, srcLimitOnlyWithDict);\n                matchLen += (curSrcMatchEnd - curSrc).cast::<u32>();\n                curSrc = curSrcMatchEnd;\n            }\n        } else {\n            curSrcMatchEnd = RapidlzCompressExpandBackward(matchEndLimit, (r#match + RAPIDLZ_MIN_MATCH!()), (curSrc + RAPIDLZ_MIN_MATCH!()));\n            matchLen = (curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH!()).cast::<u32>();\n            curSrc = curSrcMatchEnd;\n        }\n        #[cfg(RAPIDLZ_DEBUG)]\n        if RAPIDLZ_UNLIKELY!((RAPIDLZ_LIT_AND_MATCH_COPY_END!(curDest, matchLen) > destEnd)) {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n        curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n        curSrcAnchor = curSrc;\n        if (curSrc >= matchStartLimit) {\n            break;\n        }\n        let mut hv2: u32 = RapidlzHash4CalcValue((curSrc - 2));\n        let mut index: u32 = (curSrc - 2 - base);\n        RapidlzHash4PutPos(index, hv2, strmCtx.hashTable);\n\n        hashValue = RapidlzHash4CalcValue(curSrc);\n        let mut current: u32 = (curSrc - base);\n        let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue, strmCtx.hashTable);\n        if (matchOffset < startIndex) {\n            r#match = (dictBase + matchOffset);\n            prefixDictStart = dict;\n        } else {\n            r#match = (base + matchOffset);\n            prefixDictStart = src;\n        }\n\n        RapidlzHash4PutPos(current, hashValue, strmCtx.hashTable);\n\n        if (matchOffset >= prefixDictLimit) && (matchOffset + RAPIDLZ_MAX_OFFSET!() >= current) {\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(r#match)) {\n                token = curDest;\n                curDest += 1;\n                *token = 0;\n                offset = (current - matchOffset);\n                goto _OFFSET_AND_MATCH;\n            }\n        }\n        forwardHashValue = RapidlzHash4CalcValue((curSrc + 1));\n        curSrc += 1;\n    }\n\n    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605214440)\nerror: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n   --> src/src/rapidlz_dictionary_c.rs:394:33\n    |\n394 |         RapidlzWriteLE16(curDest.cast(), offset.cast());\n    |                                 ^\n    |                                 |\n    |                                 expected one of 7 possible tokens\n    |                                 help: missing `,`\n\nerror: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n   --> src/src/rapidlz_dictionary_c.rs:394:48\n    |\n394 |         RapidlzWriteLE16(curDest.cast(), offset.cast());\n    |                                                ^\n    |                                                |\n    |                                                expected one of 7 possible tokens\n    |                                                help: missing `,`\n\nerror: expected identifier, found `:`\n   --> src/src/rapidlz_dictionary_c.rs:392:26\n    |\n392 |         _OFFSET_AND_MATCH:\n    |                          ^ expected identifier\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:335:23\n    |\n328 |     let mut prefixDictStart: Ptr<u8> = Default::default();\n    |                              ------- expected due to this type\n...\n335 |     prefixDictStart = 0;\n    |                       ^ expected `Ptr<u8>`, found integer\n    |\n    = note: expected struct `memory::ptr::Ptr<u8>`\n                 found type `{integer}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n335 |     *prefixDictStart = 0;\n    |     +\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:338:25\n    |\n338 |     strmCtx.dictSize += srcSize;\n    |                         ^^^^^^^ expected `u32`, found `i32`\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n   --> src/src/rapidlz_dictionary_c.rs:338:22\n    |\n338 |     strmCtx.dictSize += srcSize;\n    |                      ^^ no implementation for `u32 += i32`\n    |\n    = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "int RapidlzCompWithPrefixDict(RapidlzStreamCtx *strmCtx, const char *src, char *dest, int srcSize, int destSize)\n    {\n        uint8_t *curSrc = (uint8_t *)src;\n        uint8_t *curSrcAnchor = (uint8_t *)curSrc;\n        uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + destSize;\n        if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH)\n        {\n            return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n        }\n        uint8_t *matchStartLimit = srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE + 1;\n        uint8_t *matchEndLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        uint32_t startIndex = strmCtx->currentOffset;\n        uint8_t *base = (uint8_t *)src - startIndex;\n\n        uint8_t *prefixDictStart;\n        uint32_t dictSize;\n        dictSize = strmCtx->dictSize;\n        prefixDictStart = (uint8_t *)src - dictSize;\n        strmCtx->dictSize += srcSize;\n        uint32_t prefixDictLimit = startIndex - dictSize;\n        strmCtx->currentOffset += (uint32_t)srcSize;\n\n        uint32_t hashValue = RapidlzHash4CalcValue(curSrc);\n        RapidlzHash4PutPos(startIndex, hashValue, strmCtx->hashTable);\n        curSrc++;\n        uint32_t forwardHashValue = RapidlzHash4CalcValue(curSrc);\n\n        uint8_t *match, *token;\n        int acceleration = strmCtx->acceleration;\n        while (true)\n        {\n            uint8_t *forwardPos = curSrc;\n            int step = 1;\n            int searchMatchNb = acceleration << RAPIDLZ_STEP_FORWARD_BASE;\n            do\n            {\n                hashValue = forwardHashValue;\n                uint32_t current = (forwardPos - base);\n                uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n                curSrc = forwardPos;\n                forwardPos += step;\n                step = (searchMatchNb++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (RAPIDLZ_UNLIKELY(forwardPos > matchStartLimit))\n                {\n                    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n                }\n\n                match = base + matchOffset;\n                forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n                RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n\n                if (matchOffset < prefixDictLimit)\n                {\n                    continue;\n                }\n                if ((matchOffset + RAPIDLZ_MAX_OFFSET) < current)\n                {\n                    continue;\n                }\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    break;\n                }\n            } while (1);\n\n            RAPIDLZ_EXPAND_FORWARD(prefixDictStart, match, curSrc, curSrcAnchor);\n\n            token = curDest;\n            RAPIDLZ_RETURN_IF_NOT_TRUE(RapidlzStreamEncLiterals(curSrc, curSrcAnchor, &curDest, destEnd),\n                                       RAPIDLZ_ENC_NOT_OK);\n\n        _OFFSET_AND_MATCH:\n\n            RapidlzWriteLE16(curDest, curSrc - match);\n            curDest += 2;\n\n            uint32_t matchLen;\n            uint8_t *curSrcMatchEnd;\n\n            curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, match + RAPIDLZ_MIN_MATCH,\n                                                                      curSrc + RAPIDLZ_MIN_MATCH);\n            matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n            curSrc = curSrcMatchEnd;\n#ifdef RAPIDLZ_DEBUG\n            if (RAPIDLZ_UNLIKELY(RAPIDLZ_LIT_AND_MATCH_COPY_END(curDest, matchLen) > destEnd))\n            {\n                return RAPIDLZ_ENC_NOT_OK;\n            }\n#endif\n            curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n\n            curSrcAnchor = curSrc;\n            if (curSrc >= matchStartLimit)\n            {\n                break;\n            }\n            uint32_t hv = RapidlzHash4CalcValue(curSrc - 2);\n            uint32_t index = curSrc - 2 - base;\n            RapidlzHash4PutPos(index, hv, strmCtx->hashTable);\n\n            hashValue = RapidlzHash4CalcValue(curSrc);\n            uint32_t current = (curSrc - base);\n            uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n\n            match = base + matchOffset;\n\n            RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n            if ((matchOffset >= prefixDictLimit) && ((matchOffset + RAPIDLZ_MAX_OFFSET) >= current))\n            {\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    token = curDest++;\n                    *token = 0;\n                    goto _OFFSET_AND_MATCH;\n                }\n            }\n            forwardHashValue = RapidlzHash4CalcValue(++curSrc);\n        }\n\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }",
            "rust_code": "pub fn RapidlzCompWithPrefixDict(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut destSize: i32) -> i32 {\n    let mut curSrc: Ptr<u8> = src;\n    let mut curSrcAnchor: Ptr<u8> = curSrc;\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize);\n    let mut curDest: Ptr<u8> = dest;\n    let mut destEnd: Ptr<u8> = (curDest + destSize);\n    if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH!()) {\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }\n    let mut matchStartLimit: Ptr<u8> = (srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE!() + 1);\n    let mut matchEndLimit: Ptr<u8> = (srcEnd - RAPIDLZ_LAST_LITERALS!());\n    let mut startIndex: u32 = strmCtx.currentOffset;\n    let mut base: Ptr<u8> = (src - startIndex);\n\n    let mut prefixDictStart: Ptr<u8>;\n    let mut dictSize: u32;\n    dictSize = strmCtx.dictSize;\n    prefixDictStart = (src - dictSize);\n    strmCtx.dictSize += srcSize.cast();\n    let mut prefixDictLimit: u32 = (startIndex - dictSize);\n    strmCtx.currentOffset += srcSize.cast::<u32>();\n\n    let mut hashValue: u32 = RapidlzHash4CalcValue(curSrc);\n    RapidlzHash4PutPos(startIndex, hashValue, strmCtx.hashTable.cast());\n    curSrc += 1;\n    let mut forwardHashValue: u32 = RapidlzHash4CalcValue(curSrc);\n\n    let mut r#match: Ptr<u8>;\n    let mut token: Ptr<u8>;\n    let mut acceleration: i32 = strmCtx.acceleration;\n    loop {\n        let mut forwardPos: Ptr<u8> = curSrc;\n        let mut step: i32 = 1;\n        let mut searchMatchNb: i32 = (acceleration << RAPIDLZ_STEP_FORWARD_BASE!());\n        loop {\n            hashValue = forwardHashValue;\n            let mut current: u32 = (forwardPos - base).cast();\n            let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue, strmCtx.hashTable.cast());\n            curSrc = forwardPos;\n            forwardPos += step;\n            step = (searchMatchNb >> RAPIDLZ_STEP_FORWARD_BASE!());\n            searchMatchNb += 1;\n\n            if RAPIDLZ_UNLIKELY!(forwardPos > matchStartLimit) {\n                return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n            }\n\n            r#match = (base + matchOffset);\n            forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n            RapidlzHash4PutPos(current, hashValue, strmCtx.hashTable.cast());\n\n            if (matchOffset < prefixDictLimit) {\n                continue;\n            }\n            if ((matchOffset + RAPIDLZ_MAX_OFFSET!()) < current) {\n                continue;\n            }\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(r#match)) {\n                break;\n            }\n        }\n\n        RAPIDLZ_EXPAND_FORWARD!(prefixDictStart, r#match, curSrc, curSrcAnchor);\n\n        token = curDest;\n        if !RapidlzStreamEncLiterals(curSrc, curSrcAnchor, c_ref!(curDest), destEnd) {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n\n        _OFFSET_AND_MATCH:\n\n        RapidlzWriteLE16(curDest, (curSrc - r#match));\n        curDest += 2;\n\n        let mut matchLen: u32;\n        let mut curSrcMatchEnd: Ptr<u8>;\n\n        curSrcMatchEnd = RapidlzCompressExpandBackward(matchEndLimit, (r#match + RAPIDLZ_MIN_MATCH!()), (curSrc + RAPIDLZ_MIN_MATCH!()));\n        matchLen = (curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH!()).cast::<u32>();\n        curSrc = curSrcMatchEnd;\n        if RAPIDLZ_UNLIKELY!(RAPIDLZ_LIT_AND_MATCH_COPY_END!(curDest, matchLen) > destEnd) {\n            return RAPIDLZ_ENC_NOT_OK!();\n        }\n        curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n\n        curSrcAnchor = curSrc;\n        if (curSrc >= matchStartLimit) {\n            break;\n        }\n        let mut hv: u32 = RapidlzHash4CalcValue((curSrc - 2));\n        let mut index: u32 = (curSrc - 2 - base);\n        RapidlzHash4PutPos(index, hv, strmCtx.hashTable);\n\n        hashValue = RapidlzHash4CalcValue(curSrc);\n        let mut current: u32 = (curSrc - base);\n        let mut matchOffset: u32 = RapidlzHash4GetPos(hashValue, strmCtx.hashTable);\n\n        r#match = (base + matchOffset);\n\n        RapidlzHash4PutPos(current, hashValue, strmCtx.hashTable);\n        if (matchOffset >= prefixDictLimit) && ((matchOffset + RAPIDLZ_MAX_OFFSET!()) >= current) {\n            if (RAPIDLZ_READ32BIT!(curSrc) == RAPIDLZ_READ32BIT!(r#match)) {\n                token = curDest;\n                curDest += 1;\n                *token = 0;\n                goto!(_OFFSET_AND_MATCH);\n            }\n        }\n        forwardHashValue = RapidlzHash4CalcValue((curSrc + 1));\n        curSrc += 1;\n    }\n\n    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605294191)\nerror: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n   --> src/src/rapidlz_dictionary_c.rs:386:33\n    |\n386 |         RapidlzWriteLE16(curDest.cast(), (curSrc - r#match).cast());\n    |                                 ^\n    |                                 |\n    |                                 expected one of 7 possible tokens\n    |                                 help: missing `,`\n\nerror: expected identifier, found `:`\n   --> src/src/rapidlz_dictionary_c.rs:384:26\n    |\n384 |         _OFFSET_AND_MATCH:\n    |                          ^ expected identifier\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static int RapidlzDecWithPrefixDict(const char *const src, char *const dest, int srcSize, int outBufferSize,\n                                        const char *dictStart, int dictSize)\n    {\n        (void)dictStart;\n        (void)dictSize;\n#ifdef RAPIDLZ_DEBUG\n        dictSize = (dictSize > RAPIDLZ_MAX_DICT_SIZE) ? RAPIDLZ_MAX_DICT_SIZE : dictSize;\n        uint8_t *prefixDictStart = (uint8_t *)dest - dictSize;\n#endif\n        const uint8_t *curSrc = (const uint8_t *)src;\n        const uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + outBufferSize;\n\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *destEndFast = destEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n\n        uint32_t token, len;\n        uint16_t offset;\n        uint8_t *matchSrc;\n        uint32_t tmp = 0;\n        size_t leftSrcSize;\n        while (1)\n        {\n            token = *curSrc++;\n\n            len = token >> 4;\n            if (RAPIDLZ_LIKELY(len < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)))\n                {\n                    RapidlzCopy16Byte(curDest, curSrc);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, tmp);\n                if (RAPIDLZ_LIKELY((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)))\n                {\n                    RapidlzWildCopy16(curSrc, curDest, curDest + len);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n\n            offset = RapidlzReadLE16Bit(curSrc);\n            curSrc += 2;\n            matchSrc = curDest - offset;\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_UNLIKELY(matchSrc < prefixDictStart)), RAPIDLZ_DEC_NOT_OK);\n#endif\n\n            len = token & RAPIDLZ_MAX_4BIT_VALUE;\n\n            if (len < RAPIDLZ_MAX_4BIT_VALUE)\n            {\n                len += 4;\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, tmp);\n                len += 4;\n            }\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS), RAPIDLZ_DEC_NOT_OK);\n#endif\n\n            if (RAPIDLZ_LIKELY((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE + RAPIDLZ_LAST_LITERALS)))\n            {\n                RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                curDest += len;\n            }\n            else\n            {\n                if (RAPIDLZ_LIKELY(len < 1024))\n                {\n                    RAPIDLZ_FAST_SAFE_COPY_BY_BYTES(curDest, matchSrc, len);\n                }\n                else\n                {\n                    RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                    curDest += len;\n                }\n            }\n        }\n\n        return (int)((void *)curDest - (void *)(dest));\n    }",
            "rust_code": "pub fn RapidlzDecWithPrefixDict(mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut outBufferSize: i32, mut dictStart: Ptr<u8>, mut dictSize: i32) -> i32 {\n    // (void)dictStart;\n    // (void)dictSize;\n    #[cfg(RAPIDLZ_DEBUG)]\n    {\n        dictSize = if dictSize > RAPIDLZ_MAX_DICT_SIZE!() { RAPIDLZ_MAX_DICT_SIZE!() } else { dictSize };\n        let mut prefixDictStart: Ptr<u8> = (dest - dictSize);\n    }\n    let mut curSrc: Ptr<u8> = src;\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize);\n    let mut curDest: Ptr<u8> = dest;\n    let mut destEnd: Ptr<u8> = (curDest + outBufferSize);\n\n    let mut srcEndFast: Ptr<u8> = (srcEnd - RAPIDLZ_COPY_PROTECT_SIZE!());\n    let mut destEndFast: Ptr<u8> = (destEnd - RAPIDLZ_COPY_PROTECT_SIZE!());\n\n    let mut token: u32;\n    let mut len: u32;\n    let mut offset: u16;\n    let mut matchSrc: Ptr<u8>;\n    let mut tmp: u32 = 0;\n    let mut leftSrcSize: usize;\n    loop {\n        token = (*curSrc);\n        curSrc += 1;\n\n        len = token >> 4;\n        if RAPIDLZ_LIKELY!(len < RAPIDLZ_MAX_4BIT_VALUE!()) {\n            if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast) {\n                RapidlzCopy16Byte(curDest, curSrc);\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc);\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, tmp);\n            if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)) {\n                RapidlzWildCopy16(curSrc, curDest, (curDest + len));\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc);\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        }\n\n        offset = RapidlzReadLE16Bit(curSrc);\n        curSrc += 2;\n        matchSrc = (curDest - offset);\n        #[cfg(RAPIDLZ_DEBUG)]\n        {\n            RAPIDLZ_RETURN_IF_NOT_TRUE!(!RAPIDLZ_UNLIKELY!(matchSrc < prefixDictStart), RAPIDLZ_DEC_NOT_OK!());\n        }\n\n        len = token & RAPIDLZ_MAX_4BIT_VALUE!();\n\n        if (len < RAPIDLZ_MAX_4BIT_VALUE!()) {\n            len += 4;\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, tmp);\n            len += 4;\n        }\n        #[cfg(RAPIDLZ_DEBUG)]\n        {\n            RAPIDLZ_RETURN_IF_NOT_TRUE!(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS!()), RAPIDLZ_DEC_NOT_OK!());\n        }\n\n        if RAPIDLZ_LIKELY!((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE!() + RAPIDLZ_LAST_LITERALS!())) {\n            RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n            curDest += len;\n        } else {\n            if RAPIDLZ_LIKELY!(len < 1024) {\n                RAPIDLZ_FAST_SAFE_COPY_BY_BYTES!(curDest, matchSrc, len);\n            } else {\n                RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                curDest += len;\n            }\n        }\n    }\n\n    return (curDest.cast::<Ptr<Void>>() - dest.cast::<Ptr<Void>>()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605369558)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:418:31\n    |\n417 |         if RAPIDLZ_LIKELY!(len < RAPIDLZ_MAX_4BIT_VALUE!()).as_bool() {\n    |                                                                       - closing delimiter possibly meant for this\n418 |             if RAPIDLZ_LIKELY!((curSrc + len <= srcEndFast).as_bool() && (curDest + len <= destEndFast).as_bool() {\n    |                               ^ unclosed delimiter\n...\n425 |         } else {\n    |         ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static int RapidlzDecWithExternalDict(const char *const src, char *const dest, int srcSize, int outBufferSize,\n                                          const char *dictStart, int dictSize)\n    {\n        const uint8_t *curSrc = (const uint8_t *)src;\n        const uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + outBufferSize;\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *destEndFast = destEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *dictEnd = (uint8_t *)dictStart + dictSize;\n\n        uint32_t token, len;\n        uint16_t offset;\n        uint8_t *matchSrc;\n        uint32_t temp = 0;\n        size_t leftSrcSize;\n        while (1)\n        {\n            token = *curSrc++;\n\n            len = token >> 4;\n            if (RAPIDLZ_LIKELY(len < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY(RAPIDLZ_DICT_FAST_COPY_AVAIL(curSrc, len, srcEndFast, curDest, destEndFast)))\n                {\n                    RapidlzCopy16Byte(curDest, curSrc);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, temp);\n                if (RAPIDLZ_LIKELY(RAPIDLZ_DICT_FAST_COPY_AVAIL(curSrc, len, srcEndFast, curDest, destEndFast)))\n                {\n                    RapidlzWildCopy16(curSrc, curDest, curDest + len);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n\n            offset = RapidlzReadLE16Bit(curSrc);\n            curSrc += 2;\n            matchSrc = curDest - offset;\n\n            len = token & RAPIDLZ_MAX_4BIT_VALUE;\n\n            RAPIDLZ_GET_MATCH_LEN(len, curSrc, srcEnd, temp);\n\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS), RAPIDLZ_DEC_NOT_OK);\n#endif\n            if (matchSrc >= (uint8_t *)dest)\n            {\n                if (RAPIDLZ_LIKELY((curDest + len) <=\n                                   (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE + RAPIDLZ_LAST_LITERALS)))\n                {\n                    RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                    curDest += len;\n                }\n                else\n                {\n                    if (RAPIDLZ_LIKELY(len < 1024))\n                    {\n                        RAPIDLZ_FAST_SAFE_COPY_BY_BYTES(curDest, matchSrc, len);\n                    }\n                    else\n                    {\n                        RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                        curDest += len;\n                    }\n                }\n            }\n            else\n            {\n                errno_t err;\n                if ((int)len <= ((uint8_t *)dest - matchSrc))\n                {\n                    err = memmove_s(curDest, destEnd - curDest, dictEnd - ((uint8_t *)dest - matchSrc), len);\n                    curDest += len;\n                }\n                else\n                {\n                    size_t externCopySize = (size_t)((uint8_t *)dest - matchSrc);\n                    size_t innerCopySize = len - externCopySize;\n                    err = memcpy_s(curDest, destEnd - curDest, dictEnd - externCopySize, externCopySize);\n                    curDest += externCopySize;\n                    if (innerCopySize > (size_t)(curDest - (uint8_t *)dest))\n                    {\n                        const uint8_t *copySrc = (uint8_t *)dest;\n                        while ((innerCopySize--) != 0)\n                        {\n                            *curDest++ = *copySrc++;\n                        }\n                    }\n                    else\n                    {\n                        err = memcpy_s(curDest, destEnd - curDest, (uint8_t *)dest, innerCopySize);\n                        curDest += innerCopySize;\n                    }\n                }\n#ifdef RAPIDLZ_DEBUG\n                RAPIDLZ_RETURN_IF_NOT_EOK(err, RAPIDLZ_DEC_NOT_OK);\n#else\n            (void)err;\n#endif\n            }\n        }\n\n        return (int)((void *)curDest - (void *)(dest));\n    }",
            "rust_code": "pub fn RapidlzDecWithExternalDict(mut src: Ptr<u8>, mut dest: Ptr<u8>, mut srcSize: i32, mut outBufferSize: i32, mut dictStart: Ptr<u8>, mut dictSize: i32) -> i32 {\n    let mut curSrc: Ptr<u8> = src;\n    let mut srcEnd: Ptr<u8> = (curSrc + srcSize);\n    let mut curDest: Ptr<u8> = dest;\n    let mut destEnd: Ptr<u8> = (curDest + outBufferSize);\n    let mut srcEndFast: Ptr<u8> = (srcEnd - RAPIDLZ_COPY_PROTECT_SIZE!());\n    let mut destEndFast: Ptr<u8> = (destEnd - RAPIDLZ_COPY_PROTECT_SIZE!());\n    let mut dictEnd: Ptr<u8> = (dictStart.cast::<Ptr<u8>>() + dictSize);\n\n    let mut token: u32;\n    let mut len: u32;\n    let mut offset: u16;\n    let mut matchSrc: Ptr<u8>;\n    let mut temp: u32 = 0;\n    let mut leftSrcSize: usize;\n    loop {\n        token = (*curSrc);\n        curSrc += 1;\n\n        len = (token >> 4);\n        if RAPIDLZ_LIKELY!(len < RAPIDLZ_MAX_4BIT_VALUE!()) {\n            if RAPIDLZ_LIKELY!(RAPIDLZ_DICT_FAST_COPY_AVAIL!(curSrc, len, srcEndFast, curDest, destEndFast)) {\n                RapidlzCopy16Byte(curDest, curSrc);\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc);\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(len, curSrc, srcEnd, temp);\n            if RAPIDLZ_LIKELY!(RAPIDLZ_DICT_FAST_COPY_AVAIL!(curSrc, len, srcEndFast, curDest, destEndFast)) {\n                RapidlzWildCopy16(curSrc, curDest, (curDest + len));\n                RAPIDLZ_POSITION_UPDATE!(curSrc, curDest, len);\n            } else {\n                leftSrcSize = (srcEnd - curSrc);\n                RAPIDLZ_SAFE_COPY_TILL_END!(curSrc, leftSrcSize, curDest, destEnd, len);\n            }\n        }\n\n        offset = RapidlzReadLE16Bit(curSrc);\n        curSrc += 2;\n        matchSrc = (curDest - offset);\n\n        len = (token & RAPIDLZ_MAX_4BIT_VALUE!());\n\n        RAPIDLZ_GET_MATCH_LEN!(len, curSrc, srcEnd, temp);\n\n        if (matchSrc >= dest.cast::<Ptr<u8>>()) {\n            if RAPIDLZ_LIKELY!((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE!() + RAPIDLZ_LAST_LITERALS!())) {\n                RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                curDest += len;\n            } else {\n                if RAPIDLZ_LIKELY!(len < 1024) {\n                    RAPIDLZ_FAST_SAFE_COPY_BY_BYTES!(curDest, matchSrc, len);\n                } else {\n                    RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                    curDest += len;\n                }\n            }\n        } else {\n            let mut err: errno_t;\n            if (len.cast::<i32>() <= (dest.cast::<Ptr<u8>>() - matchSrc).cast::<i32>() {\n                err = c_memmove_s!(curDest, destEnd - curDest, dictEnd - (dest.cast::<Ptr<u8>>() - matchSrc), len);\n                curDest += len;\n            } else {\n                let mut externCopySize: usize = (dest.cast::<Ptr<u8>>() - matchSrc);\n                let mut innerCopySize: usize = (len - externCopySize);\n                err = c_memcpy_s!(curDest, destEnd - curDest, dictEnd - externCopySize, externCopySize);\n                curDest += externCopySize;\n                if (innerCopySize > (curDest - dest.cast::<Ptr<u8>>()).cast::<usize>() {\n                    let mut copySrc: Ptr<u8> = dest;\n                    while (innerCopySize != 0) {\n                        *curDest = *copySrc;\n                        curDest += 1;\n                        copySrc += 1;\n                        innerCopySize -= 1;\n                    }\n                } else {\n                    err = c_memcpy_s!(curDest, destEnd - curDest, dest, innerCopySize);\n                    curDest += innerCopySize;\n                }\n            }\n        }\n    }\n\n    return (curDest.cast::<Ptr<Void>>() - dest.cast::<Ptr<Void>>()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605372642)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:464:20\n    |\n459 |             } else {\n    |                    - closing delimiter possibly meant for this\n...\n464 |                 if (innerCopySize > (curDest - dest.cast::<Ptr<u8>>()).cast::<usize>().as_bool() {\n    |                    ^ unclosed delimiter\n...\n476 |             }\n    |             ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/rapidlz_dictionary_c.rs:456:16\n    |\n454 |         } else {\n    |                - closing delimiter possibly meant for this\n455 |             let mut err: errno_t;\n456 |             if (len.cast::<i32>() <= (dest.cast::<Ptr<u8>>() - matchSrc).cast::<i32>().as_bool() {\n    |                ^ unclosed delimiter\n...\n477 |         }\n    |         ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int RapidlzCompressStream(RapidlzStreamCtx *strmCtx, const char *src, char *dst, int srcSize, int dstSize)\n    {\n        RapidlzCompressFunc rapidlzEncFunc = NULL;\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE), RAPIDLZ_ENC_NOT_OK);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!((src == NULL && srcSize != 0) || (dstSize <= 0) || (dst == NULL)),\n                                   RAPIDLZ_ENC_NOT_OK);\n        if (srcSize == 0)\n        {\n            return RapidlzZeroBytesEncode(dst, dstSize);\n        }\n        char *dictEnd = (strmCtx->dictSize != 0) ? (char *)strmCtx->dict + strmCtx->dictSize : NULL;\n        int cSize;\n        if (dictEnd == src)\n        {\n            rapidlzEncFunc = RapidlzCompWithPrefixDict;\n        }\n        else\n        {\n            if (strmCtx->strmCtxSpecific != NULL)\n            {\n                RAPIDLZ_RETURN_IF_NOT_EOK(\n                    memcpy_s(strmCtx, sizeof(RapidlzStreamCtx), strmCtx->strmCtxSpecific, sizeof(RapidlzStreamCtx)),\n                    RAPIDLZ_ENC_NOT_OK);\n            }\n            rapidlzEncFunc = RapidlzCompWithExternalDict;\n        }\n        RapidlzStrmCtxNorm(strmCtx, (char *)src, srcSize, dictEnd);\n        cSize = rapidlzEncFunc(strmCtx, src, dst, srcSize, dstSize);\n        strmCtx->dictSize = srcSize;\n        strmCtx->dict = (uint8_t *)src;\n        return cSize;\n    }",
            "rust_code": "pub fn RapidlzCompressStream(mut strmCtx: Ptr<RapidlzStreamCtx>, mut src: Ptr<u8>, mut dst: Ptr<u8>, mut srcSize: i32, mut dstSize: i32) -> i32 {\n    let mut rapidlzEncFunc: RapidlzCompressFunc = NULL!();\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE!()), RAPIDLZ_ENC_NOT_OK!());\n    RAPIDLZ_RETURN_IF_NOT_TRUE!(!((src == NULL!()) && (srcSize != 0) || (dstSize <= 0) || (dst == NULL!())), RAPIDLZ_ENC_NOT_OK!());\n    if (srcSize == 0) {\n        return RapidlzZeroBytesEncode(dst, dstSize);\n    }\n    let mut dictEnd: Ptr<u8> = if (strmCtx.dictSize != 0) { (strmCtx.dict.cast::<Ptr<u8>>() + strmCtx.dictSize) } else { NULL!() };\n    let mut cSize: i32;\n    if (dictEnd == src) {\n        rapidlzEncFunc = RapidlzCompWithPrefixDict;\n    } else {\n        if (strmCtx.strmCtxSpecific != NULL!()) {\n            RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(strmCtx, c_sizeofval!(strmCtx), strmCtx.strmCtxSpecific, c_sizeofval!(strmCtx)), RAPIDLZ_ENC_NOT_OK!());\n        }\n        rapidlzEncFunc = RapidlzCompWithExternalDict;\n    }\n    RapidlzStrmCtxNorm(strmCtx, src, srcSize, dictEnd);\n    cSize = rapidlzEncFunc(strmCtx, src, dst, srcSize, dstSize);\n    strmCtx.dictSize = srcSize.cast::<u32>();\n    strmCtx.dict = src.cast::<Ptr<u8>>();\n    return cSize;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605376035)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:403:5\n    |\n403 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!((src == NULL!()).as_bool() && (srcSize != 0).as_bool() || (dstSize <= 0).as_bool() || (dst == NULL!()).as_bool()), RAPIDLZ_ENC_NOT_OK!(...\n    |     ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:403:5\n    |\n403 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!((src == NULL!()).as_bool() && (srcSize != 0).as_bool() || (dstSize <= 0).as_bool() || (dst == NULL!()).as_bool()), RAPIDLZ_ENC_NOT_OK!(...\n    |     ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:413:13\n    |\n413 | ...   RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(strmCtx, c_sizeofval!(strmCtx), strmCtx.strmCtxSpecific, c_sizeofval!(strmCtx)), RAPIDLZ_ENC_NOT_OK!(...\n    |       ---------------------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:413:13\n    |\n413 | ...   RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(strmCtx, c_sizeofval!(strmCtx), strmCtx.strmCtxSpecific, c_sizeofval!(strmCtx)), RAPIDLZ_ENC_NOT_OK!(...\n    |       ---------------------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:402:5\n    |\n402 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     ---------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_dictionary_c.rs:402:5\n    |\n402 |     RAPIDLZ_RETURN_IF_NOT_TRUE!(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE!()).as_bool(), RAPIDLZ_ENC_NOT_OK!());\n    |     ---------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_dictionary_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_RETURN_IF_NOT_TRUE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `EOK`\n   --> src/src/rapidlz_dictionary_c.rs:102:26\n    |\n102 | ...f $condition != EOK {\n    |                    ^^^ not a value\n...\n413 | ...   RAPIDLZ_RETURN_IF_NOT_EOK!(c_memcpy_s!(strmCtx, c_sizeofval!(strmCtx), strmCtx.strmCtxSpecific, c_sizeofval!(strmCtx)), RAPIDLZ_ENC_NOT_OK!(...\n    |       ---------------------------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `RAPIDLZ_RETURN_IF_NOT_EOK` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:410:26\n    |\n401 |     let mut rapidlzEncFunc: RapidlzCompressFunc = NULL!();\n    |                             ------------------- expected due to this type\n...\n410 |         rapidlzEncFunc = RapidlzCompWithPrefixDict;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FuncPtr<fn(..., ..., ..., ..., ...) -> ...>`, found fn item\n    |\n    = note: expected struct `func_ptr::FuncPtr<fn(memory::ptr::Ptr<TagRapidlzStreamCtx>, memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32) -> i32>`\n              found fn item `fn(memory::ptr::Ptr<TagRapidlzStreamCtx>, memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32) -> i32 {RapidlzCompWithPrefixDict}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n410 |         *rapidlzEncFunc = RapidlzCompWithPrefixDict;\n    |         +\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:415:26\n    |\n401 |     let mut rapidlzEncFunc: RapidlzCompressFunc = NULL!();\n    |                             ------------------- expected due to this type\n...\n415 |         rapidlzEncFunc = RapidlzCompWithExternalDict;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FuncPtr<fn(..., ..., ..., ..., ...) -> ...>`, found fn item\n    |\n    = note: expected struct `func_ptr::FuncPtr<fn(memory::ptr::Ptr<TagRapidlzStreamCtx>, memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32) -> i32>`\n              found fn item `fn(memory::ptr::Ptr<TagRapidlzStreamCtx>, memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32) -> i32 {RapidlzCompWithExternalDict}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n415 |         *rapidlzEncFunc = RapidlzCompWithExternalDict;\n    |         +\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
        },
        {
            "c_code": "int RapidlzDecompressSafeUsingDict(const char *src, char *dst, int compressedSize, int dstSize,\n                                       const char *dictStart, int dictSize)\n    {\n        if ((src == NULL) || (compressedSize == 0) || (dst == NULL) || (dstSize < 0))\n        {\n            return RAPIDLZ_ERROR_PARAM_UNSUPPORTED;\n        }\n        if (RAPIDLZ_UNLIKELY(dstSize == 0))\n        {\n            return RapidlzZeroBytesDecode(src, compressedSize);\n        }\n        RapidlzDecompressFunc rapidlzDecFunc;\n        if ((dictSize == 0) || (dictStart + dictSize == dst))\n        {\n            rapidlzDecFunc = RapidlzDecWithPrefixDict;\n        }\n        else\n        {\n            rapidlzDecFunc = RapidlzDecWithExternalDict;\n        }\n        return rapidlzDecFunc(src, dst, compressedSize, dstSize, dictStart, dictSize);\n    }",
            "rust_code": "pub fn RapidlzDecompressSafeUsingDict(mut src: Ptr<u8>, mut dst: Ptr<u8>, mut compressedSize: i32, mut dstSize: i32, mut dictStart: Ptr<u8>, mut dictSize: i32) -> i32 {\n    if (src == NULL!()) || (compressedSize == 0) || (dst == NULL!()) || (dstSize < 0) {\n        return RAPIDLZ_ERROR_PARAM_UNSUPPORTED!();\n    }\n    if RAPIDLZ_UNLIKELY!(dstSize == 0) {\n        return RapidlzZeroBytesDecode(src, compressedSize);\n    }\n    let mut rapidlzDecFunc: RapidlzDecompressFunc;\n    if (dictSize == 0) || (dictStart + dictSize == dst) {\n        rapidlzDecFunc = RapidlzDecWithPrefixDict;\n    } else {\n        rapidlzDecFunc = RapidlzDecWithExternalDict;\n    }\n    return rapidlzDecFunc(src, dst, compressedSize, dstSize, dictStart, dictSize);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605382112)\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:414:26\n    |\n412 |     let mut rapidlzDecFunc: RapidlzDecompressFunc;\n    |                             --------------------- expected due to this type\n413 |     if (dictSize == 0).as_bool() || (dictStart + dictSize == dst).as_bool() {\n414 |         rapidlzDecFunc = RapidlzDecWithPrefixDict;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `FuncPtr<fn(..., ..., ..., ..., ..., ...) -> ...>`, found fn item\n    |\n    = note: expected struct `func_ptr::FuncPtr<fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32>`\n              found fn item `fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32 {RapidlzDecWithPrefixDict}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n414 |         *rapidlzDecFunc = RapidlzDecWithPrefixDict;\n    |         +\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_dictionary_c.rs:416:26\n    |\n412 |     let mut rapidlzDecFunc: RapidlzDecompressFunc;\n    |                             --------------------- expected due to this type\n...\n416 |         rapidlzDecFunc = RapidlzDecWithExternalDict;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FuncPtr<fn(..., ..., ..., ..., ..., ...) -> ...>`, found fn item\n    |\n    = note: expected struct `func_ptr::FuncPtr<fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32>`\n              found fn item `fn(memory::ptr::Ptr<u8>, memory::ptr::Ptr<u8>, i32, i32, memory::ptr::Ptr<u8>, i32) -> i32 {RapidlzDecWithExternalDict}`\nhelp: consider dereferencing here to assign to the mutably borrowed value\n    |\n416 |         *rapidlzDecFunc = RapidlzDecWithExternalDict;\n    |         +\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "size_t RapidlzDecompress(const void *src, void *dst, size_t srcSize, size_t dstSize)\n    {\n        if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n            return 0;\n        }\n\n        uint8_t token, temp = 0;\n        register uint16_t offset;\n        register uint32_t litLen, matchLen;\n        uint8_t *matchSrc;\n        const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n        const uint8_t *srcCurr = (const uint8_t *)src;\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n        uint8_t *dstCurr = (uint8_t *)dst;\n        uint8_t *dstEndFast = dstEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n\n        while (srcCurr < srcEnd)\n        {\n            token = *srcCurr++;\n            litLen = (token >> 4);\n\n            if (RAPIDLZ_LIKELY(litLen < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n                {\n                    RapidlzCopy16Byte(dstCurr, srcCurr);\n                    dstCurr += litLen;\n                    srcCurr += litLen;\n                    goto READ_MATCH;\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(litLen, srcCurr, srcEnd, temp);\n                if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n                {\n                    RapidlzWildCopy16(srcCurr, dstCurr, dstCurr + litLen);\n                    dstCurr += litLen;\n                    srcCurr += litLen;\n                    goto READ_MATCH;\n                }\n            }\n\n            size_t leftSrcSize = srcEnd - srcCurr;\n            if (RAPIDLZ_UNLIKELY(litLen > leftSrcSize || memmove_s(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"litLen:%u dstEnd - dst:%zu\\n\", litLen, leftSrcSize);\n                return 0;\n            }\n\n            dstCurr += litLen;\n            srcCurr += litLen;\n\n            if (leftSrcSize == litLen)\n            {\n                return dstCurr - (uint8_t *)(dst);\n            }\n\n        READ_MATCH:\n            if (RAPIDLZ_UNLIKELY(srcCurr > srcEnd - 2))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n                return 0;\n            }\n            offset = RapidlzReadLE16Bit(srcCurr);\n            srcCurr += 2;\n            matchSrc = dstCurr - offset;\n            if (RAPIDLZ_UNLIKELY((void *)matchSrc < dst))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n                return 0;\n            }\n\n            matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE) + RAPIDLZ_MIN_MATCH;\n            if (matchLen == RAPIDLZ_MAX_4BIT_MATCH)\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(matchLen, srcCurr, srcEnd, temp);\n            }\n\n            if (RAPIDLZ_LIKELY(dstCurr + matchLen <= dstEndFast))\n            {\n                RapidlzCopyMatchFast(dstCurr, matchSrc, offset, matchLen);\n                dstCurr += matchLen;\n            }\n            else\n            {\n                if (dstCurr + matchLen > dstEnd)\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCurr:%zu matchLen:%u\\n\", dstEnd - dstCurr,\n                                matchLen);\n                    return 0;\n                }\n\n                SAFE_COPY_MATCH(dstCurr, matchSrc, matchLen);\n            }\n        }\n\n        return dstCurr - (uint8_t *)dst;\n    }",
            "rust_code": "pub fn RapidlzDecompress(mut src: Ptr<Void>, mut dst: Ptr<Void>, mut srcSize: usize, mut dstSize: usize) -> usize {\n    if (src == NULL!() || dst == NULL!() || srcSize == 0 || dstSize == 0) {\n        RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n        return 0;\n    }\n\n    let mut token: u8 = Default::default();\n    let mut temp: u8 = 0;\n    let mut offset: u16 = Default::default();\n    let mut litLen: u32 = Default::default();\n    let mut matchLen: u32 = Default::default();\n    let mut matchSrc: Ptr<u8> = Default::default();\n    let mut srcEnd: Ptr<u8> = (src.cast::<Ptr<u8>>() + srcSize);\n    let mut srcCurr: Ptr<u8> = src.cast::<Ptr<u8>>();\n    let mut srcEndFast: Ptr<u8> = (srcEnd - RAPIDLZ_COPY_PROTECT_SIZE!());\n    let mut dstEnd: Ptr<u8> = (dst.cast::<Ptr<u8>>() + dstSize);\n    let mut dstCurr: Ptr<u8> = dst.cast::<Ptr<u8>>();\n    let mut dstEndFast: Ptr<u8> = (dstEnd - RAPIDLZ_COPY_PROTECT_SIZE!());\n\n    while (srcCurr < srcEnd) {\n        token = *srcCurr;\n        srcCurr += 1;\n        litLen = (token >> 4).cast();\n\n        if RAPIDLZ_LIKELY!(litLen < RAPIDLZ_MAX_4BIT_VALUE!()) {\n            if RAPIDLZ_LIKELY!(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast) {\n                RapidlzCopy16Byte(dstCurr, srcCurr);\n                dstCurr += litLen;\n                srcCurr += litLen;\n                goto!(READ_MATCH);\n            }\n        } else {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n            if RAPIDLZ_LIKELY!(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast) {\n                RapidlzWildCopy16(srcCurr, dstCurr, (dstCurr + litLen));\n                dstCurr += litLen;\n                srcCurr += litLen;\n                goto!(READ_MATCH);\n            }\n        }\n\n        let mut leftSrcSize: usize = (srcEnd - srcCurr);\n        if RAPIDLZ_UNLIKELY!(litLen > leftSrcSize || c_memmove_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK!()) {\n            RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"litLen:{} dstEnd - dst:{}\\n\"), litLen, leftSrcSize);\n            return 0;\n        }\n\n        dstCurr += litLen;\n        srcCurr += litLen;\n\n        if (leftSrcSize == litLen) {\n            return (dstCurr - dst.cast::<Ptr<u8>>());\n        }\n\n        label!(READ_MATCH);\n        if RAPIDLZ_UNLIKELY!(srcCurr > srcEnd - 2) {\n            RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n            return 0;\n        }\n        offset = RapidlzReadLE16Bit(srcCurr);\n        srcCurr += 2;\n        matchSrc = (dstCurr - offset);\n        if RAPIDLZ_UNLIKELY!(matchSrc.cast::<Ptr<Void>>() < dst) {\n            RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n            return 0;\n        }\n\n        matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE!()) + RAPIDLZ_MIN_MATCH!();\n        if (matchLen == RAPIDLZ_MAX_4BIT_MATCH!()) {\n            RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n        }\n\n        if RAPIDLZ_LIKELY!(dstCurr + matchLen <= dstEndFast) {\n            RapidlzCopyMatchFast(dstCurr, matchSrc, offset, matchLen);\n            dstCurr += matchLen;\n        } else {\n            if (dstCurr + matchLen > dstEnd) {\n                RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCurr:{} matchLen:{}\\n\"), (dstEnd - dstCurr), matchLen);\n                return 0;\n            }\n\n            SAFE_COPY_MATCH!(dstCurr, matchSrc, matchLen);\n        }\n    }\n\n    return (dstCurr - dst.cast::<Ptr<u8>>());\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605386643)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:11:9\n    |\n11  |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:11:9\n    |\n11  |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `goto` in this scope\n  --> src/src/rapidlz_decompress_c.rs:38:17\n   |\n38 |                 goto!(READ_MATCH);\n   |                 ^^^^\n\nerror: cannot find macro `goto` in this scope\n  --> src/src/rapidlz_decompress_c.rs:46:17\n   |\n46 |                 goto!(READ_MATCH);\n   |                 ^^^^\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:52:13\n    |\n52  |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"litLen:{} dstEnd - dst:{}\\n\"), litLen, leftSrcSize);\n    |             -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:52:13\n    |\n52  |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"litLen:{} dstEnd - dst:{}\\n\"), litLen, leftSrcSize);\n    |             -------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `label` in this scope\n  --> src/src/rapidlz_decompress_c.rs:63:9\n   |\n63 |         label!(READ_MATCH);\n   |         ^^^^^\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:65:13\n    |\n65  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:65:13\n    |\n65  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:72:13\n    |\n72  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:72:13\n    |\n72  |             RAPIDLZ_LOG!(RAPIDLZ_FORMAT_INVALID!(), cstr!(\"rapidlz format invalid\\n\"));\n    |             -------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:86:17\n    |\n86  |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCurr:{} matchLen:{}\\n\"), (dstEnd - dstCurr).cast(), matchLen);\n    |                 ------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:86:17\n    |\n86  |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCurr:{} matchLen:{}\\n\"), (dstEnd - dstCurr).cast(), matchLen);\n    |                 ------------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_decompress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:41:68\n   |\n41 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n   |                                                                    ^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:153:18\n    |\n153 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:41:13\n    |\n41  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n    |             ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:157:18\n    |\n157 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:41:13\n    |\n41  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(litLen, srcCurr, srcEnd, temp);\n    |             ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:51:39\n   |\n51 |         if RAPIDLZ_UNLIKELY!(litLen > leftSrcSize || c_memmove_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK!()).as_bool() {\n   |                              ------   ^^^^^^^^^^^ expected `u32`, found `usize`\n   |                              |\n   |                              expected because this is `u32`\n   |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n   |\n51 |         if RAPIDLZ_UNLIKELY!(litLen > leftSrcSize.try_into().unwrap() || c_memmove_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK!()).as_bool() {\n   |                                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:59:28\n   |\n59 |         if (leftSrcSize == litLen).as_bool() {\n   |             -----------    ^^^^^^ expected `usize`, found `u32`\n   |             |\n   |             expected because this is `usize`\n   |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n59 |         if (leftSrcSize == litLen.try_into().unwrap()).as_bool() {\n   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:76:20\n   |\n19 |     let mut matchLen: u32 = Default::default();\n   |                       --- expected due to this type\n...\n76 |         matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE!()) + RAPIDLZ_MIN_MATCH!();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0308]: mismatched types\n  --> src/src/rapidlz_decompress_c.rs:78:70\n   |\n78 |             RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n   |                                                                      ^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:153:18\n    |\n153 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:78:13\n    |\n78  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n    |             -------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u8` to `u32`\n   --> src/src/rapidlz_inner_h.rs:157:18\n    |\n157 |             $len += $temp;\n    |                  ^^ no implementation for `u32 += u8`\n    |\n   ::: src/src/rapidlz_decompress_c.rs:78:13\n    |\n78  |             RAPIDLZ_READ_OPTIONAL_LENGTH!(matchLen, srcCurr, srcEnd, temp);\n    |             -------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `RAPIDLZ_READ_OPTIONAL_LENGTH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 22 previous errors\n"
        },
        {
            "c_code": "const char *RapidlzVersionGet(void)\n    {\n        return g_rapidlzVersion;\n    }",
            "rust_code": "pub fn RapidlzVersionGet() -> Ptr<u8> {\n    return g_rapidlzVersion;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605398243)\nerror[E0277]: the trait bound `types::global::Global<memory::ptr::Ptr<u8>>: CastInto<memory::ptr::Ptr<u8>>` is not satisfied\n   --> src/src/rapidlz_compress_c.rs:56:29\n    |\n56  |     return g_rapidlzVersion.cast();\n    |                             ^^^^ the trait `integer::Integer` is not implemented for `types::global::Global<memory::ptr::Ptr<u8>>`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<u8>` to implement `cast_trait::CastFrom<types::global::Global<memory::ptr::Ptr<u8>>>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::global::Global<memory::ptr::Ptr<u8>>` to implement `CastInto<memory::ptr::Ptr<u8>>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nerror[E0277]: the trait bound `memory::ptr::Ptr<u8>: integer::Integer` is not satisfied\n   --> src/src/rapidlz_compress_c.rs:56:29\n    |\n56  |     return g_rapidlzVersion.cast();\n    |                             ^^^^ the trait `integer::Integer` is not implemented for `memory::ptr::Ptr<u8>`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<u8>` to implement `cast_trait::CastFrom<types::global::Global<memory::ptr::Ptr<u8>>>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |                       -------  ^^^^^^^^^^^^     ^^\n    |                       |\n    |                       unsatisfied trait bound introduced here\nnote: required for `types::global::Global<memory::ptr::Ptr<u8>>` to implement `CastInto<memory::ptr::Ptr<u8>>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "size_t RapidlzCompressBound(size_t srcSize)\n    {\n\n        return RAPIDLZ_COMPRESSBOUND(srcSize);\n    }",
            "rust_code": "pub fn RapidlzCompressBound(mut srcSize: usize) -> usize {\n    return RAPIDLZ_COMPRESSBOUND!(srcSize);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605399779)\nerror[E0423]: expected value, found macro `RAPIDLZ_MAX_INPUT_SIZE`\n  --> src/src/rapidlz_compress_c.rs:49:29\n   |\n49 |         if ($size as u32) > RAPIDLZ_MAX_INPUT_SIZE { 0 } else { $size + ($size / 255) + 16 } \n   |                             ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n61 |     return RAPIDLZ_COMPRESSBOUND!(srcSize);\n   |            ------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `RAPIDLZ_COMPRESSBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t RapidlzGetPosOnTable(uint32_t hashValue, uint8_t *hashTable, uint8_t hashType)\n    {\n        if (hashType == 4)\n        {\n            return (uint32_t)(*(((uint16_t *)hashTable) + hashValue));\n        }\n        else if (hashType == 5)\n        {\n            return (*(((uint32_t *)hashTable) + hashValue));\n        }\n\n        return 0;\n    }",
            "rust_code": "pub fn RapidlzGetPosOnTable(mut hashValue: u32, mut hashTable: Ptr<u8>, mut hashType: u8) -> u32 {\n    if (hashType == 4) {\n        return (*((hashTable.cast::<Ptr<u16>>() + hashValue));\n    } else if (hashType == 5) {\n        return (*((hashTable.cast::<Ptr<u32>>() + hashValue));\n    }\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605401295)\nerror: mismatched closing delimiter: `}`\n  --> src/src/rapidlz_compress_c.rs:76:16\n   |\n75 |     if (hashType == 4).as_bool() {\n   |                                  - closing delimiter possibly meant for this\n76 |         return (*((hashTable.cast::<Ptr<u16>>() + hashValue)).cast();\n   |                ^ unclosed delimiter\n77 |     } else if (hashType == 5).as_bool() {\n   |     ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n  --> src/src/rapidlz_compress_c.rs:78:16\n   |\n77 |     } else if (hashType == 5).as_bool() {\n   |                                         - closing delimiter possibly meant for this\n78 |         return (*((hashTable.cast::<Ptr<u32>>() + hashValue)).cast();\n   |                ^ unclosed delimiter\n79 |     }\n   |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t RapidlzCalcHashValue(const uint8_t *srcCurr, uint8_t hashType, uint8_t hashBits)\n    {\n        if (hashType == 5)\n        {\n            return (uint32_t)((((RAPIDLZ_READ64BIT(srcCurr)) << 24) * 11400714819323198485ULL) >> (64 - hashBits));\n        }\n        else\n        {\n            return (RAPIDLZ_READ32BIT(srcCurr) * 2654435769U) >> (32 - hashBits);\n        }\n    }",
            "rust_code": "pub fn RapidlzCalcHashValue(mut srcCurr: Ptr<u8>, mut hashType: u8, mut hashBits: u8) -> u32 {\n    if (hashType == 5) {\n        return (((RAPIDLZ_READ64BIT!(srcCurr) << 24) * 11400714819323198485u64) >> (64 - hashBits).cast::<u32>();\n    } else {\n        return (RAPIDLZ_READ32BIT!(srcCurr) * 2654435769u32) >> (32 - hashBits).cast::<u32>();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605402069)\nerror: mismatched closing delimiter: `}`\n  --> src/src/rapidlz_compress_c.rs:81:16\n   |\n80 |     if (hashType == 5).as_bool() {\n   |                                  - closing delimiter possibly meant for this\n81 |         return (((RAPIDLZ_READ64BIT!(srcCurr) << 24) * 11400714819323198485u64) >> (64 - hashBits).cast::<u32>();\n   |                ^ unclosed delimiter\n82 |     } else {\n   |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint8_t *RapidlzStoreLastLiterals(uint8_t *dst, uint8_t *dstEnd, const uint8_t *srcCurr,\n                                                    uint32_t litLength, uint8_t bufferLimit)\n    {\n        uint8_t *dstCurr = dst;\n\n        if (bufferLimit != 0)\n        {\n            const uint32_t litTokSize = 1 + litLength + (litLength / RAPIDLZ_MAX_BYTE_VALUE);\n            if (dstCurr + litTokSize > dstEnd)\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu litTokSize:%u\\n\", dstEnd - dstCurr,\n                            litTokSize);\n                return NULL;\n            }\n        }\n\n        uint8_t token = (uint8_t)(((litLength < RAPIDLZ_MAX_4BIT_VALUE) ? (litLength) : (RAPIDLZ_MAX_4BIT_VALUE)) << 4);\n        *dstCurr = token;\n        dstCurr++;\n\n        if (litLength >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            dstCurr = RapidlzCompressStoreOptionalLength(dstCurr, litLength - RAPIDLZ_MAX_4BIT_VALUE);\n        }\n\n        if (memcpy_s(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_SECUREC_ERROR, \"dstEnd - dstCurr:%zu litLength%u\\n\", dstEnd - dstCurr, litLength);\n            return NULL;\n        }\n\n        return dstCurr + litLength;\n    }",
            "rust_code": "pub fn RapidlzStoreLastLiterals(mut dst: Ptr<u8>, mut dstEnd: Ptr<u8>, mut srcCurr: Ptr<u8>, mut litLength: u32, mut bufferLimit: u8) -> Ptr<u8> {\n    let mut dstCurr: Ptr<u8> = dst;\n\n    if (bufferLimit != 0) {\n        let mut litTokSize: u32 = 1 + litLength + (litLength / RAPIDLZ_MAX_BYTE_VALUE!());\n        if (dstCurr + litTokSize > dstEnd) {\n            RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} litTokSize:{}\\n\"), dstEnd - dstCurr, litTokSize);\n            return NULL!();\n        }\n    }\n\n    let mut token: u8 = if litLength < RAPIDLZ_MAX_4BIT_VALUE!() { litLength.cast() } else { RAPIDLZ_MAX_4BIT_VALUE!() } << 4;\n    *dstCurr = token;\n    dstCurr += 1;\n\n    if (litLength >= RAPIDLZ_MAX_4BIT_VALUE!()) {\n        dstCurr = RapidlzCompressStoreOptionalLength(dstCurr, (litLength - RAPIDLZ_MAX_4BIT_VALUE!()));\n    }\n\n    if c_memcpy_s!(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK!() {\n        RAPIDLZ_LOG!(RAPIDLZ_SECUREC_ERROR!(), cstr!(\"dstEnd - dstCurr:{} litLength{}\\n\"), dstEnd - dstCurr, litLength);\n        return NULL!();\n    }\n\n    return (dstCurr + litLength);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605402825)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:112:13\n    |\n112 |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} litTokSize:{}\\n\"), dstEnd - dstCurr, litTokSize);\n    |             ------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:112:13\n    |\n112 |             RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} litTokSize:{}\\n\"), dstEnd - dstCurr, litTokSize);\n    |             ------------------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:126:9\n    |\n126 |         RAPIDLZ_LOG!(RAPIDLZ_SECUREC_ERROR!(), cstr!(\"dstEnd - dstCurr:{} litLength{}\\n\"), dstEnd - dstCurr, litLength);\n    |         --------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:126:9\n    |\n126 |         RAPIDLZ_LOG!(RAPIDLZ_SECUREC_ERROR!(), cstr!(\"dstEnd - dstCurr:{} litLength{}\\n\"), dstEnd - dstCurr, litLength);\n    |         --------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "static size_t RapidlzCompressProcess(void *dst, size_t dstSize, const void *src, size_t srcSize, RapidlzCCtx *cCtx)\n    {\n        uint32_t hashValue, matchLength, literalLength;\n        uint32_t step = 1;\n        uint16_t offset;\n        uint8_t *hashTable = cCtx->hashTable;\n        const uint8_t *srcBegin = (const uint8_t *)src;\n        const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n        const uint8_t *srcCurr = srcBegin + 1;\n        const uint8_t *srcCurrMatchEnd;\n        const uint8_t *srcAnchor = srcBegin;\n        const uint8_t *matchBegin;\n        const uint8_t *matchLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        const uint8_t *srcLimit = srcEnd - RAPIDLZ_MIN_COMPRESS_SIZE;\n        uint8_t *dstBegin = (uint8_t *)dst;\n        uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n        uint8_t *dstCurr = dstBegin;\n        uint8_t hashType = cCtx->hashType;\n        uint8_t hashBits = cCtx->hashBits;\n        uint32_t searchMatchNb = cCtx->step << RAPIDLZ_STEP_FORWARD_BASE;\n        uint32_t searchMatchNbTmp = searchMatchNb;\n        uint8_t bufferLimit = cCtx->bufferLimit;\n\n        while (RAPIDLZ_LIKELY(srcCurr <= srcLimit))\n        {\n            for (;;)\n            {\n                hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n                matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n                RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n                if ((RAPIDLZ_READ32BIT(srcCurr) == RAPIDLZ_READ32BIT(matchBegin)) &&\n                    RAPIDLZ_LIKELY((srcCurr - matchBegin) <= RAPIDLZ_MAX_OFFSET))\n                {\n                    break;\n                }\n\n                srcCurr += step;\n                step = (searchMatchNbTmp++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (srcCurr > srcLimit)\n                {\n                    dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n                    if (dstCurr == NULL)\n                    {\n                        return 0;\n                    }\n                    return dstCurr - dstBegin;\n                }\n            }\n            step = 1;\n            searchMatchNbTmp = searchMatchNb;\n\n            srcCurrMatchEnd =\n                RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n            RAPIDLZ_EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor);\n            matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n            offset = (uint16_t)(srcCurr - matchBegin);\n            literalLength = srcCurr - srcAnchor;\n            if (bufferLimit != 0)\n            {\n                uint32_t writeSize = literalLength + 8 + (literalLength + matchLength / RAPIDLZ_MAX_BYTE_VALUE);\n                if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                                writeSize);\n                    return 0;\n                }\n            }\n            dstCurr = RapidlzStoreSequence(dstCurr, srcAnchor, literalLength, matchLength, offset);\n            srcCurr = srcCurrMatchEnd;\n            srcAnchor = srcCurr;\n            hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n            RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n\n            if (RAPIDLZ_UNLIKELY(srcCurr > srcLimit))\n            {\n                break;\n            }\n\n            hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n            matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n            RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n            if ((RAPIDLZ_READ32BIT(srcCurr) != RAPIDLZ_READ32BIT(matchBegin)) ||\n                RAPIDLZ_UNLIKELY((srcCurr - matchBegin) > RAPIDLZ_MAX_OFFSET))\n            {\n                srcCurr++;\n                continue;\n            }\n\n            srcCurrMatchEnd =\n                RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n            matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n            offset = (uint16_t)(srcCurr - matchBegin);\n            if (bufferLimit != 0)\n            {\n                const uint32_t writeSize = 8 + matchLength / RAPIDLZ_MAX_BYTE_VALUE;\n                if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                                writeSize);\n                    return 0;\n                }\n            }\n            *dstCurr = 0;\n            dstCurr = RapidlzStoreOffMatch(dstCurr + 1, dstCurr, matchLength, offset);\n\n            srcCurr = srcCurrMatchEnd;\n            srcAnchor = srcCurr;\n\n            hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n            RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n        }\n\n        if (srcAnchor < srcEnd)\n        {\n            dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n            if (dstCurr == NULL)\n            {\n                return 0;\n            }\n        }\n\n        return dstCurr - dstBegin;\n    }",
            "rust_code": "pub fn RapidlzCompressProcess(mut dst: Ptr<Void>, mut dstSize: usize, mut src: Ptr<Void>, mut srcSize: usize, mut cCtx: Ptr<RapidlzCCtx>) -> usize {\n    let mut hashValue: u32;\n    let mut matchLength: u32;\n    let mut literalLength: u32;\n    let mut step: u32 = 1;\n    let mut offset: u16;\n    let mut hashTable: Ptr<u8> = cCtx.hashTable;\n    let mut srcBegin: Ptr<u8> = src.cast::<Ptr<u8>>();\n    let mut srcEnd: Ptr<u8> = src.cast::<Ptr<u8>>() + srcSize;\n    let mut srcCurr: Ptr<u8> = srcBegin + 1;\n    let mut srcCurrMatchEnd: Ptr<u8>;\n    let mut srcAnchor: Ptr<u8> = srcBegin;\n    let mut matchBegin: Ptr<u8>;\n    let mut matchLimit: Ptr<u8> = srcEnd - RAPIDLZ_LAST_LITERALS!();\n    let mut srcLimit: Ptr<u8> = srcEnd - RAPIDLZ_MIN_COMPRESS_SIZE!();\n    let mut dstBegin: Ptr<u8> = dst.cast::<Ptr<u8>>();\n    let mut dstEnd: Ptr<u8> = dst.cast::<Ptr<u8>>() + dstSize;\n    let mut dstCurr: Ptr<u8> = dstBegin;\n    let mut hashType: u8 = cCtx.hashType;\n    let mut hashBits: u8 = cCtx.hashBits;\n    let mut searchMatchNb: u32 = (cCtx.step << RAPIDLZ_STEP_FORWARD_BASE!()).cast();\n    let mut searchMatchNbTmp: u32 = searchMatchNb;\n    let mut bufferLimit: u8 = cCtx.bufferLimit;\n\n    while RAPIDLZ_LIKELY!(srcCurr <= srcLimit) {\n        loop {\n            hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n            matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n            RapidlzPutPosOnTable((srcCurr - srcBegin).cast(), hashValue, hashTable, hashType);\n\n            if (RAPIDLZ_READ32BIT!(srcCurr) == RAPIDLZ_READ32BIT!(matchBegin)) &&\n                RAPIDLZ_LIKELY!((srcCurr - matchBegin) <= RAPIDLZ_MAX_OFFSET!()) {\n                break;\n            }\n\n            srcCurr += step;\n            step = (searchMatchNbTmp >> RAPIDLZ_STEP_FORWARD_BASE!());\n\n            if (srcCurr > srcLimit) {\n                dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, (srcEnd - srcAnchor).cast(), bufferLimit);\n                if (dstCurr == NULL!()) {\n                    return 0;\n                }\n                return (dstCurr - dstBegin);\n            }\n        }\n        step = 1;\n        searchMatchNbTmp = searchMatchNb;\n\n        srcCurrMatchEnd = RapidlzCompressExpandBackward(matchLimit, (matchBegin + RAPIDLZ_MIN_MATCH!()), (srcCurr + RAPIDLZ_MIN_MATCH!()));\n        RAPIDLZ_EXPAND_FORWARD!(srcBegin, matchBegin, srcCurr, srcAnchor);\n        matchLength = (srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH!()).cast();\n        offset = (srcCurr - matchBegin).cast::<u16>();\n        literalLength = (srcCurr - srcAnchor).cast();\n        if (bufferLimit != 0) {\n            let mut writeSize: u32 = literalLength + 8 + (literalLength + matchLength / RAPIDLZ_MAX_BYTE_VALUE!());\n            if RAPIDLZ_UNLIKELY!(dstCurr + writeSize > dstEnd) {\n                RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} writeSize:{}\\n\"), (dstEnd - dstCurr), writeSize);\n                return 0;\n            }\n        }\n        dstCurr = RapidlzStoreSequence(dstCurr, srcAnchor, literalLength, matchLength, offset);\n        srcCurr = srcCurrMatchEnd;\n        srcAnchor = srcCurr;\n        hashValue = RapidlzCalcHashValue((srcCurr - 2), hashType, hashBits);\n        RapidlzPutPosOnTable((srcCurr - 2 - srcBegin).cast(), hashValue, hashTable, hashType);\n\n        if RAPIDLZ_UNLIKELY!(srcCurr > srcLimit) {\n            break;\n        }\n\n        hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n        matchBegin = (srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType));\n        RapidlzPutPosOnTable((srcCurr - srcBegin).cast(), hashValue, hashTable, hashType);\n\n        if (RAPIDLZ_READ32BIT!(srcCurr) != RAPIDLZ_READ32BIT!(matchBegin)) ||\n            RAPIDLZ_UNLIKELY!((srcCurr - matchBegin) > RAPIDLZ_MAX_OFFSET!()) {\n            srcCurr += 1;\n            continue;\n        }\n\n        srcCurrMatchEnd = RapidlzCompressExpandBackward(matchLimit, (matchBegin + RAPIDLZ_MIN_MATCH!()), (srcCurr + RAPIDLZ_MIN_MATCH!()));\n        matchLength = (srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH!()).cast();\n        offset = (srcCurr - matchBegin).cast::<u16>();\n        if (bufferLimit != 0) {\n            let mut writeSize: u32 = 8 + matchLength / RAPIDLZ_MAX_BYTE_VALUE!();\n            if RAPIDLZ_UNLIKELY!(dstCurr + writeSize > dstEnd) {\n                RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} writeSize:{}\\n\"), (dstEnd - dstCurr), writeSize);\n                return 0;\n            }\n        }\n        *dstCurr = 0;\n        dstCurr = RapidlzStoreOffMatch((dstCurr + 1), dstCurr, matchLength, offset);\n\n        srcCurr = srcCurrMatchEnd;\n        srcAnchor = srcCurr;\n\n        hashValue = RapidlzCalcHashValue((srcCurr - 2), hashType, hashBits);\n        RapidlzPutPosOnTable((srcCurr - 2 - srcBegin).cast(), hashValue, hashTable, hashType);\n    }\n\n    if (srcAnchor < srcEnd) {\n        dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, (srcEnd - srcAnchor).cast(), bufferLimit);\n        if (dstCurr == NULL!()) {\n            return 0;\n        }\n    }\n\n    return (dstCurr - dstBegin);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605407682)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:222:17\n    |\n222 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} writeSize:{}\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:222:17\n    |\n222 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} writeSize:{}\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:252:17\n    |\n252 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} writeSize:{}\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:252:17\n    |\n252 |                 RAPIDLZ_LOG!(RAPIDLZ_DST_SIZE_SMALL!(), cstr!(\"dstEnd - dstCur:{} writeSize:{}\\n\"), (dstEnd - dstCurr).cast(), writeSize);\n    |                 ------------------------------------------------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "size_t RapidlzCompress(const void *src, void *dst, size_t srcSize, size_t dstSize, int acceleration)\n    {\n        if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n            return 0;\n        }\n\n        if (acceleration < 1 || acceleration > RAPIDLZ_ACCELERATION_MAX)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"acceleration:%d\\n\", acceleration);\n            return 0;\n        }\n\n        RapidlzCCtx *cCtx = (RapidlzCCtx *)malloc(sizeof(RapidlzCCtx));\n        if (cCtx == NULL)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"cCtx malloc failed\\n\");\n            return 0;\n        }\n\n        cCtx->hashBits = RAPIDLZ_MIN_HASH_BIT;\n        size_t totalHashSize;\n        if (srcSize <= RAPIDLZ_SRC_SIZE_THRESHOLD)\n        {\n            cCtx->hashType = RAPIDLZ_HASH_TYPE_4;\n            if (srcSize >= 64)\n            {\n                cCtx->hashBits = (RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT) ? (RAPIDLZ_MAX_HASH_BIT + 1)\n                                                                                    : RapidlzHighBit64(srcSize);\n            }\n            totalHashSize = sizeof(uint16_t) * (uint32_t)(1 << cCtx->hashBits);\n        }\n        else\n        {\n            cCtx->hashType = RAPIDLZ_HASH_TYPE_5;\n            cCtx->hashBits = RAPIDLZ_MAX_HASH_BIT;\n            totalHashSize = sizeof(uint32_t) * (uint32_t)(1 << cCtx->hashBits);\n        }\n\n        uint8_t *table = (uint8_t *)malloc(totalHashSize);\n        if (table == NULL)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"hash table malloc failed\\n\");\n            free(cCtx);\n            return 0;\n        }\n        (void)memset_s(table, totalHashSize, 0, totalHashSize);\n        cCtx->hashTable = table;\n        cCtx->step = (uint8_t)acceleration;\n        cCtx->bufferLimit = dstSize < RapidlzCompressBound(srcSize);\n\n        size_t cSize = RapidlzCompressProcess(dst, dstSize, src, srcSize, cCtx);\n        RapidlzCCtxFree(cCtx);\n        return cSize;\n    }",
            "rust_code": "pub fn RapidlzCompress(mut src: Ptr<Void>, mut dst: Ptr<Void>, mut srcSize: usize, mut dstSize: usize, mut acceleration: i32) -> usize {\n    if (src == NULL!()) || (dst == NULL!()) || (srcSize == 0) || (dstSize == 0) {\n        RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n        return 0;\n    }\n\n    if (acceleration < 1) || (acceleration > RAPIDLZ_ACCELERATION_MAX!()) {\n        RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"acceleration:{}\\n\"), acceleration);\n        return 0;\n    }\n\n    let mut cCtx: Ptr<RapidlzCCtx> = c_malloc!(c_sizeof!(RapidlzCCtx));\n    if (cCtx == NULL!()) {\n        RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"cCtx malloc failed\\n\"));\n        return 0;\n    }\n\n    cCtx.hashBits = RAPIDLZ_MIN_HASH_BIT!();\n    let mut totalHashSize: usize;\n    if (srcSize <= RAPIDLZ_SRC_SIZE_THRESHOLD!()) {\n        cCtx.hashType = RAPIDLZ_HASH_TYPE_4!();\n        if (srcSize >= 64) {\n            cCtx.hashBits = if RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize) };\n        }\n        totalHashSize = (c_sizeof!(u16) * (1 << cCtx.hashBits).cast::<u32>()).cast();\n    } else {\n        cCtx.hashType = RAPIDLZ_HASH_TYPE_5!();\n        cCtx.hashBits = RAPIDLZ_MAX_HASH_BIT!();\n        totalHashSize = (c_sizeof!(u32) * (1 << cCtx.hashBits).cast::<u32>()).cast();\n    }\n\n    let mut table: Ptr<u8> = c_malloc!(totalHashSize);\n    if (table == NULL!()) {\n        RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"hash table malloc failed\\n\"));\n        c_free!(cCtx);\n        return 0;\n    }\n    c_memset_s!(table, totalHashSize, 0, totalHashSize).cast::<Void>();\n    cCtx.hashTable = table;\n    cCtx.step = acceleration.cast::<u8>();\n    cCtx.bufferLimit = (dstSize < RapidlzCompressBound(srcSize));\n\n    let mut cSize: usize = RapidlzCompressProcess(dst, dstSize, src, srcSize, cCtx);\n    RapidlzCCtxFree(cCtx);\n    return cSize;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/rapidlz_1744605514761)\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:183:9\n    |\n183 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:183:9\n    |\n183 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"input invalid\\n\"));\n    |         ---------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:188:9\n    |\n188 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"acceleration:{}\\n\"), acceleration);\n    |         -------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:188:9\n    |\n188 |         RAPIDLZ_LOG!(RAPIDLZ_INPUT_INVALID!(), cstr!(\"acceleration:{}\\n\"), acceleration);\n    |         -------------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:194:9\n    |\n194 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"cCtx malloc failed\\n\"));\n    |         --------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:194:9\n    |\n194 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"cCtx malloc failed\\n\"));\n    |         --------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:12:13\n    |\n12  |             strrchr!(__FILE__!(), b'/') + 1\n    |             ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:214:9\n    |\n214 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"hash table malloc failed\\n\"));\n    |         --------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: cannot find macro `strrchr` in this scope\n    |\n   ::: src/translation_utils/c_alignment/libraries/c_string.rs:229:1\n    |\n229 | macro_rules! c_strrchr {\n    | ---------------------- similarly named macro `c_strrchr` defined here\n   --> src/src/rapidlz_log_h.rs:11:12\n    |\n11  |         if strrchr!(__FILE__!(), b'/').as_bool() {\n    |            ^^^^^^^ help: a macro with a similar name exists: `c_strrchr`\n    |\n   ::: src/src/rapidlz_compress_c.rs:214:9\n    |\n214 |         RAPIDLZ_LOG!(RAPIDLZ_MALLOC_FAILED!(), cstr!(\"hash table malloc failed\\n\"));\n    |         --------------------------------------------------------------------------- in this macro invocation\n    |\nnote: `strrchr` is imported here, but it is a function, not a macro\n   --> src/src/rapidlz_compress_c.rs:1:5\n    |\n1   | use crate::translation_utils::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `RAPIDLZFILENAME` which comes from the expansion of the macro `RAPIDLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:203:49\n    |\n203 | ...   cCtx.hashBits = if RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcS...\n    |                          ---------------- ^^^^^^^ expected `u64`, found `usize`\n    |                          |\n    |                          arguments to this function are incorrect\n    |\nnote: function defined here\n   --> src/src/rapidlz_inner_h.rs:211:8\n    |\n211 | pub fn RapidlzHighBit64(mut x: u64) -> u8 {\n    |        ^^^^^^^^^^^^^^^^ ----------\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n    |\n203 |             cCtx.hashBits = if RapidlzHighBit64(srcSize.try_into().unwrap()) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize) };\n    |                                                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:203:140\n    |\n203 | ... RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize) };\n    |                                          ---------------- ^^^^^^^ expected `u64`, found `usize`\n    |                                          |\n    |                                          arguments to this function are incorrect\n    |\nnote: function defined here\n   --> src/src/rapidlz_inner_h.rs:211:8\n    |\n211 | pub fn RapidlzHighBit64(mut x: u64) -> u8 {\n    |        ^^^^^^^^^^^^^^^^ ----------\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n    |\n203 |             cCtx.hashBits = if RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT!() { RAPIDLZ_MAX_HASH_BIT!() + 1 } else { RapidlzHighBit64(srcSize.try_into().unwrap()) };\n    |                                                                                                                                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/rapidlz_compress_c.rs:221:24\n    |\n221 |     cCtx.bufferLimit = (dstSize < RapidlzCompressBound(srcSize)).as_bool();\n    |     ----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `bool`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 11 previous errors\n"
        }
    ]
}