{"All": 92, "Compilation Pass": 65, "Compilation Error": 27, "Pass Rate": 0.7065217391304348, "Error Information": [{"c_code": "void BzpHeapInit(BzpHuffmanInfo *huffman)\n    {\n        int32_t i = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = i;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }", "rust_code": "pub fn BzpHeapInit(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = i.cast();\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n    });\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104089670)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:62:22\n   |\n62 |         huffman.heap[huffman.nHeap] = i.cast();\n   |         -------     -^^^^^^^-------\n   |         |           ||\n   |         |           |immutable borrow occurs here\n   |         |           mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:62:22\n   |\n62 |         huffman.heap[huffman.nHeap] = i.cast();\n   |                      ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:62:21\n   |\n62 |         huffman.heap[huffman.nHeap] = i.cast();\n   |                     ^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }", "rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman.cast());\n    BzpHeapInit(huffman.cast());\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1).as_bool() {\n        idx1 = huffman.heap[1].cast();\n        huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n        idx2 = huffman.heap[1].cast();\n        huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n        huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n        huffman.parent[idx1] = huffman.nWeight.cast();\n        huffman.parent[idx2] = huffman.nWeight.cast();\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap.prefix_plus_plus();\n        huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n        huffman.nWeight.prefix_plus_plus();\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n    }\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104090016)\nerror[E0499]: cannot borrow `huffman` as mutable more than once at a time\n  --> src/src/compress/bzp_huffman_encode_c.rs:75:40\n   |\n75 |         huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n   |                           -------     -^^^^^^^----------------------------\n   |                           |           ||\n   |                           |           |second mutable borrow occurs here\n   |                           |           first borrow later used here\n   |                           first mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:75:40\n   |\n75 |         huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:75:39\n   |\n75 |         huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0499]: cannot borrow `huffman` as mutable more than once at a time\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:40\n   |\n78 |         huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n   |                           -------     -^^^^^^^----------------------------\n   |                           |           ||\n   |                           |           |second mutable borrow occurs here\n   |                           |           first borrow later used here\n   |                           first mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:40\n   |\n78 |         huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:39\n   |\n78 |         huffman.heap[1] = huffman.heap[huffman.nHeap.suffix_minus_minus()].cast();\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:24\n   |\n80 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:24\n   |\n80 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:23\n   |\n80 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:83:24\n   |\n83 |         huffman.parent[huffman.nWeight] = -1;\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:83:24\n   |\n83 |         huffman.parent[huffman.nWeight] = -1;\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:83:23\n   |\n83 |         huffman.parent[huffman.nWeight] = -1;\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:22\n   |\n85 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |         -------     -^^^^^^^-------\n   |         |           ||\n   |         |           |immutable borrow occurs here\n   |         |           mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:22\n   |\n85 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                      ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:21\n   |\n85 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                     ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0499, E0502.\nFor more information about an error, try `rustc --explain E0499`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"}, {"c_code": "void BzpGenerateSelectMTF(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t list[nGroups];\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            list[i] = i;\n        }\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = 0;\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                if (huffman->select[i] == list[j])\n                {\n                    pos = j;\n                    break;\n                }\n            }\n            for (int32_t j = pos; j > 0; j--)\n            {\n                list[j] = list[j - 1];\n            }\n            list[0] = huffman->select[i];\n            huffman->selectMTF[i] = pos;\n        }\n    }", "rust_code": "pub fn BzpGenerateSelectMTF(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    let mut list: Array<i32, { /* nGroups */ }> = Default::default();\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        list[i] = i.cast();\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut pos: i32 = 0;\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            if (huffman.select[i] == list[j]).as_bool() {\n                pos = j.cast();\n                break;\n            }\n        });\n        c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n            list[j] = list[j - 1].cast();\n        });\n        list[0] = huffman.select[i].cast();\n        huffman.selectMTF[i] = pos.cast();\n    });\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104091487)\nerror[E0308]: mismatched types\n   --> src/src/compress/bzp_huffman_encode_c.rs:220:30\n    |\n220 |     let mut list: Array<i32, { /* nGroups */ }> = Default::default();\n    |                              ^^^^^^^^^^^^^^^^^ expected `usize`, found `()`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpInitLenArray(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t npart = nGroups;\n        int32_t AllFreqNum = huffman->nBlock;\n        int32_t st = 0, ed;\n\n        while (npart > 0)\n        {\n            int32_t NowFreqNum = 0;\n            int32_t FreqNumLimit = AllFreqNum / npart;\n\n            ed = st - 1;\n            while (ed < huffman->alphaSize - 1 && NowFreqNum < FreqNumLimit)\n            {\n                ed++;\n                NowFreqNum += huffman->mtfFreq[ed];\n            }\n\n            if (ed > st && npart != nGroups && npart != 1 && ((nGroups - npart) & 1))\n            {\n                NowFreqNum -= huffman->mtfFreq[ed];\n                ed--;\n            }\n\n            for (int32_t i = 0; i < huffman->alphaSize; i++)\n            {\n                if (i >= st && i <= ed)\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = 0;\n                }\n                else\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST;\n                }\n            }\n            npart--;\n            st = ed + 1;\n            AllFreqNum -= NowFreqNum;\n        }\n    }", "rust_code": "pub fn BzpInitLenArray(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    let mut npart: i32 = nGroups.cast();\n    let mut AllFreqNum: i32 = huffman.nBlock.cast();\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    while (npart > 0).as_bool() {\n        let mut NowFreqNum: i32 = 0;\n        let mut FreqNumLimit: i32 = AllFreqNum / npart;\n\n        ed = st - 1;\n        while (ed < huffman.alphaSize - 1).as_bool() && (NowFreqNum < FreqNumLimit).as_bool() {\n            ed += 1;\n            NowFreqNum += huffman.mtfFreq[ed].cast();\n        }\n\n        if (ed > st).as_bool() && (npart != nGroups).as_bool() && (npart != 1).as_bool() && ((nGroups - npart) & 1).as_bool() {\n            NowFreqNum -= huffman.mtfFreq[ed].cast();\n            ed -= 1;\n        }\n\n        c_for!(let mut i: i32 = 0; i < huffman.alphaSize.cast(); i.suffix_plus_plus(); {\n            if (i >= st).as_bool() && (i <= ed).as_bool() {\n                huffman.huffmanGroups[npart - 1].len[i] = 0;\n            } else {\n                huffman.huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST!();\n            }\n        });\n        npart -= 1;\n        st = ed + 1;\n        AllFreqNum -= NowFreqNum;\n    }\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104091665)\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:237:47\n    |\n237 |             NowFreqNum += huffman.mtfFreq[ed].cast();\n    |                        --                     ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                        |\n    |                        type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `i32: std::ops::AddAssign<_>` found in the `core` crate:\n            - impl std::ops::AddAssign for i32;\n            - impl std::ops::AddAssign<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n237 |             NowFreqNum += huffman.mtfFreq[ed].cast::<T>();\n    |                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed)\n    {\n        (void)memset_s(huffman->cost, sizeof(huffman->cost), 0, sizeof(huffman->cost));\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = st; k <= ed; k++)\n        {\n            for (int32_t t = 0; t < nGroups; t++)\n            {\n                huffman->cost[t] += huffman->huffmanGroups[t].len[huffman->block[k]];\n            }\n        }\n    }", "rust_code": "pub fn BzpCalculateCost(mut huffman: Ptr<BzpHuffmanGroups>, mut st: i32, mut ed: i32) {\n    c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n        c_for!(let mut t: i32 = 0; t < nGroups; t.suffix_plus_plus(); {\n            huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n        });\n    });\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104091845)\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:233:79\n    |\n233 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n    |                             -- type must be known at this point               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\n    = note: multiple `impl`s satisfying `i32: std::ops::AddAssign<_>` found in the `core` crate:\n            - impl std::ops::AddAssign for i32;\n            - impl std::ops::AddAssign<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n233 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast::<T>();\n    |                                                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }", "rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        if (huffman.cost[k] < huffman.cost[id]).as_bool() {\n            id = k.cast();\n        }\n    });\n    huffman.select[huffman.nSelect.suffix_plus_plus()] = id.cast();\n    return id.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104092022)\nerror[E0499]: cannot borrow `huffman` as mutable more than once at a time\n   --> src/src/compress/bzp_huffman_encode_c.rs:241:20\n    |\n241 |     huffman.select[huffman.nSelect.suffix_plus_plus()] = id.cast();\n    |     -------       -^^^^^^^----------------------------\n    |     |             ||\n    |     |             |second mutable borrow occurs here\n    |     |             first borrow later used here\n    |     first mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_huffman_encode_c.rs:241:20\n    |\n241 |     huffman.select[huffman.nSelect.suffix_plus_plus()] = id.cast();\n    |                    ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_huffman_encode_c.rs:241:19\n    |\n241 |     huffman.select[huffman.nSelect.suffix_plus_plus()] = id.cast();\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpHuffmanMain(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n        huffman->nGroups = nGroups;\n\n        BzpInitLenArray(huffman);\n        int32_t st = 0, ed;\n\n        for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++)\n        {\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                (void)memset_s(huffman->huffmanGroups[j].weight, sizeof(huffman->huffmanGroups[j].weight), 0,\n                               sizeof(huffman->huffmanGroups[j].weight));\n            }\n\n            st = 0;\n            huffman->nSelect = 0;\n            while (st < huffman->nBlock)\n            {\n                ed = BZP_MIN_FUN(huffman->nBlock, st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) - 1;\n\n                BzpCalculateCost(huffman, st, ed);\n\n                int32_t id = BzpSelectTree(huffman);\n\n                for (int32_t k = st; k <= ed; k++)\n                {\n                    huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n                }\n                st = ed + 1;\n            }\n\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n            }\n        }\n\n        BzpGenerateSelectMTF(huffman);\n\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n        }\n    }", "rust_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock.cast()).cast();\n    huffman.nGroups = nGroups.cast();\n\n    BzpInitLenArray(huffman.cast());\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!().cast(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0, c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock).as_bool() {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman.cast(), st.cast(), ed.cast());\n\n            let mut id: i32 = BzpSelectTree(huffman.cast()).cast();\n\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]).cast());\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman.cast());\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]).cast());\n    });\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104092200)\nerror[E0284]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:254:82\n    |\n254 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\n    = note: cannot satisfy `<i32 as std::ops::Add<_>>::Output == i32`\nhelp: consider specifying the generic argument\n    |\n254 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:254:82\n    |\n254 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\nnote: multiple `impl`s satisfying `i32: std::ops::Add<_>` found\n   --> src/translation_utils/types/num.rs:112:1\n    |\n112 | impl Add<Num> for i32 {\n    | ^^^^^^^^^^^^^^^^^^^^^\n    = note: and more `impl`s found in the following crates: `core`:\n            - impl std::ops::Add for i32;\n            - impl std::ops::Add<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n254 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"}, {"c_code": "void BzpNumEncode(BzpMtfInfo *mtf, int32_t num)\n    {\n        num <<= 1;\n\n        do\n        {\n            num >>= 1;\n            num--;\n            if (num & 1)\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE1;\n                mtf->mtfFreq[BZP_MTF_ENCODE1]++;\n            }\n            else\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE0;\n                mtf->mtfFreq[BZP_MTF_ENCODE0]++;\n            }\n        } while (num >= BZP_MTF_ENCODE_BASE);\n    }", "rust_code": "pub fn BzpNumEncode(mut mtf: Ptr<BzpMtfInfo>, mut num: i32) {\n    num <<= 1;\n\n    c_do!({\n        num >>= 1;\n        num -= 1;\n        if (num & 1).as_bool() {\n            mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE1!();\n            mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n        } else {\n            mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE0!();\n            mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n        }\n    } while num >= BZP_MTF_ENCODE_BASE!());\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104092960)\nerror[E0499]: cannot borrow `mtf` as mutable more than once at a time\n  --> src/src/compress/bzp_mtf_encode_c.rs:58:22\n   |\n58 |             mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE1!();\n   |             ---     -^^^-------------------------\n   |             |       ||\n   |             |       |second mutable borrow occurs here\n   |             |       first borrow later used here\n   |             first mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:58:22\n   |\n58 |             mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE1!();\n   |                      ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:58:21\n   |\n58 |             mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE1!();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0499]: cannot borrow `mtf` as mutable more than once at a time\n  --> src/src/compress/bzp_mtf_encode_c.rs:61:22\n   |\n61 |             mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE0!();\n   |             ---     -^^^-------------------------\n   |             |       ||\n   |             |       |second mutable borrow occurs here\n   |             |       first borrow later used here\n   |             first mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:61:22\n   |\n61 |             mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE0!();\n   |                      ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:61:21\n   |\n61 |             mtf.mtfV[mtf.nMtf.suffix_plus_plus()] = BZP_MTF_ENCODE0!();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"}, {"c_code": "void BzpMtfMain(BzpMtfInfo *mtf)\n    {\n        uint8_t list[BZP_MAX_ALPHA_SIZE];\n        int32_t EOB;\n        int32_t num = 0;\n        BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE);\n        EOB = mtf->nUse + 1;\n        for (int32_t i = 0; i <= EOB; i++)\n        {\n            mtf->mtfFreq[i] = 0;\n        }\n        for (int32_t i = 0; i < mtf->nBlock; i++)\n        {\n            int32_t pos = mtf->map[i] - 1;\n            if (pos < 0)\n            {\n                pos += mtf->nBlock;\n            }\n            uint8_t ch = mtf->block[pos];\n            if (ch == list[0])\n            {\n                num++;\n            }\n            else\n            {\n                if (num > 0)\n                {\n                    BzpNumEncode(mtf, num);\n                    num = 0;\n                }\n                int32_t pos_ = 1;\n                while (ch != list[pos_] && pos_ < mtf->nUse)\n                {\n                    pos_++;\n                }\n\n                for (int32_t j = pos_; j > 0; j--)\n                {\n                    list[j] = list[j - 1];\n                }\n                list[0] = ch;\n\n                mtf->mtfV[mtf->nMtf] = pos_ + 1;\n                mtf->mtfFreq[pos_ + 1]++;\n                mtf->nMtf++;\n            }\n        }\n        if (num > 0)\n        {\n            BzpNumEncode(mtf, num);\n        }\n\n        mtf->mtfV[mtf->nMtf] = EOB;\n        mtf->mtfFreq[EOB]++;\n        mtf->nMtf++;\n    }", "rust_code": "pub fn BzpMtfMain(mut mtf: Ptr<BzpMtfInfo>) {\n    let mut list: Array<u8, { BZP_MAX_ALPHA_SIZE!() }> = Default::default();\n    let mut EOB: i32 = Default::default();\n    let mut num: i32 = 0;\n    BzpMapInputChar(mtf.cast(), list.cast(), BZP_MAX_ALPHA_SIZE!().cast());\n    EOB = (mtf.nUse + 1).cast();\n    c_for!(let mut i: i32 = 0; i <= EOB; i.suffix_plus_plus(); {\n        mtf.mtfFreq[i] = 0;\n    });\n    c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n        let mut pos: i32 = (mtf.map[i] - 1).cast();\n        if (pos < 0).as_bool() {\n            pos += mtf.nBlock;\n        }\n        let mut ch: u8 = mtf.block[pos].cast();\n        if (ch == list[0]).as_bool() {\n            num += 1;\n        } else {\n            if (num > 0).as_bool() {\n                BzpNumEncode(mtf.cast(), num.cast());\n                num = 0;\n            }\n            let mut pos_: i32 = 1;\n            while (ch != list[pos_]).as_bool() && (pos_ < mtf.nUse).as_bool() {\n                pos_ += 1;\n            }\n            c_for!(let mut j: i32 = pos_; j > 0; j.suffix_minus_minus(); {\n                list[j] = list[j - 1].cast();\n            });\n            list[0] = ch.cast();\n            mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n            mtf.mtfFreq[pos_ + 1] += 1;\n            mtf.nMtf += 1;\n        }\n    });\n    if (num > 0).as_bool() {\n        BzpNumEncode(mtf.cast(), num.cast());\n    }\n    mtf.mtfV[mtf.nMtf] = EOB.cast();\n    mtf.mtfFreq[EOB] += 1;\n    mtf.nMtf += 1;\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104093134)\nerror[E0502]: cannot borrow `mtf` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_mtf_encode_c.rs:86:22\n   |\n86 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |             ---     -^^^------\n   |             |       ||\n   |             |       |immutable borrow occurs here\n   |             |       mutable borrow later used here\n   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:86:22\n   |\n86 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |                      ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:86:21\n   |\n86 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |                     ^^^^^^^^^^\n\nerror[E0502]: cannot borrow `mtf` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_mtf_encode_c.rs:94:14\n   |\n94 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |     ---     -^^^------\n   |     |       ||\n   |     |       |immutable borrow occurs here\n   |     |       mutable borrow later used here\n   |     mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:94:14\n   |\n94 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |              ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:94:13\n   |\n94 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |             ^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"}, {"c_code": "void BzpQSortSingle(int32_t *sortBlock, int32_t *idx, BzpQSortInfo *stack)\n    {\n        int32_t tl = stack->tl, tr = stack->tr;\n        int32_t value = BzpSelectMidVal(sortBlock, idx, tl, tr);\n        int32_t lPos = tl, rPos = tr, ePos = tl;\n\n        while (ePos <= rPos)\n        {\n            if (idx[sortBlock[ePos]] < value)\n            {\n                BzpSwap2Elem(sortBlock, ePos, lPos);\n                ePos++;\n                lPos++;\n            }\n            else if (idx[sortBlock[ePos]] == value)\n            {\n                ePos++;\n            }\n            else\n            {\n                while (rPos >= ePos && idx[sortBlock[rPos]] > value)\n                {\n                    rPos--;\n                }\n                if (rPos < ePos)\n                {\n                    break;\n                }\n                if (idx[sortBlock[rPos]] == value)\n                {\n                    BzpSwap2Elem(sortBlock, ePos, rPos);\n                }\n                else if (lPos == ePos)\n                {\n\n                    BzpSwap2Elem(sortBlock, ePos, rPos);\n                    lPos++;\n                }\n                else\n                {\n                    BzpSwap3Elem(sortBlock, lPos, ePos, rPos);\n                    lPos++;\n                }\n                ePos++;\n                rPos--;\n            }\n        }\n\n        if (lPos - tl > tr - rPos)\n        {\n            stack->stackL[stack->cnt] = tl;\n            stack->stackR[stack->cnt] = lPos - 1;\n            stack->cnt++;\n            stack->stackL[stack->cnt] = rPos + 1;\n            stack->stackR[stack->cnt] = tr;\n            stack->cnt++;\n        }\n        else\n        {\n            stack->stackL[stack->cnt] = rPos + 1;\n            stack->stackR[stack->cnt] = tr;\n            stack->cnt++;\n            stack->stackL[stack->cnt] = tl;\n            stack->stackR[stack->cnt] = lPos - 1;\n            stack->cnt++;\n        }\n    }", "rust_code": "pub fn BzpQSortSingle(mut sortBlock: Ptr<i32>, mut idx: Ptr<i32>, mut stack: Ptr<BzpQSortInfo>) {\n    let mut tl: i32 = stack.tl.cast();\n    let mut tr: i32 = stack.tr.cast();\n    let mut value: i32 = BzpSelectMidVal(sortBlock.cast(), idx.cast(), tl.cast(), tr.cast()).cast();\n    let mut lPos: i32 = tl.cast();\n    let mut rPos: i32 = tr.cast();\n    let mut ePos: i32 = tl.cast();\n\n    while (ePos <= rPos).as_bool() {\n        if (idx[sortBlock[ePos]] < value).as_bool() {\n            BzpSwap2Elem(sortBlock.cast(), ePos.cast(), lPos.cast());\n            ePos.suffix_plus_plus();\n            lPos.suffix_plus_plus();\n        } else if (idx[sortBlock[ePos]] == value).as_bool() {\n            ePos.suffix_plus_plus();\n        } else {\n            while (rPos >= ePos).as_bool() && (idx[sortBlock[rPos]] > value).as_bool() {\n                rPos.suffix_minus_minus();\n            }\n            if (rPos < ePos).as_bool() {\n                break;\n            }\n            if (idx[sortBlock[rPos]] == value).as_bool() {\n                BzpSwap2Elem(sortBlock.cast(), ePos.cast(), rPos.cast());\n            } else if (lPos == ePos).as_bool() {\n                BzpSwap2Elem(sortBlock.cast(), ePos.cast(), rPos.cast());\n                lPos.suffix_plus_plus();\n            } else {\n                BzpSwap3Elem(sortBlock.cast(), lPos.cast(), ePos.cast(), rPos.cast());\n                lPos.suffix_plus_plus();\n            }\n            ePos.suffix_plus_plus();\n            rPos.suffix_minus_minus();\n        }\n    }\n\n    if (lPos - tl > tr - rPos).as_bool() {\n        stack.stackL[stack.cnt] = tl.cast();\n        stack.stackR[stack.cnt] = (lPos - 1).cast();\n        stack.cnt.suffix_plus_plus();\n        stack.stackL[stack.cnt] = (rPos + 1).cast();\n        stack.stackR[stack.cnt] = tr.cast();\n        stack.cnt.suffix_plus_plus();\n    } else {\n        stack.stackL[stack.cnt] = (rPos + 1).cast();\n        stack.stackR[stack.cnt] = tr.cast();\n        stack.cnt.suffix_plus_plus();\n        stack.stackL[stack.cnt] = tl.cast();\n        stack.stackR[stack.cnt] = (lPos - 1).cast();\n        stack.cnt.suffix_plus_plus();\n    }\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104094465)\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:130:22\n    |\n130 |         stack.stackL[stack.cnt] = tl.cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:130:22\n    |\n130 |         stack.stackL[stack.cnt] = tl.cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:130:21\n    |\n130 |         stack.stackL[stack.cnt] = tl.cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:131:22\n    |\n131 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:131:22\n    |\n131 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:131:21\n    |\n131 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:133:22\n    |\n133 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:133:22\n    |\n133 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:133:21\n    |\n133 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:134:22\n    |\n134 |         stack.stackR[stack.cnt] = tr.cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:134:22\n    |\n134 |         stack.stackR[stack.cnt] = tr.cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:134:21\n    |\n134 |         stack.stackR[stack.cnt] = tr.cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:137:22\n    |\n137 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:137:22\n    |\n137 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:137:21\n    |\n137 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:138:22\n    |\n138 |         stack.stackR[stack.cnt] = tr.cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:138:22\n    |\n138 |         stack.stackR[stack.cnt] = tr.cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:138:21\n    |\n138 |         stack.stackR[stack.cnt] = tr.cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:140:22\n    |\n140 |         stack.stackL[stack.cnt] = tl.cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:140:22\n    |\n140 |         stack.stackL[stack.cnt] = tl.cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:140:21\n    |\n140 |         stack.stackL[stack.cnt] = tl.cast();\n    |                     ^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `stack` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_bwt_encode_c.rs:141:22\n    |\n141 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |         -----       -^^^^^-----\n    |         |           ||\n    |         |           |immutable borrow occurs here\n    |         |           mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_bwt_encode_c.rs:141:22\n    |\n141 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |                      ^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_bwt_encode_c.rs:141:21\n    |\n141 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |                     ^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"}, {"c_code": "uint32_t BzpReadBits(int32_t nBit, InDeComdata *inData)\n    {\n        uint32_t res = 0;\n\n        while (inData->nBuf < nBit)\n        {\n            if (inData->input->nBuf == inData->input->pos)\n            {\n                inData->input->nBuf =\n                    fread(inData->input->buf, sizeof(char), sizeof(inData->input->buf), inData->input->filePtr);\n                inData->input->pos = 0;\n            }\n            int32_t data = ((uint32_t)(inData->input->buf[inData->input->pos]));\n\n            inData->buf = (inData->buf << BZP_BITS8) | data;\n            inData->input->pos++;\n            inData->nBuf += BZP_BITS8;\n        }\n        res = inData->buf >> (inData->nBuf - nBit);\n        res = res & ((1 << nBit) - 1);\n        inData->nBuf -= nBit;\n        return res;\n    }", "rust_code": "pub fn BzpReadBits(mut nBit: i32, mut inData: Ptr<InDeComdata>) -> u32 {\n    let mut res: u32 = 0;\n\n    while (inData.nBuf < nBit).as_bool() {\n        if (inData.input.nBuf == inData.input.pos).as_bool() {\n            inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n            inData.input.pos = 0;\n        }\n        let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>().cast();\n\n        inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n        inData.input.pos += 1;\n        inData.nBuf += BZP_BITS8!();\n    }\n    res = (inData.buf >> (inData.nBuf - nBit)).cast();\n    res = (res & ((1 << nBit) - 1)).cast();\n    inData.nBuf -= nBit;\n    return res.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104096026)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/memory/file_ptr.rs:368:9\n    |\n368 |         fread($ptr.cast(), $size.cast(), $count.cast(), &mut $file).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:35:33\n    |\n35  |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n    |                                 ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `c_fread` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BzpWriteChar(uint8_t ch, InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        if (inData->output->nBuf >= BZP_BUF_SIZE)\n        {\n            int32_t n2 =\n                fwrite((void *)(inData->output->buf), sizeof(uint8_t), inData->output->nBuf, inData->output->filePtr);\n            if (n2 != inData->output->nBuf)\n            {\n                ret = BZP_ERROR_IO;\n            }\n            inData->output->nBuf = 0;\n        }\n        inData->output->buf[inData->output->nBuf++] = ch;\n        return ret;\n    }", "rust_code": "pub fn BzpWriteChar(mut ch: u8, mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    if (inData.output.nBuf >= BZP_BUF_SIZE!()).as_bool() {\n        let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n        if (n2 != inData.output.nBuf).as_bool() {\n            ret = BZP_ERROR_IO!();\n        }\n        inData.output.nBuf = 0;\n    }\n    inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n    return ret.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104096219)\nerror[E0499]: cannot borrow `inData` as mutable more than once at a time\n  --> src/src/public/bzp_decompress_stream_c.rs:44:23\n   |\n44 |     inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n   |     ------           -^^^^^^--------------------------------\n   |     |                ||\n   |     |                |second mutable borrow occurs here\n   |     |                first borrow later used here\n   |     first mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/public/bzp_decompress_stream_c.rs:44:23\n   |\n44 |     inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n   |                       ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/public/bzp_decompress_stream_c.rs:44:22\n   |\n44 |     inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BzpHuffmanDecodeStep(BzpHuffmanDecode *huffman, InDeComdata *inData)\n    {\n\n        if (huffman->deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP)\n        {\n            huffman->deCodeNum = 0;\n            huffman->selectCnt++;\n        }\n        int32_t gid = huffman->select[huffman->selectCnt];\n\n        int32_t chlen = huffman->minLens[gid];\n        int32_t val = BzpReadBits(chlen, inData);\n\n        while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT && val > huffman->limit[gid][chlen])\n        {\n            chlen++;\n            int32_t nxtbit = BzpReadBits(1, inData);\n            val = (val << 1) | nxtbit;\n        }\n        if (chlen > BZP_HUFFMAN_LEN_UPPER_LIMIT)\n        {\n            return -1;\n        }\n\n        val = val - huffman->base[gid][chlen];\n        val = huffman->perm[gid][val];\n        huffman->deCodeNum++;\n        return val;\n    }", "rust_code": "pub fn BzpHuffmanDecodeStep(mut huffman: Ptr<BzpHuffmanDecode>, mut inData: Ptr<InDeComdata>) -> i32 {\n    if (huffman.deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP!()).as_bool() {\n        huffman.deCodeNum = 0;\n        huffman.selectCnt += 1;\n    }\n    let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n    let mut chlen: i32 = huffman.minLens[gid].cast();\n    let mut val: i32 = BzpReadBits(chlen.cast(), inData.cast()).cast();\n    while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT!()).as_bool() && (val > huffman.limit[gid][chlen]).as_bool() {\n        chlen += 1;\n        let mut nxtbit: i32 = BzpReadBits(1, inData.cast()).cast();\n        val = (val << 1) | nxtbit;\n    }\n    if (chlen > BZP_HUFFMAN_LEN_UPPER_LIMIT!()).as_bool() {\n        return -1;\n    }\n    val = (val - huffman.base[gid][chlen]).cast();\n    val = huffman.perm[gid][val].cast();\n    huffman.deCodeNum += 1;\n    return val.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104096399)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/public/bzp_decompress_stream_c.rs:45:39\n   |\n45 |     let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n   |                        -------       -^^^^^^^-----------\n   |                        |             ||\n   |                        |             |immutable borrow occurs here\n   |                        |             mutable borrow later used here\n   |                        mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/public/bzp_decompress_stream_c.rs:45:39\n   |\n45 |     let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n   |                                       ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/public/bzp_decompress_stream_c.rs:45:38\n   |\n45 |     let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n   |                                      ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n        debwt->nBlock = 0;\n        uint8_t ch;\n        int32_t ninUse = huffman->alphaSize - BZP_EXTRA_CHARS_NUM;\n        int32_t eob = ninUse + 1;\n        int32_t val = BzpHuffmanDecodeStep(huffman, inData);\n        while (val != eob && val != -1)\n        {\n            if (val == 0 || val == 1)\n            {\n                int32_t res = 0, basenum = 1;\n                while (val == 0 || val == 1)\n                {\n                    res = res + (val + 1) * basenum;\n                    basenum <<= 1;\n                    val = BzpHuffmanDecodeStep(huffman, inData);\n                }\n                for (int32_t j = 0; j < res; j++)\n                {\n                    debwt->block[debwt->nBlock++] = inData->list[0];\n                }\n            }\n            else\n            {\n                int32_t pos = val - 1;\n                ch = inData->list[pos];\n                debwt->block[debwt->nBlock++] = ch;\n\n                for (int32_t j = pos; j > 0; j--)\n                {\n                    inData->list[j] = inData->list[j - 1];\n                }\n                inData->list[0] = ch;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n        }\n        if (val == -1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }", "rust_code": "pub fn BzpMTFDeCode(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    debwt.nBlock = 0;\n    let mut ch: u8 = Default::default();\n    let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n    let mut eob: i32 = ninUse + 1;\n    let mut val: i32 = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n    while (val != eob).as_bool() && (val != -1).as_bool() {\n        if (val == 0).as_bool() || (val == 1).as_bool() {\n            let mut res: i32 = 0;\n            let mut basenum: i32 = 1;\n            while (val == 0).as_bool() || (val == 1).as_bool() {\n                res = res + (val + 1) * basenum;\n                basenum <<= 1;\n                val = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n            }\n            c_for!(let mut j: i32 = 0; j < res; j.suffix_plus_plus(); {\n                debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n            });\n        } else {\n            let mut pos: i32 = val - 1;\n            ch = inData.list[pos].cast();\n            debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n            c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n                inData.list[j] = inData.list[j - 1].cast();\n            });\n            inData.list[0] = ch.cast();\n            val = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n        }\n    }\n    if (val == -1).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    return BZP_OK!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104097608)\nerror[E0499]: cannot borrow `debwt` as mutable more than once at a time\n   --> src/src/public/bzp_decompress_stream_c.rs:170:29\n    |\n170 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                 -----      -^^^^^---------------------------\n    |                 |          ||\n    |                 |          |second mutable borrow occurs here\n    |                 |          first borrow later used here\n    |                 first mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_decompress_stream_c.rs:170:29\n    |\n170 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                             ^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_decompress_stream_c.rs:170:28\n    |\n170 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0499]: cannot borrow `debwt` as mutable more than once at a time\n   --> src/src/public/bzp_decompress_stream_c.rs:175:25\n    |\n175 |             debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n    |             -----      -^^^^^---------------------------\n    |             |          ||\n    |             |          |second mutable borrow occurs here\n    |             |          first borrow later used here\n    |             first mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_decompress_stream_c.rs:175:25\n    |\n175 |             debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n    |                         ^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_decompress_stream_c.rs:175:24\n    |\n175 |             debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"}, {"c_code": "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }", "rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8 = Default::default();\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i].cast();\n        if (inData.num == BZP_RLC_NUM_4!()).as_bool() {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData.cast()).cast();\n            });\n            inData.lasChar = BZP_ASCII_SIZE!().cast();\n            inData.num = 0;\n        } else if (ch == inData.lasChar).as_bool() {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n            ret = BzpWriteChar(ch.cast(), inData.cast()).cast();\n            inData.num.suffix_plus_plus();\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n            ret = BzpWriteChar(ch.cast(), inData.cast()).cast();\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n    });\n    return ret.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104097799)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:166:17\n    |\n166 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:166:17\n    |\n166 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:166:17\n    |\n166 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:166:17\n    |\n166 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:171:26\n    |\n171 |         } else if (ch == inData.lasChar).as_bool() {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n171 |         } else if (i32::from(ch) == inData.lasChar).as_bool() {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:172:13\n    |\n172 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:172:13\n    |\n172 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:172:13\n    |\n172 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:172:13\n    |\n172 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:176:13\n    |\n176 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:176:13\n    |\n176 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:176:13\n    |\n176 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:176:13\n    |\n176 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast());\n    |             ------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"}, {"c_code": "int32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n\n        int32_t ret = BZP_OK;\n        BzpCheckFileHead(inData);\n        uint32_t blockCRC = BzpReadUInt32(inData);\n\n        (void)BzpReadBits(BZP_BIT, inData);\n\n        int32_t oriPtr = BzpReadUInt24(inData);\n        if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        int32_t ninUse = BzpGetDictionaryList(inData);\n        huffman->alphaSize = ninUse + BZP_EXTRA_CHARS_NUM;\n        huffman->nGroups = BzpReadBits(BZP_BITS3, inData);\n        if (huffman->nGroups < BZP_NGROUPS_NUM_0 || huffman->nGroups > BZP_NGROUPS_NUM_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        huffman->nSelect = BzpReadBits(BZP_BITS15, inData);\n\n        int32_t nSelectUpperLimit = (inData->blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP + 1);\n        if (huffman->nSelect < 1 || huffman->nSelect > nSelectUpperLimit)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        ret |= BzpDeHuffmanSelect(inData, huffman);\n\n        ret |= BzpDeHuffmanLen(inData, huffman);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n\n        BzpGenerateDecodeTable(huffman);\n\n        debwt->oriPtr = oriPtr;\n        ret = BzpMTFDeCode(inData, huffman, debwt);\n        if (ret != BZP_OK || debwt->nBlock >= BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        BzpBwtDecode(debwt);\n\n        ret = BzpDeCodeToStream(inData, debwt);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        inData->blockCRC = ~(inData->blockCRC);\n\n        if (blockCRC != inData->blockCRC)\n        {\n            ret = BZP_ERROR_DATA;\n        }\n\n        return ret;\n    }", "rust_code": "pub fn BzpDeCompressOneBlock(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    BzpCheckFileHead(inData.cast());\n    let mut blockCRC: u32 = BzpReadUInt32(inData.cast());\n    BzpReadBits(BZP_BIT!(), inData.cast()).cast::<Void>();\n    let mut oriPtr: i32 = BzpReadUInt24(inData.cast());\n    if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    let mut ninUse: i32 = BzpGetDictionaryList(inData.cast());\n    huffman.alphaSize = (ninUse + BZP_EXTRA_CHARS_NUM!()).cast();\n    huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData.cast()).cast();\n    if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    huffman.nSelect = BzpReadBits(BZP_BITS15!(), inData.cast()).cast();\n    let mut nSelectUpperLimit: i32 = (inData.blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!() + 1).cast();\n    if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    ret |= BzpDeHuffmanSelect(inData.cast(), huffman.cast()).cast();\n    ret |= BzpDeHuffmanLen(inData.cast(), huffman.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    BzpGenerateDecodeTable(huffman.cast());\n    debwt.oriPtr = oriPtr.cast();\n    ret = BzpMTFDeCode(inData.cast(), huffman.cast(), debwt.cast()).cast();\n    if (ret != BZP_OK!() || (debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    BzpBwtDecode(debwt.cast());\n    ret = BzpDeCodeToStream(inData.cast(), debwt.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    inData.blockCRC = !(inData.blockCRC).cast();\n    if (blockCRC != inData.blockCRC).as_bool() {\n        ret = BZP_ERROR_DATA!();\n    }\n    return ret.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104098214)\nerror: mismatched closing delimiter: `}`\n   --> src/src/public/bzp_decompress_stream_c.rs:215:8\n    |\n187 | pub fn BzpDeCompressOneBlock(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    |                                                                                                                                         - closing delimiter possibly meant for this\n...\n215 |     if (ret != BZP_OK!() || (debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n    |        ^ unclosed delimiter\n...\n228 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BZPDeCompressData(InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        uint32_t caltotalCRC = 0;\n        uint8_t ch;\n        ret = BzpReadFileHead(inData);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpHuffmanDecode *huffman = BzpHuffmanDecodeInit(inData->blockSize);\n        BzpBwtDecodeInfo *debwt = BzpBwtDecodeInit(inData->blockSize);\n\n        while ((ch = BzpReadBits(BZP_BITS8, inData)) != BZP_FILE_END_0)\n        {\n            if (ch != BZP_BLOCK_HEAD_0)\n            {\n                ret = BZP_ERROR_DATA;\n                break;\n            }\n            BzpHuffmanDecodeReset(huffman);\n            inData->blockCRC = BZP_INIT_BLOCK_CRC;\n\n            ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n\n            caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n            caltotalCRC ^= inData->blockCRC;\n        }\n        if (ret == BZP_OK)\n        {\n            ret = BZPReadFileEnd(inData, caltotalCRC);\n        }\n        BzpHuffmanDecodeFinish(huffman);\n        BzpBwtDecodeFinish(debwt);\n        return ret;\n    }", "rust_code": "pub fn BZPDeCompressData(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut caltotalCRC: u32 = 0;\n    let mut ch: u8 = Default::default();\n    ret = BzpReadFileHead(inData.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret.cast();\n    }\n    let mut huffman: Ptr<BzpHuffmanDecode> = BzpHuffmanDecodeInit(inData.blockSize.cast());\n    let mut debwt: Ptr<BzpBwtDecodeInfo> = BzpBwtDecodeInit(inData.blockSize.cast());\n\n    while {\n        ch = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n        ch != BZP_FILE_END_0!()\n    } {\n        if (ch != BZP_BLOCK_HEAD_0!()).as_bool() {\n            ret = BZP_ERROR_DATA!();\n            break;\n        }\n        BzpHuffmanDecodeReset(huffman.cast());\n        inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n\n        ret = BzpDeCompressOneBlock(inData.cast(), huffman.cast(), debwt.cast()).cast();\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n\n        caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n        caltotalCRC ^= inData.blockCRC.cast();\n    }\n    if (ret == BZP_OK!()).as_bool() {\n        ret = BZPReadFileEnd(inData.cast(), caltotalCRC.cast()).cast();\n    }\n    BzpHuffmanDecodeFinish(huffman.cast());\n    BzpBwtDecodeFinish(debwt.cast());\n    return ret.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104098717)\nerror[E0283]: type annotations needed\n   --> src/src/public/bzp_decompress_stream_c.rs:274:40\n    |\n274 |         caltotalCRC ^= inData.blockCRC.cast();\n    |                     --                 ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                     |\n    |                     type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `u32: BitXorAssign<_>` found in the `core` crate:\n            - impl BitXorAssign for u32;\n            - impl BitXorAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n    |\n274 |         caltotalCRC ^= inData.blockCRC.cast::<T>();\n    |                                            +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpWriteToArray(int32_t val, int32_t n, BzpOutComdata *data)\n    {\n\n        while (data->nBuf >= BZP_BITS8)\n        {\n            data->out[data->num++] = (uint8_t)(data->buf >> BZP_BITS24);\n            data->nBuf -= BZP_BITS8;\n            data->buf <<= BZP_BITS8;\n        }\n        data->buf |= (val << (BZP_BITS32 - n - data->nBuf));\n        data->nBuf += n;\n    }", "rust_code": "pub fn BzpWriteToArray(mut val: i32, mut n: i32, mut data: Ptr<BzpOutComdata>) {\n    while (data.nBuf >= BZP_BITS8!()).as_bool() {\n        data.out[data.num.suffix_plus_plus()] = (data.buf >> BZP_BITS24!()).cast::<u8>();\n        data.nBuf -= BZP_BITS8!();\n        data.buf <<= BZP_BITS8!();\n    }\n    data.buf |= (val << (BZP_BITS32!() - n - data.nBuf)).cast();\n    data.nBuf += n;\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104101315)\nerror[E0283]: type annotations needed\n   --> src/src/public/bzp_compress_stream_c.rs:119:58\n    |\n119 |     data.buf |= (val << (BZP_BITS32!() - n - data.nBuf)).cast();\n    |              -- type must be known at this point         ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\n    = note: multiple `impl`s satisfying `u32: BitOrAssign<_>` found in the `core` crate:\n            - impl BitOrAssign for u32;\n            - impl BitOrAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n    |\n119 |     data.buf |= (val << (BZP_BITS32!() - n - data.nBuf)).cast::<T>();\n    |                                                              +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpWriteValidASCII(BzpOutComdata *outData, BzpBwtInfo *bwt)\n    {\n        int32_t validGid[BZP_ASCII_SIZE], cnt = 0;\n        bool use16[BZP_ASCII_SIZE];\n        (void)memset_s(use16, sizeof(use16), 0, sizeof(use16));\n\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            int32_t gid = i / BZP_CHARS_PER_GROUP_ASCII;\n            use16[gid] |= bwt->inUse[i];\n        }\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            BzpWriteToArray((int32_t)(use16[i]), BZP_BIT, outData);\n            if (use16[i])\n            {\n                validGid[cnt++] = i;\n            }\n        }\n        for (int32_t i = 0; i < cnt; i++)\n        {\n            for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++)\n            {\n                int32_t valid = validGid[i] * BZP_CHARS_PER_GROUP_ASCII + j;\n                BzpWriteToArray((int32_t)(bwt->inUse[valid]), BZP_BIT, outData);\n            }\n        }\n    }", "rust_code": "pub fn BzpWriteValidASCII(mut outData: Ptr<BzpOutComdata>, mut bwt: Ptr<BzpBwtInfo>) {\n    let mut validGid: Array<i32, { BZP_ASCII_SIZE!() }> = Default::default();\n    let mut cnt: i32 = 0;\n    let mut use16: Array<bool, { BZP_ASCII_SIZE!() }> = Default::default();\n    c_memset_s!(use16, c_sizeofval!(use16), 0, c_sizeofval!(use16)).cast::<Void>();\n\n    c_for!(let mut i: i32 = 0; i < BZP_ASCII_SIZE!().cast(); i.suffix_plus_plus(); {\n        let mut gid: i32 = i / BZP_CHARS_PER_GROUP_ASCII!();\n        use16[gid] |= bwt.inUse[i].cast();\n    });\n    c_for!(let mut i: i32 = 0; i < BZP_GROUPS_ASCII!().cast(); i.suffix_plus_plus(); {\n        BzpWriteToArray(use16[i].cast::<i32>(), BZP_BIT!(), outData.cast());\n        if use16[i].as_bool() {\n            validGid[cnt] = i.cast();\n            cnt += 1;\n        }\n    });\n    c_for!(let mut i: i32 = 0; i < cnt; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < BZP_CHARS_PER_GROUP_ASCII!(); j.suffix_plus_plus(); {\n            let mut valid: i32 = validGid[i] * BZP_CHARS_PER_GROUP_ASCII!() + j;\n            BzpWriteToArray(bwt.inUse[valid].cast::<i32>(), BZP_BIT!(), outData.cast());\n        });\n    });\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104102603)\nerror[E0283]: type annotations needed\n   --> src/src/public/bzp_compress_stream_c.rs:174:36\n    |\n174 |         use16[gid] |= bwt.inUse[i].cast();\n    |                    --              ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                    |\n    |                    type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `bool: BitOrAssign<_>` found in the `core` crate:\n            - impl BitOrAssign for bool;\n            - impl BitOrAssign<&bool> for bool;\nhelp: consider specifying the generic argument\n    |\n174 |         use16[gid] |= bwt.inUse[i].cast::<T>();\n    |                                        +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpFlushbuf(BzpOutComdata *outData)\n    {\n        while (outData->nBuf > 0)\n        {\n            outData->out[outData->num++] = (uint8_t)(outData->buf >> BZP_BITS24);\n            outData->nBuf -= BZP_BITS8;\n            outData->buf <<= BZP_BITS8;\n        }\n    }", "rust_code": "pub fn BzpFlushbuf(mut outData: Ptr<BzpOutComdata>) {\n    while (outData.nBuf > 0).as_bool() {\n        outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n        outData.num += 1;\n        outData.nBuf -= BZP_BITS8!();\n        outData.buf <<= BZP_BITS8!();\n    }\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104103703)\nerror[E0502]: cannot borrow `outData` as immutable because it is also borrowed as mutable\n   --> src/src/public/bzp_compress_stream_c.rs:232:21\n    |\n232 |         outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n    |         -------    -^^^^^^^-----\n    |         |          ||\n    |         |          |immutable borrow occurs here\n    |         |          mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_compress_stream_c.rs:232:21\n    |\n232 |         outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n    |                     ^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_compress_stream_c.rs:232:20\n    |\n232 |         outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n    |                    ^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BzpBuffToStream(BzpFile *bzpf, BzpOutComdata *outData)\n    {\n        bzpf->output->pos = 0;\n\n        int32_t pos = 0;\n\n        while (pos < outData->num)\n        {\n            bzpf->output->nBuf = 0;\n\n            while (pos < outData->num && bzpf->output->nBuf < BZP_BUF_SIZE)\n            {\n                bzpf->output->buf[bzpf->output->nBuf++] = outData->out[pos];\n                pos++;\n            }\n            int32_t n2 =\n                fwrite((void *)(bzpf->output->buf), sizeof(uint8_t), bzpf->output->nBuf, bzpf->output->filePtr);\n            if (n2 != bzpf->output->nBuf)\n            {\n                return BZP_ERROR_IO;\n            }\n        }\n        return BZP_OK;\n    }", "rust_code": "pub fn BzpBuffToStream(mut bzpf: Ptr<BzpFile>, mut outData: Ptr<BzpOutComdata>) -> i32 {\n    bzpf.output.pos = 0;\n    let mut pos: i32 = 0;\n    while (pos < outData.num).as_bool() {\n        bzpf.output.nBuf = 0;\n        while (pos < outData.num).as_bool() && (bzpf.output.nBuf < BZP_BUF_SIZE!()).as_bool() {\n            bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n            bzpf.output.nBuf += 1;\n            pos += 1;\n        }\n        let mut n2: i32 = c_fwrite!(bzpf.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), bzpf.output.nBuf, bzpf.output.filePtr);\n        if (n2 != bzpf.output.nBuf).as_bool() {\n            return BZP_ERROR_IO!();\n        }\n    }\n    return BZP_OK!();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104104149)\nerror[E0502]: cannot borrow `bzpf` as immutable because it is also borrowed as mutable\n   --> src/src/public/bzp_compress_stream_c.rs:292:29\n    |\n292 |             bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n    |             ----           -^^^^-------------\n    |             |              ||\n    |             |              |immutable borrow occurs here\n    |             |              mutable borrow later used here\n    |             mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_compress_stream_c.rs:292:29\n    |\n292 |             bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n    |                             ^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_compress_stream_c.rs:292:28\n    |\n292 |             bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n    |                            ^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }", "rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!() || num > BZP_RLC_NUM_UPPER_LIMIT!()).as_bool() {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!().cast()).cast();\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()).as_bool() {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104104365)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:300:18\n    |\n300 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:296:9\n    |\n296 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:296:9\n    |\n296 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:296:9\n    |\n296 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:296:9\n    |\n296 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"}, {"c_code": "void BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata)\n    {\n\n        while (!BZP_BLOCK_FULL(bwt) && !BZP_BUFF_READ_EMPTY(bzpf))\n        {\n            int32_t pos = bzpf->input->pos;\n            uint8_t ch = (uint8_t)bzpf->input->buf[pos];\n            uint8_t lasch = (uint8_t)bzpf->lasChar;\n            if (ch != lasch || bzpf->num == BZP_RLC_NUM_UPPER_LIMIT)\n            {\n                BzpAddCharToBlock(lasch, bzpf->num, bwt);\n                bzpf->lasChar = ch;\n                bzpf->num = 1;\n            }\n            else\n            {\n                bzpf->num++;\n            }\n\n            bzpf->input->pos++;\n        }\n\n        if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n        {\n\n            BzpAddCharToBlock(bzpf->lasChar, bzpf->num, bwt);\n            bzpf->lasChar = BZP_ASCII_SIZE;\n            bzpf->num = 0;\n        }\n    }", "rust_code": "pub fn BzpBuffToBlockRLC(mut bzpf: Ptr<BzpFile>, mut bwt: Ptr<BzpBwtInfo>, mut IsLastdata: bool) {\n    while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n        let mut pos: i32 = bzpf.input.pos.cast();\n        let mut ch: u8 = (bzpf.input.buf[pos]).cast::<u8>();\n        let mut lasch: u8 = (bzpf.lasChar).cast::<u8>();\n        if (ch != lasch).as_bool() || (bzpf.num == BZP_RLC_NUM_UPPER_LIMIT!()).as_bool() {\n            BzpAddCharToBlock(lasch.cast(), bzpf.num.cast(), bwt.cast());\n            bzpf.lasChar = ch.cast();\n            bzpf.num = 1;\n        } else {\n            bzpf.num += 1;\n        }\n        bzpf.input.pos += 1;\n    }\n    if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n        BzpAddCharToBlock(bzpf.lasChar.cast(), bzpf.num.cast(), bwt.cast());\n        bzpf.lasChar = BZP_ASCII_SIZE!();\n        bzpf.num = 0;\n    }\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104104582)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:297:48\n    |\n297 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:297:48\n    |\n297 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:310:33\n    |\n310 |     if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                 -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:310:33\n    |\n310 |     if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                 -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"}, {"c_code": "void BzpResetCompress(BzpBwtInfo *bwt, BzpOutComdata *outData)\n    {\n\n        outData->num = 0;\n\n        bwt->nBlock = 0;\n        bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n        (void)memset_s(bwt->inUse, sizeof(bwt->inUse), 0, sizeof(bwt->inUse));\n        int32_t n = outData->blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t);\n        (void)memset_s(bwt->isStartPos, n, 0, n);\n        bwt->blockId++;\n    }", "rust_code": "pub fn BzpResetCompress(mut bwt: Ptr<BzpBwtInfo>, mut outData: Ptr<BzpOutComdata>) {\n    outData.num = 0;\n    bwt.nBlock = 0;\n    bwt.blockCRC = BZP_INIT_BLOCK_CRC!();\n    c_memset_s!(bwt.inUse, c_sizeofval!(bwt.inUse), 0, c_sizeofval!(bwt.inUse)).cast::<Void>();\n    let mut n: i32 = outData.blockSize * BZP_BASE_BLOCK_SIZE!() * c_sizeof!(i32);\n    c_memset_s!(bwt.isStartPos, n.cast(), 0, n.cast()).cast::<Void>();\n    bwt.blockId += 1;\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104104805)\nerror[E0282]: type annotations needed\n   --> src/src/public/bzp_compress_stream_c.rs:307:35\n    |\n307 |     c_memset_s!(bwt.isStartPos, n.cast(), 0, n.cast()).cast::<Void>();\n    |                                   ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n307 |     c_memset_s!(bwt.isStartPos, n.cast::<T>(), 0, n.cast()).cast::<Void>();\n    |                                       +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "int32_t BzpProcessData(BzpAlgorithmInfo *bzpInfo, bool IsLastdata)\n    {\n        BzpFile *bzpf = bzpInfo->compressFile;\n        BzpOutComdata *outData = bzpInfo->outData;\n        BzpBwtInfo *bwt = bzpInfo->bwt;\n\n        bzpf->state = BZP_INPUT_COMPRESS;\n        int32_t ret = BZP_OK;\n        while (bzpf->state != BZP_RETUEN_COMPRESS)\n        {\n            if (bzpf->state == BZP_OUTPUT_COMPRESS)\n            {\n\n                ret = BzpBuffToStream(bzpf, outData);\n\n                BzpResetCompress(bwt, outData);\n                bzpf->state = BZP_INPUT_COMPRESS;\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (bzpf->state == BZP_INPUT_COMPRESS)\n            {\n\n                BzpBuffToBlockRLC(bzpf, bwt, IsLastdata);\n\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n\n                    BzpWriteFileEnd(outData, bwt->combinedCRC);\n                    BzpFlushbuf(outData);\n\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else if (BZP_BLOCK_FULL(bwt))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (ret != BZP_OK)\n            {\n                return ret;\n            }\n        }\n        return ret;\n    }", "rust_code": "pub fn BzpProcessData(mut bzpInfo: Ptr<BzpAlgorithmInfo>, mut IsLastdata: bool) -> i32 {\n    let mut bzpf: Ptr<BzpFile> = bzpInfo.compressFile.cast();\n    let mut outData: Ptr<BzpOutComdata> = bzpInfo.outData.cast();\n    let mut bwt: Ptr<BzpBwtInfo> = bzpInfo.bwt.cast();\n\n    bzpf.state = BZP_INPUT_COMPRESS!();\n    let mut ret: i32 = BZP_OK!();\n    while (bzpf.state != BZP_RETUEN_COMPRESS!()).as_bool() {\n        if (bzpf.state == BZP_OUTPUT_COMPRESS!()).as_bool() {\n            ret = BzpBuffToStream(bzpf.cast(), outData.cast()).cast();\n            BzpResetCompress(bwt.cast(), outData.cast());\n            bzpf.state = BZP_INPUT_COMPRESS!();\n            if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n                bzpf.state = BZP_RETUEN_COMPRESS!();\n            }\n        }\n        if (bzpf.state == BZP_INPUT_COMPRESS!()).as_bool() {\n            BzpBuffToBlockRLC(bzpf.cast(), bwt.cast(), IsLastdata.cast());\n            if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n                ret = BzpCompressOneBlock(bzpInfo.cast(), outData.cast()).cast();\n                BzpWriteFileEnd(outData.cast(), bwt.combinedCRC.cast());\n                BzpFlushbuf(outData.cast());\n                bzpf.state = BZP_OUTPUT_COMPRESS!();\n            } else if BZP_BLOCK_FULL!(bwt).as_bool() {\n                ret = BzpCompressOneBlock(bzpInfo.cast(), outData.cast()).cast();\n                bzpf.state = BZP_OUTPUT_COMPRESS!();\n            } else {\n                bzpf.state = BZP_RETUEN_COMPRESS!();\n            }\n        }\n        if (ret != BZP_OK!()).as_bool() {\n            return ret;\n        }\n    }\n    return ret.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104105017)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:318:40\n    |\n318 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:318:40\n    |\n318 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:324:40\n    |\n324 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:324:40\n    |\n324 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"}, {"c_code": "int32_t BzpCompressStream(char *inName, char *outName, int32_t blockSize)\n    {\n\n        int32_t ret = BZP_OK;\n        bool IsLastdata = false;\n\n        if (inName == NULL || outName == NULL || BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        BzpAlgorithmInfo *bzpInfo = BzpAlgorithmInfoInit(blockSize);\n        if (bzpInfo == NULL)\n        {\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        ret = BzpOpenFile(bzpInfo, inName, outName);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpStream *inStream = bzpInfo->compressFile->input;\n\n        while (!IsLastdata)\n        {\n            inStream->nBuf = fread(inStream->buf, sizeof(char), sizeof(inStream->buf), inStream->filePtr);\n            inStream->pos = 0;\n            IsLastdata = BzpFileEOF(inStream->filePtr);\n            ret = BzpProcessData(bzpInfo, IsLastdata);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n        }\n        BzpCompressEnd(bzpInfo);\n        if (ret != BZP_OK)\n        {\n            remove(outName);\n        }\n        return ret;\n    }", "rust_code": "pub fn BzpCompressStream(mut inName: Ptr<u8>, mut outName: Ptr<u8>, mut blockSize: i32) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut IsLastdata: bool = false;\n\n    if (inName == NULL!()).as_bool() || (outName == NULL!()).as_bool() || BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return BZP_ERROR_PARAM!();\n    }\n\n    let mut bzpInfo: Ptr<BzpAlgorithmInfo> = BzpAlgorithmInfoInit(blockSize.cast());\n    if (bzpInfo == NULL!()).as_bool() {\n        return BZP_ERROR_MEMORY_OPER_FAILURE!();\n    }\n    ret = BzpOpenFile(bzpInfo.cast(), inName.cast(), outName.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    let mut inStream: Ptr<BzpStream> = bzpInfo.compressFile.input.cast();\n\n    while !IsLastdata.as_bool() {\n        inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n        inStream.pos = 0;\n        IsLastdata = BzpFileEOF(inStream.filePtr.cast()).cast();\n        ret = BzpProcessData(bzpInfo.cast(), IsLastdata.cast()).cast();\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n    }\n    BzpCompressEnd(bzpInfo.cast());\n    if (ret != BZP_OK!()).as_bool() {\n        c_remove!(outName);\n    }\n    return ret.cast();\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104105473)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/memory/file_ptr.rs:368:9\n    |\n368 |         fread($ptr.cast(), $size.cast(), $count.cast(), &mut $file).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:341:25\n    |\n341 |         inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n    |                         ------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `c_fread` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}, {"c_code": "void BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t)\n    {\n        int32_t vec = 0, cnt = 0;\n        int32_t mi = huffman->len[t][0], mx = huffman->len[t][0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[t][i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[t][i]);\n        }\n        huffman->minLens[t] = mi;\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[t][j] == i)\n                {\n                    huffman->perm[t][cnt++] = j;\n                }\n            }\n        }\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->base[t][huffman->len[t][i] + 1]++;\n        }\n\n        for (int32_t i = 1; i <= mx + 1; i++)\n        {\n            huffman->base[t][i] += huffman->base[t][i - 1];\n        }\n\n        for (int32_t i = mi; i <= mx; i++)\n        {\n\n            vec += (huffman->base[t][i + 1] - huffman->base[t][i]);\n\n            huffman->limit[t][i] = vec - 1;\n            vec <<= 1;\n        }\n        for (int32_t i = mi + 1; i <= mx; i++)\n        {\n            huffman->base[t][i] = ((huffman->limit[t][i - 1] + 1) << 1) - huffman->base[t][i];\n        }\n    }", "rust_code": "pub fn BzpGetOneTable(mut huffman: Ptr<BzpHuffmanDecode>, mut t: i32) {\n    let mut vec: i32 = 0;\n    let mut cnt: i32 = 0;\n    let mut mi: i32 = huffman.len[t][0].cast();\n    let mut mx: i32 = huffman.len[t][0].cast();\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize.cast(); i.suffix_plus_plus(); {\n        mi = BZP_MIN_FUN!(mi, huffman.len[t][i].cast());\n        mx = BZP_MAX_FUN!(mx, huffman.len[t][i].cast());\n    });\n    huffman.minLens[t] = mi.cast();\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize.cast(); j.suffix_plus_plus(); {\n            if (huffman.len[t][j] == i).as_bool() {\n                huffman.perm[t][cnt] = j.cast();\n                cnt += 1;\n            }\n        });\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize.cast(); i.suffix_plus_plus(); {\n        huffman.base[t][huffman.len[t][i] + 1] += 1;\n    });\n    c_for!(let mut i: i32 = 1; i <= mx + 1; i.suffix_plus_plus(); {\n        huffman.base[t][i] += huffman.base[t][i - 1].cast();\n    });\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        vec += (huffman.base[t][i + 1] - huffman.base[t][i]).cast();\n        huffman.limit[t][i] = (vec - 1).cast();\n        vec <<= 1;\n    });\n    c_for!(let mut i: i32 = mi + 1; i <= mx; i.suffix_plus_plus(); {\n        huffman.base[t][i] = (((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i].cast();\n    });\n}\n", "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744104106856)\nerror: mismatched closing delimiter: `}`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:66:30\n   |\n65 |     c_for!(let mut i: i32 = mi + 1; i <= mx; i.suffix_plus_plus(); {\n   |                                                                    - closing delimiter possibly meant for this\n66 |         huffman.base[t][i] = (((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i].cast();\n   |                              ^ unclosed delimiter\n67 |     });\n   |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"}]}