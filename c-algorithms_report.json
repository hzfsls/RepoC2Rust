{
    "All": 200,
    "Compilation Pass": 180,
    "Compilation Error": 20,
    "Pass Rate": 0.9,
    "Error Information": [
        {
            "c_code": "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}",
            "rust_code": "pub fn rb_tree_insert(mut tree: Ptr<RBTree>, mut key: RBTreeKey, mut value: RBTreeValue) -> Ptr<RBTreeNode> {\n    let mut node: Ptr<RBTreeNode>;\n    let mut rover: Ptr<Ptr<RBTreeNode>>;\n    let mut parent: Ptr<RBTreeNode>;\n    let mut side: RBTreeNodeSide;\n\n    node = c_malloc!(c_sizeof!(RBTreeNode));\n\n    if (node == NULL!()) {\n        return NULL!();\n    }\n\n    node.key = key;\n    node.value = value;\n    node.color = RB_TREE_NODE_RED!();\n    node.children[RB_TREE_NODE_LEFT!()] = NULL!();\n    node.children[RB_TREE_NODE_RIGHT!()] = NULL!();\n\n    parent = NULL!();\n    rover = c_ref!(tree.root_node);\n\n    while (*rover != NULL!()) {\n        parent = *rover;\n\n        if (tree.compare_func(value, (*rover).value) < 0) {\n            side = RB_TREE_NODE_LEFT!();\n        } else {\n            side = RB_TREE_NODE_RIGHT!();\n        }\n\n        rover = c_ref!((*rover).children[side]);\n    }\n\n    *rover = node;\n    node.parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928781757)\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_RBTree>` in the current scope\n   --> src/src/rb_tree_c.rs:205:18\n    |\n205 |         if (tree.compare_func(value.cast(), (*rover).value.cast()) < 0).as_bool() {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n205 |         if ((tree.compare_func)(value.cast(), (*rover).value.cast()) < 0).as_bool() {\n    |             +                 +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void arraylist_remove_range(ArrayList *arraylist, unsigned int index, unsigned int length)\n{\n\n    if (index > arraylist->length || index + length > arraylist->length)\n    {\n        return;\n    }\n\n    memmove(&arraylist->data[index], &arraylist->data[index + length],\n            (arraylist->length - (index + length)) * sizeof(ArrayListValue));\n\n    arraylist->length -= length;\n}",
            "rust_code": "pub fn arraylist_remove_range(mut arraylist: Ptr<ArrayList>, mut index: u32, mut length: u32) {\n    if (index > arraylist.length || index + length > arraylist.length) {\n        return;\n    }\n\n    c_memmove_s!(\n        c_ref!(arraylist.data[index]),\n        c_ref!(arraylist.data[index + length]),\n        (arraylist.length - (index + length)) * c_sizeof!(ArrayListValue)\n    );\n\n    arraylist.length -= length;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928790846)\nerror: unexpected end of macro invocation\n   --> src/src/arraylist_c.rs:100:74\n    |\n100 |         (arraylist.length - (index + length)) * c_sizeof!(ArrayListValue)\n    |                                              - help: missing comma here  ^ missing tokens in macro arguments\n    |\n   ::: src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:45:1\n    |\n45  | macro_rules! c_memmove_s {\n    | ------------------------ when calling this macro\n    |\nnote: while trying to match `,`\n   --> src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:46:42\n    |\n46  |     ($dst:expr, $dst_size:expr, $src:expr, $count:expr) => {\n    |                                          ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static void arraylist_sort_internal(ArrayListValue *list_data, unsigned int list_length,\n                                    ArrayListCompareFunc compare_func)\n{\n    ArrayListValue pivot;\n    ArrayListValue tmp;\n    unsigned int i;\n    unsigned int list1_length;\n    unsigned int list2_length;\n\n    if (list_length <= 1)\n    {\n        return;\n    }\n\n    pivot = list_data[list_length - 1];\n# 221 \".tmp/src/arraylist.c\"\n    list1_length = 0;\n\n    for (i = 0; i < list_length - 1; ++i)\n    {\n\n        if (compare_func(list_data[i], pivot) < 0)\n        {\n\n            tmp = list_data[i];\n            list_data[i] = list_data[list1_length];\n            list_data[list1_length] = tmp;\n\n            ++list1_length;\n        }\n        else\n        {\n        }\n    }\n\n    list2_length = list_length - list1_length - 1;\n# 255 \".tmp/src/arraylist.c\"\n    list_data[list_length - 1] = list_data[list1_length];\n    list_data[list1_length] = pivot;\n\n    arraylist_sort_internal(list_data, list1_length, compare_func);\n\n    arraylist_sort_internal(&list_data[list1_length + 1], list2_length, compare_func);\n}",
            "rust_code": "pub fn arraylist_sort_internal(mut list_data: Ptr<ArrayListValue>, mut list_length: u32, mut compare_func: ArrayListCompareFunc) {\n    let mut pivot: ArrayListValue = Default::default();\n    let mut tmp: ArrayListValue = Default::default();\n    let mut i: u32 = Default::default();\n    let mut list1_length: u32 = Default::default();\n    let mut list2_length: u32 = Default::default();\n\n    if (list_length <= 1) {\n        return;\n    }\n\n    pivot = list_data[list_length - 1];\n\n    list1_length = 0;\n\n    c_for!(let mut i: u32 = 0; i < list_length - 1; i.prefix_plus_plus(); {\n        if (compare_func(list_data[i], pivot) < 0 {\n            tmp = list_data[i];\n            list_data[i] = list_data[list1_length];\n            list_data[list1_length] = tmp;\n\n            list1_length += 1;\n        } else {\n        }\n    });\n\n    list2_length = list_length - list1_length - 1;\n\n    list_data[list_length - 1] = list_data[list1_length];\n    list_data[list1_length] = pivot;\n\n    arraylist_sort_internal(list_data, list1_length, compare_func);\n\n    arraylist_sort_internal((list_data.cast::<Ptr<ArrayListValue>>() + list1_length + 1), list2_length, compare_func);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928793281)\nerror: mismatched closing delimiter: `}`\n   --> src/src/arraylist_c.rs:134:12\n    |\n133 |     c_for!(let mut i: u32 = 0; i < list_length - 1; i.prefix_plus_plus(); {\n    |                                                                           - closing delimiter possibly meant for this\n134 |         if (compare_func(list_data[i].cast(), pivot.cast()) < 0 {\n    |            ^ unclosed delimiter\n...\n142 |     });\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *child;\n    int diff;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2)\n    {\n\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]))\n        {\n\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);\n    }\n    else if (diff <= -2)\n    {\n\n        child = node->children[AVL_TREE_NODE_LEFT];\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]))\n        {\n\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}",
            "rust_code": "pub fn avl_tree_node_balance(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) -> Ptr<AVLTreeNode> {\n    let mut left_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut right_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut child: Ptr<AVLTreeNode> = Default::default();\n    let mut diff: i32 = Default::default();\n\n    left_subtree = node.children[AVL_TREE_NODE_LEFT!()];\n    right_subtree = node.children[AVL_TREE_NODE_RIGHT!()];\n\n    diff = (avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2) {\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()]) <\n            avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()]) {\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT!());\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT!());\n    } else if (diff <= -2) {\n        child = node.children[AVL_TREE_NODE_LEFT!()];\n\n        if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()]) <\n            avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()]) {\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT!());\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT!());\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928811179)\nerror: mismatched closing delimiter: `}`\n   --> src/src/avl_tree_c.rs:149:12\n    |\n146 |     if (diff >= 2).as_bool() {\n    |                              - closing delimiter possibly meant for this\n...\n149 |         if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()].cast()) <\n    |            ^ unclosed delimiter\n...\n155 |     } else if (diff <= -2).as_bool() {\n    |     ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/avl_tree_c.rs:158:12\n    |\n155 |     } else if (diff <= -2).as_bool() {\n    |                                      - closing delimiter possibly meant for this\n...\n158 |         if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()].cast()) <\n    |            ^ unclosed delimiter\n...\n164 |     }\n    |     ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/avl_tree_c.rs:144:12\n    |\n135 | pub fn avl_tree_node_balance(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) -> Ptr<AVLTreeNode> {\n    |                                                                                                      - closing delimiter possibly meant for this\n...\n144 |     diff = (avl_tree_subtree_height(right_subtree.cast()) - avl_tree_subtree_height(left_subtree.cast());\n    |            ^ unclosed delimiter\n...\n169 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}",
            "rust_code": "pub fn avl_tree_insert(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey, mut value: AVLTreeValue) -> Ptr<AVLTreeNode> {\n    let mut rover: Ptr<Ptr<AVLTreeNode>> = Default::default();\n    let mut new_node: Ptr<AVLTreeNode> = Default::default();\n    let mut previous_node: Ptr<AVLTreeNode> = Default::default();\n\n    rover = c_ref!(tree.root_node);\n    previous_node = NULL!();\n\n    while (*rover != NULL!()) {\n        previous_node = *rover;\n        if (tree.compare_func(key, (*rover).key) < 0) {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_LEFT!()]);\n        } else {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_RIGHT!()]);\n        }\n    }\n\n    new_node = c_malloc!(c_sizeof!(AVLTreeNode));\n\n    if (new_node == NULL!()) {\n        return NULL!();\n    }\n\n    new_node.children[AVL_TREE_NODE_LEFT!()] = NULL!();\n    new_node.children[AVL_TREE_NODE_RIGHT!()] = NULL!();\n    new_node.parent = previous_node;\n    new_node.key = key;\n    new_node.value = value;\n    new_node.height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return new_node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928813739)\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_AVLTree>` in the current scope\n   --> src/src/avl_tree_c.rs:160:18\n    |\n160 |         if (tree.compare_func(key.cast(), (*rover).key.cast()) < 0).as_bool() {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n160 |         if ((tree.compare_func)(key.cast(), (*rover).key.cast()) < 0).as_bool() {\n    |             +                 +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}",
            "rust_code": "pub fn bloom_filter_new(mut table_size: u32, mut hash_func: BloomFilterHashFunc, mut num_functions: u32) -> Ptr<BloomFilter> {\n    let mut filter: Ptr<BloomFilter> = Default::default();\n\n    if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts))) {\n        return NULL!();\n    }\n\n    filter = c_malloc!(c_sizeof!(BloomFilter));\n\n    if (filter == NULL!()) {\n        return NULL!();\n    }\n\n    filter.table = c_calloc!((table_size + 7) / 8, 1);\n\n    if (filter.table == NULL!()) {\n        c_free!(filter);\n        return NULL!();\n    }\n\n    filter.hash_func = hash_func;\n    filter.num_functions = num_functions;\n    filter.table_size = table_size;\n\n    return filter;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928842769)\nerror: expected `mut` or `const` keyword in raw pointer type\n  --> src/src/bloom_filter_c.rs:29:55\n   |\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts))).as_bool() {\n   |                                                       ^\n   |\nhelp: add `mut` or `const` here\n   |\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*mut salts))).as_bool() {\n   |                                                        +++\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*const salts))).as_bool() {\n   |                                                        +++++\n\nerror[E0573]: expected type, found constant `salts`\n  --> src/src/bloom_filter_c.rs:29:56\n   |\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts))).as_bool() {\n   |                                                        ^^^^^ not a type\n\nerror[E0747]: constant provided when a type was expected\n  --> src/src/bloom_filter_c.rs:29:36\n   |\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts))).as_bool() {\n   |                                    ^^^^^\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:29:25\n   |\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts))).as_bool() {\n   |         -------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `Num`\n   |         |\n   |         expected because this is `u32`\n\nSome errors have detailed explanations: E0308, E0573, E0747.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n    int bit;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = bloomfilter->table[index / 8];\n        bit = 1 << (index % 8);\n\n        if ((b & bit) == 0)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}",
            "rust_code": "pub fn bloom_filter_query(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) -> i32 {\n    let mut hash: u32 = Default::default();\n    let mut subhash: u32 = Default::default();\n    let mut index: u32 = Default::default();\n    let mut i: u32 = Default::default();\n    let mut b: u8 = Default::default();\n    let mut bit: i32 = Default::default();\n\n    hash = bloomfilter.hash_func(value);\n\n    c_for!(let mut i: u32 = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = (hash ^ salts[i]);\n        index = (subhash % bloomfilter.table_size);\n        b = bloomfilter.table[index / 8];\n        bit = (1 << (index % 8));\n        if ((b & bit) == 0) {\n            return 0;\n        }\n    });\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928848348)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:63:24\n   |\n63 |     hash = bloomfilter.hash_func(value).cast();\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n63 |     hash = (bloomfilter.hash_func)(value).cast();\n   |            +                     +\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:70:18\n   |\n70 |         if ((b & bit) == 0).as_bool() {\n   |                  ^^^ expected `u8`, found `i32`\n\nerror[E0277]: no implementation for `u8 & i32`\n  --> src/src/bloom_filter_c.rs:70:16\n   |\n70 |         if ((b & bit) == 0).as_bool() {\n   |                ^ no implementation for `u8 & i32`\n   |\n   = help: the trait `BitAnd<i32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u8` implements `BitAnd<u8>`\n             `&u8` implements `BitAnd`\n             `u8` implements `BitAnd<&u8>`\n             `u8` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "unsigned int string_hash(void *string)\n{\n\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + *p;\n        ++p;\n    }\n\n    return result;\n}",
            "rust_code": "pub fn string_hash(mut string: Ptr<Void>) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p: Ptr<u8> = string.cast::<Ptr<u8>>();\n\n    while (*p != '\\0') {\n        result = (result << 5) + result + (*p).cast::<u32>();\n        p = p + 1;\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928852397)\nerror[E0308]: mismatched types\n --> src/src/hash_string_c.rs:8:18\n  |\n8 |     while (*p != '\\0').as_bool() {\n  |            --    ^^^^ expected `u8`, found `char`\n  |            |\n  |            expected because this is `u8`\n  |\nhelp: if you meant to write a byte literal, prefix with `b`\n  |\n8 |     while (*p != b'\\0').as_bool() {\n  |                  ~~~~~\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "unsigned int string_nocase_hash(void *string)\n{\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + (unsigned int)tolower(*p);\n        ++p;\n    }\n\n    return result;\n}",
            "rust_code": "pub fn string_nocase_hash(mut string: Ptr<Void>) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p: Ptr<u8> = string.cast::<Ptr<u8>>();\n\n    while (*p != '\\0') {\n        result = (result << 5) + result + c_tolower!(*p).cast::<u32>();\n        p += 1;\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928854446)\nerror[E0308]: mismatched types\n  --> src/src/hash_string_c.rs:13:18\n   |\n13 |     while (*p != '\\0').as_bool() {\n   |            --    ^^^^ expected `u8`, found `char`\n   |            |\n   |            expected because this is `u8`\n   |\nhelp: if you meant to write a byte literal, prefix with `b`\n   |\n13 |     while (*p != b'\\0').as_bool() {\n   |                  ~~~~~\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static void trie_free_list_push(TrieNode **list, TrieNode *node)\n{\n    node->data = *list;\n    *list = node;\n}",
            "rust_code": "pub fn trie_free_list_push(mut list: Ptr<Ptr<TrieNode>>, mut node: Ptr<TrieNode>) {\n    node.data = *list;\n    *list = node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928856716)\nerror[E0282]: type annotations needed\n  --> src/src/trie_c.rs:34:23\n   |\n34 |     node.data = *list.cast();\n   |                       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n34 |     node.data = *list.cast::<T>();\n   |                           +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static TrieNode *trie_find_end(Trie *trie, char *key)\n{\n    TrieNode *node;\n    char *p;\n\n    node = trie->root_node;\n\n    for (p = key; *p != '\\0'; ++p)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        node = node->next[(unsigned char)*p];\n    }\n\n    return node;\n}",
            "rust_code": "pub fn trie_find_end(mut trie: Ptr<Trie>, mut key: Ptr<u8>) -> Ptr<TrieNode> {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n\n    node = trie.root_node;\n\n    c_for!(p = key; *p != '\\0'; p.prefix_plus_plus(); {\n        if (node == NULL!()) {\n            return NULL!();\n        }\n        let tmp0 = (*p).cast::<u8>();\n        node = node.next[tmp0];\n    });\n\n    return node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928859204)\nerror[E0308]: mismatched types\n  --> src/src/trie_c.rs:79:27\n   |\n79 |     c_for!(p = key; *p != '\\0'; p.prefix_plus_plus(); {\n   |                     --    ^^^^ expected `u8`, found `char`\n   |                     |\n   |                     expected because this is `u8`\n   |\nhelp: if you meant to write a byte literal, prefix with `b`\n   |\n79 |     c_for!(p = key; *p != b'\\0'; p.prefix_plus_plus(); {\n   |                           ~~~~~\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
            "rust_code": "pub fn trie_insert(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()) {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = value;\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node);\n    p = key;\n\n    loop {\n        node = *rover.cast();\n\n        if (node == NULL!()) {\n            node = c_calloc!(1, c_sizeof!(TrieNode)).cast::<Ptr<TrieNode>>();\n\n            if (node == NULL!()) {\n                trie_insert_rollback(trie, key.cast::<Ptr<u8>>());\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n            *rover = node;\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = (*p.cast::<Ptr<u8>>()).cast::<u8>().cast::<i32>();\n\n        if (c == '\\0' as i32) {\n            node.data = value;\n            break;\n        }\n\n        rover = c_ref!(node.next[c]);\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928862367)\nerror[E0282]: type annotations needed\n   --> src/src/trie_c.rs:154:23\n    |\n154 |         node = *rover.cast();\n    |                       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n154 |         node = *rover.cast::<T>();\n    |                           +++++\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:164:25\n    |\n164 |             node.data = TRIE_NULL!().cast();\n    |                         ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `(): CastInto<{type error}>` is not satisfied\n   --> src/src/trie_c.rs:160:74\n    |\n160 |                 trie_insert_rollback(trie.cast(), key.cast::<Ptr<u8>>()).cast();\n    |                                                                          ^^^^ the trait `integer::Integer` is not implemented for `()`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<()>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `()` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "int trie_remove(Trie *trie, char *key)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    char *p;\n    int c;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        c = (unsigned char)*p;\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (c == '\\0')\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}",
            "rust_code": "pub fn trie_remove(mut trie: Ptr<Trie>, mut key: Ptr<u8>) -> i32 {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut next: Ptr<TrieNode> = Default::default();\n    let mut last_next_ptr: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: u8 = Default::default();\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = TRIE_NULL!();\n    } else {\n        return 0;\n    }\n\n    node = trie.root_node;\n    last_next_ptr = c_ref!(trie.root_node);\n    p = key;\n\n    loop {\n        c = (*p);\n        next = node.next[c];\n\n        node.use_count -= 1;\n\n        if (node.use_count <= 0) {\n            c_free!(node);\n\n            if (last_next_ptr != NULL!()) {\n                *last_next_ptr = NULL!();\n                last_next_ptr = NULL!();\n            }\n        }\n\n        if (c == '\\0') {\n            break;\n        } else {\n            p += 1;\n        }\n\n        if (last_next_ptr != NULL!()) {\n            last_next_ptr = c_ref!(node.next[c]);\n        }\n\n        node = next;\n    }\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928875359)\nerror[E0282]: type annotations needed\n   --> src/src/trie_c.rs:267:26\n    |\n267 |             c_free!(node.cast());\n    |                          ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n267 |             c_free!(node.cast::<T>());\n    |                              +++++\n\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:275:18\n    |\n275 |         if (c == '\\0').as_bool() {\n    |             -    ^^^^ expected `u8`, found `char`\n    |             |\n    |             expected because this is `u8`\n    |\nhelp: if you meant to write a byte literal, prefix with `b`\n    |\n275 |         if (c == b'\\0').as_bool() {\n    |                  ~~~~~\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}",
            "rust_code": "pub fn set_allocate_table(mut set: Ptr<Set>) -> i32 {\n    if (set.prime_index < set_num_primes!()) {\n        let tmp0 = set.prime_index;\n        set.table_size = set_primes[tmp0];\n    } else {\n        set.table_size = (set.entries * 10);\n    }\n\n    set.table = c_calloc!(set.table_size, c_sizeof!(Ptr<SetEntry>));\n\n    return (set.table != NULL!()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928881694)\nerror: cannot find macro `set_num_primes` in this scope\n  --> src/src/set_c.rs:36:27\n   |\n36 |     if (set.prime_index < set_num_primes!()).as_bool() {\n   |                           ^^^^^^^^^^^^^^\n   |\n   = note: `set_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int set_insert(Set *set, SetValue data)\n{\n    SetEntry *newentry;\n    SetEntry *rover;\n    unsigned int index;\n\n    if ((set->entries * 3) / set->table_size > 0)\n    {\n\n        if (!set_enlarge(set))\n        {\n            return 0;\n        }\n    }\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 0;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (SetEntry *)malloc(sizeof(SetEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->data = data;\n\n    newentry->next = set->table[index];\n    set->table[index] = newentry;\n\n    ++set->entries;\n\n    return 1;\n}",
            "rust_code": "pub fn set_insert(mut set: Ptr<Set>, mut data: SetValue) -> i32 {\n    let mut newentry: Ptr<SetEntry> = Default::default();\n    let mut rover: Ptr<SetEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    if ((set.entries * 3) / set.table_size > 0) {\n        if !set_enlarge(set).as_bool() {\n            return 0;\n        }\n    }\n\n    index = (set.hash_func(data) % set.table_size);\n\n    rover = set.table[index];\n\n    while (rover != NULL!()) {\n        if (set.equal_func(data, rover.data) != 0) {\n            return 0;\n        }\n\n        rover = rover.next;\n    }\n\n    newentry = c_malloc!(c_sizeof!(SetEntry));\n\n    if (newentry == NULL!()) {\n        return 0;\n    }\n\n    newentry.data = data;\n\n    newentry.next = set.table[index];\n    set.table[index] = newentry;\n\n    set.entries.prefix_plus_plus();\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928894885)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:152:18\n    |\n152 |     index = (set.hash_func(data.cast()) % set.table_size).cast();\n    |                  ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n152 |     index = ((set.hash_func)(data.cast()) % set.table_size).cast();\n    |              +             +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:157:17\n    |\n157 |         if (set.equal_func(data.cast(), rover.data.cast()) != 0).as_bool() {\n    |                 ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n157 |         if ((set.equal_func)(data.cast(), rover.data.cast()) != 0).as_bool() {\n    |             +              +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int set_remove(Set *set, SetValue data)\n{\n    SetEntry **rover;\n    SetEntry *entry;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = &set->table[index];\n\n    while (*rover != NULL)\n    {\n        if (set->equal_func(data, (*rover)->data) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            --set->entries;\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return 0;\n}",
            "rust_code": "pub fn set_remove(mut set: Ptr<Set>, mut data: SetValue) -> i32 {\n    let mut rover: Ptr<Ptr<SetEntry>> = Default::default();\n    let mut entry: Ptr<SetEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    index = (set.hash_func(data) % set.table_size);\n\n    rover = c_ref!(set.table[index]);\n\n    while (*rover != NULL!()) {\n        if (set.equal_func(data, (*rover).data) != 0) {\n\n            entry = *rover;\n\n            *rover = entry.next;\n\n            set.entries.prefix_minus_minus();\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = c_ref!((*rover).next);\n    }\n\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928901415)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:151:18\n    |\n151 |     index = (set.hash_func(data) % set.table_size).cast();\n    |                  ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n151 |     index = ((set.hash_func)(data) % set.table_size).cast();\n    |              +             +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:156:17\n    |\n156 |         if (set.equal_func(data, (*rover).data) != 0).as_bool() {\n    |                 ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n156 |         if ((set.equal_func)(data, (*rover).data) != 0).as_bool() {\n    |             +              +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int set_query(Set *set, SetValue data)\n{\n    SetEntry *rover;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    return 0;\n}",
            "rust_code": "pub fn set_query(mut set: Ptr<Set>, mut data: SetValue) -> i32 {\n    let mut rover: Ptr<SetEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    index = (set.hash_func(data) % set.table_size);\n\n    rover = set.table[index];\n\n    while (rover != NULL!()) {\n        if (set.equal_func(data, rover.data) != 0) {\n            return 1;\n        }\n\n        rover = rover.next;\n    }\n\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928904623)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:155:18\n    |\n155 |     index = (set.hash_func(data) % set.table_size).cast();\n    |                  ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n155 |     index = ((set.hash_func)(data) % set.table_size).cast();\n    |              +             +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:160:17\n    |\n160 |         if (set.equal_func(data, rover.data) != 0).as_bool() {\n    |                 ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n160 |         if ((set.equal_func)(data, rover.data) != 0).as_bool() {\n    |             +              +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}",
            "rust_code": "pub fn hash_table_allocate_table(mut hash_table: Ptr<HashTable>) -> i32 {\n    let mut new_table_size: u32 = Default::default();\n\n    if (hash_table.prime_index < hash_table_num_primes!()) {\n        let tmp0 = hash_table.prime_index;\n        new_table_size = hash_table_primes[tmp0];\n    } else {\n        new_table_size = (hash_table.entries * 10);\n    }\n\n    hash_table.table_size = new_table_size;\n\n    hash_table.table = c_calloc!(hash_table.table_size, c_sizeof!(Ptr<HashTableEntry>));\n\n    return (hash_table.table != NULL!()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928944369)\nerror: cannot find macro `hash_table_num_primes` in this scope\n  --> src/src/hash_table_c.rs:39:34\n   |\n39 |     if (hash_table.prime_index < hash_table_num_primes!()).as_bool() {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `hash_table_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    unsigned int index;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            return pair->value;\n        }\n\n        rover = rover->next;\n    }\n\n    return HASH_TABLE_NULL;\n}",
            "rust_code": "pub fn hash_table_lookup(mut hash_table: Ptr<HashTable>, mut key: HashTableKey) -> HashTableValue {\n    let mut rover: Ptr<HashTableEntry> = Default::default();\n    let mut pair: Ptr<HashTablePair> = Default::default();\n    let mut index: u32 = Default::default();\n\n    index = (hash_table.hash_func(key) % hash_table.table_size);\n\n    rover = hash_table.table[index];\n\n    while (rover != NULL!()) {\n        pair = c_ref!(rover.pair);\n\n        if (hash_table.equal_func(key, pair.key) != 0 {\n            return pair.value;\n        }\n\n        rover = rover.next;\n    }\n\n    return HASH_TABLE_NULL!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928961787)\nerror: mismatched closing delimiter: `}`\n   --> src/src/hash_table_c.rs:220:12\n    |\n217 |     while (rover != NULL!()).as_bool() {\n    |                                        - closing delimiter possibly meant for this\n...\n220 |         if (hash_table.equal_func(key, pair.key) != 0 {\n    |            ^ unclosed delimiter\n...\n225 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int hash_table_remove(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry **rover;\n    HashTableEntry *entry;\n    HashTablePair *pair;\n    unsigned int index;\n    int result;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    result = 0;\n    rover = &hash_table->table[index];\n\n    while (*rover != NULL)\n    {\n\n        pair = &((*rover)->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            --hash_table->entries;\n\n            result = 1;\n\n            break;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return result;\n}",
            "rust_code": "pub fn hash_table_remove(mut hash_table: Ptr<HashTable>, mut key: HashTableKey) -> i32 {\n    let mut rover: Ptr<Ptr<HashTableEntry>> = Default::default();\n    let mut entry: Ptr<HashTableEntry> = Default::default();\n    let mut pair: Ptr<HashTablePair> = Default::default();\n    let mut index: u32 = Default::default();\n    let mut result: i32 = 0;\n\n    index = (hash_table.hash_func(key) % hash_table.table_size);\n\n    rover = c_ref!(hash_table.table[index]);\n\n    while (*rover != NULL!()) {\n        pair = c_ref!((*rover).pair);\n\n        if (hash_table.equal_func(key, pair.key) != 0) {\n            entry = *rover;\n\n            *rover = entry.next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            hash_table.entries.prefix_minus_minus();\n\n            result = 1;\n\n            break;\n        }\n\n        rover = c_ref!((*rover).next);\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741928962704)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_HashTable>` in the current scope\n   --> src/src/hash_table_c.rs:220:25\n    |\n220 |     index = (hash_table.hash_func(key) % hash_table.table_size).cast();\n    |                         ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n220 |     index = ((hash_table.hash_func)(key) % hash_table.table_size).cast();\n    |              +                    +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_HashTable>` in the current scope\n   --> src/src/hash_table_c.rs:227:24\n    |\n227 |         if (hash_table.equal_func(key, pair.key) != 0).as_bool() {\n    |                        ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n227 |         if ((hash_table.equal_func)(key, pair.key) != 0).as_bool() {\n    |             +                     +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        }
    ]
}