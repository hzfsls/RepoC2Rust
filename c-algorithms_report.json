{
    "All": 200,
    "Compilation Pass": 178,
    "Compilation Error": 22,
    "Pass Rate": 0.89,
    "Error Information": [
        {
            "c_code": "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}",
            "rust_code": "pub fn rb_tree_insert(mut tree: Ptr<RBTree>, mut key: RBTreeKey, mut value: RBTreeValue) -> Ptr<RBTreeNode> {\n    let mut node: Ptr<RBTreeNode>;\n    let mut rover: Ptr<Ptr<RBTreeNode>>;\n    let mut parent: Ptr<RBTreeNode>;\n    let mut side: RBTreeNodeSide;\n\n    node = c_malloc!(c_sizeof!(RBTreeNode));\n\n    if (node == NULL!()) {\n        return NULL!();\n    }\n\n    node.key = key;\n    node.value = value;\n    node.color = RB_TREE_NODE_RED!();\n    node.children[RB_TREE_NODE_LEFT!()] = NULL!();\n    node.children[RB_TREE_NODE_RIGHT!()] = NULL!();\n\n    parent = NULL!();\n    rover = c_ref!(tree.root_node);\n\n    while (*rover != NULL!()) {\n        parent = *rover;\n\n        if (tree.compare_func(value, (*rover).value) < 0) {\n            side = RB_TREE_NODE_LEFT!();\n        } else {\n            side = RB_TREE_NODE_RIGHT!();\n        }\n\n        rover = c_ref!((*rover).children[side]);\n    }\n\n    *rover = node;\n    node.parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898400755)\nerror[E0282]: type annotations needed\n   --> src/src/rb_tree_c.rs:202:25\n    |\n202 |         parent = *rover.cast();\n    |                         ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n202 |         parent = *rover.cast::<T>();\n    |                             +++++\n\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_RBTree>` in the current scope\n   --> src/src/rb_tree_c.rs:204:18\n    |\n204 |         if (tree.compare_func(value.cast(), (*rover).value.cast()) < 0).as_bool() {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n204 |         if ((tree.compare_func)(value.cast(), (*rover).value.cast()) < 0).as_bool() {\n    |             +                 +\n\nSome errors have detailed explanations: E0282, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int arraylist_index_of(ArrayList *arraylist, ArrayListEqualFunc callback, ArrayListValue data)\n{\n    unsigned int i;\n\n    for (i = 0; i < arraylist->length; ++i)\n    {\n        if (callback(arraylist->data[i], data) != 0)\n            return (int)i;\n    }\n\n    return -1;\n}",
            "rust_code": "pub fn arraylist_index_of(mut arraylist: Ptr<ArrayList>, mut callback: ArrayListEqualFunc, mut data: ArrayListValue) -> i32 {\n    let mut i: u32 = 0;\n    c_for!(i = 0; i < arraylist.length; i.prefix_plus_plus(); {\n        if (callback(arraylist.data[i], data) != 0 {\n            return i.cast::<i32>();\n        }\n    });\n    return -1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898412962)\nerror: mismatched closing delimiter: `}`\n   --> src/src/arraylist_c.rs:115:12\n    |\n114 |     c_for!(i = 0; i < arraylist.length; i.prefix_plus_plus(); {\n    |                                                               - closing delimiter possibly meant for this\n115 |         if (callback(arraylist.data[i].cast(), data.cast()) != 0 {\n    |            ^ unclosed delimiter\n...\n118 |     });\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int string_nocase_compare(void *string1, void *string2)\n{\n    char *p1;\n    char *p2;\n    int c1, c2;\n\n    p1 = (char *)string1;\n    p2 = (char *)string2;\n\n    for (;;)\n    {\n\n        c1 = tolower(*p1);\n        c2 = tolower(*p2);\n\n        if (c1 != c2)\n        {\n\n            if (c1 < c2)\n            {\n                return -1;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n\n        if (c1 == '\\0')\n            break;\n\n        ++p1;\n        ++p2;\n    }\n\n    return 0;\n}",
            "rust_code": "pub fn string_nocase_compare(mut string1: Ptr<Void>, mut string2: Ptr<Void>) -> i32 {\n    let mut p1: Ptr<u8> = string1.cast::<Ptr<u8>>();\n    let mut p2: Ptr<u8> = string2.cast::<Ptr<u8>>();\n    let mut c1: i32 = Default::default();\n    let mut c2: i32 = Default::default();\n\n    loop {\n        c1 = c_tolower!(*p1);\n        c2 = c_tolower!(*p2);\n\n        if c1 != c2 {\n            if c1 < c2 {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        if c1 == '\\0' {\n            break;\n        }\n\n        p1 = p1 + 1;\n        p2 = p2 + 1;\n    }\n\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898428504)\nerror[E0308]: mismatched types\n  --> src/src/compare_string_c.rs:47:18\n   |\n47 |         if c1 == '\\0' {\n   |            --    ^^^^ expected `i32`, found `char`\n   |            |\n   |            expected because this is `i32`\n   |\nhelp: you can cast a `char` to an `i32`, since a `char` always occupies 4 bytes\n   |\n47 |         if c1 == '\\0' as i32 {\n   |                       ++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *child;\n    int diff;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2)\n    {\n\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]))\n        {\n\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);\n    }\n    else if (diff <= -2)\n    {\n\n        child = node->children[AVL_TREE_NODE_LEFT];\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]))\n        {\n\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}",
            "rust_code": "pub fn avl_tree_node_balance(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) -> Ptr<AVLTreeNode> {\n    let mut left_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut right_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut child: Ptr<AVLTreeNode> = Default::default();\n    let mut diff: i32 = Default::default();\n\n    left_subtree = node.children[AVL_TREE_NODE_LEFT!()];\n    right_subtree = node.children[AVL_TREE_NODE_RIGHT!()];\n\n    diff = (avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree));\n\n    if (diff >= 2) {\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()]) <\n            (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()])) {\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT!());\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT!());\n    } else if (diff <= -2) {\n        child = node.children[AVL_TREE_NODE_LEFT!()];\n\n        if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()]) <\n            (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()])) {\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT!());\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT!());\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898434117)\nerror: mismatched closing delimiter: `}`\n   --> src/src/avl_tree_c.rs:149:12\n    |\n146 |     if (diff >= 2).as_bool() {\n    |                              - closing delimiter possibly meant for this\n...\n149 |         if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()].cast()) <\n    |            ^ unclosed delimiter\n...\n155 |     } else if (diff <= -2).as_bool() {\n    |     ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/avl_tree_c.rs:158:12\n    |\n155 |     } else if (diff <= -2).as_bool() {\n    |                                      - closing delimiter possibly meant for this\n...\n158 |         if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()].cast()) <\n    |            ^ unclosed delimiter\n...\n164 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}",
            "rust_code": "pub fn avl_tree_insert(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey, mut value: AVLTreeValue) -> Ptr<AVLTreeNode> {\n    let mut rover: Ptr<Ptr<AVLTreeNode>> = Default::default();\n    let mut new_node: Ptr<AVLTreeNode> = Default::default();\n    let mut previous_node: Ptr<AVLTreeNode> = Default::default();\n\n    rover = c_ref!(tree.root_node);\n    previous_node = NULL!();\n\n    while (*rover != NULL!()) {\n        previous_node = *rover;\n        if (tree.compare_func(key, (*rover).key) < 0 {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_LEFT!()]);\n        } else {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_RIGHT!()]);\n        }\n    }\n\n    new_node = c_malloc!(c_sizeof!(AVLTreeNode));\n\n    if (new_node == NULL!()) {\n        return NULL!();\n    }\n\n    new_node.children[AVL_TREE_NODE_LEFT!()] = NULL!();\n    new_node.children[AVL_TREE_NODE_RIGHT!()] = NULL!();\n    new_node.parent = previous_node;\n    new_node.key = key;\n    new_node.value = value;\n    new_node.height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return new_node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898436761)\nerror: mismatched closing delimiter: `}`\n   --> src/src/avl_tree_c.rs:160:12\n    |\n158 |     while (*rover != NULL!()).as_bool() {\n    |                                         - closing delimiter possibly meant for this\n159 |         previous_node = *rover;\n160 |         if (tree.compare_func(key.cast(), (*rover).key.cast()) < 0 {\n    |            ^ unclosed delimiter\n...\n165 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}",
            "rust_code": "pub fn bloom_filter_new(mut table_size: u32, mut hash_func: BloomFilterHashFunc, mut num_functions: u32) -> Ptr<BloomFilter> {\n    let mut filter: Ptr<BloomFilter> = Default::default();\n\n    if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts)) {\n        return NULL!();\n    }\n\n    filter = c_malloc!(c_sizeof!(BloomFilter));\n\n    if (filter == NULL!()) {\n        return NULL!();\n    }\n\n    filter.table = c_calloc!((table_size + 7) / 8, 1);\n\n    if (filter.table == NULL!()) {\n        c_free!(filter);\n        return NULL!();\n    }\n\n    filter.hash_func = hash_func;\n    filter.num_functions = num_functions;\n    filter.table_size = table_size;\n\n    return filter;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898464800)\nerror: mismatched closing delimiter: `}`\n  --> src/src/bloom_filter_c.rs:29:8\n   |\n26 | pub fn bloom_filter_new(mut table_size: u32, mut hash_func: BloomFilterHashFunc, mut num_functions: u32) -> Ptr<BloomFilter> {\n   |                                                                                                                              - closing delimiter possibly meant for this\n...\n29 |     if (num_functions > (c_sizeof!(salts) / c_sizeof!(*salts)).as_bool() {\n   |        ^ unclosed delimiter\n...\n51 | }\n   | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "unsigned int string_hash(void *string)\n{\n\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + *p;\n        ++p;\n    }\n\n    return result;\n}",
            "rust_code": "pub fn string_hash(mut string: Ptr<Void>) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p: Ptr<u8> = string.cast::<Ptr<u8>>();\n\n    while (*p != '\\0') {\n        result = (result << 5) + result + (*p).cast::<u32>();\n        p = p + 1;\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898473608)\nerror[E0308]: mismatched types\n --> src/src/hash_string_c.rs:8:18\n  |\n8 |     while (*p != '\\0').as_bool() {\n  |            --    ^^^^ expected `u8`, found `char`\n  |            |\n  |            expected because this is `u8`\n  |\nhelp: if you meant to write a byte literal, prefix with `b`\n  |\n8 |     while (*p != b'\\0').as_bool() {\n  |                  ~~~~~\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "unsigned int string_nocase_hash(void *string)\n{\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + (unsigned int)tolower(*p);\n        ++p;\n    }\n\n    return result;\n}",
            "rust_code": "pub fn string_nocase_hash(mut string: Ptr<Void>) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p: Ptr<u8> = string.cast::<Ptr<u8>>();\n\n    while (*p != '\\0') {\n        result = (result << 5) + result + c_tolower!(*p).cast::<u32>();\n        p += 1;\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898475643)\nerror[E0308]: mismatched types\n  --> src/src/hash_string_c.rs:13:18\n   |\n13 |     while (*p != '\\0').as_bool() {\n   |            --    ^^^^ expected `u8`, found `char`\n   |            |\n   |            expected because this is `u8`\n   |\nhelp: if you meant to write a byte literal, prefix with `b`\n   |\n13 |     while (*p != b'\\0').as_bool() {\n   |                  ~~~~~\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static void trie_free_list_push(TrieNode **list, TrieNode *node)\n{\n    node->data = *list;\n    *list = node;\n}",
            "rust_code": "pub fn trie_free_list_push(mut list: Ptr<Ptr<TrieNode>>, mut node: Ptr<TrieNode>) {\n    node.data = *list;\n    *list = node;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898477952)\nerror[E0308]: mismatched types\n  --> src/src/trie_c.rs:37:17\n   |\n37 |     node.data = *list;\n   |     ---------   ^^^^^ expected `Ptr<u8>`, found `Ptr<_TrieNode>`\n   |     |\n   |     expected due to the type of this binding\n   |\n   = note: expected struct `memory::ptr::Ptr<u8>`\n              found struct `memory::ptr::Ptr<_TrieNode>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
            "rust_code": "pub fn trie_insert(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()) {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = value;\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node);\n    p = key;\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()) {\n            node = c_calloc!(1, c_sizeof!(TrieNode)).cast::<Ptr<TrieNode>>();\n\n            if (node == NULL!()) {\n                trie_insert_rollback(trie, key.cast::<Ptr<u8>>());\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node;\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = (*p).cast::<u8>().cast::<i32>();\n\n        if (c == '\\0' as i32) {\n            node.data = value;\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]);\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898480789)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/c_alignment/libraries/c_calloc.rs:8:9\n    |\n8   |         calloc($count.cast(), $size.cast()).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/trie_c.rs:173:20\n    |\n173 |             node = c_calloc!(1, c_sizeof!(TrieNode)).cast::<Ptr<TrieNode>>();\n    |                    --------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `c_calloc` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `(): CastInto<{type error}>` is not satisfied\n   --> src/src/trie_c.rs:176:74\n    |\n176 |                 trie_insert_rollback(trie.cast(), key.cast::<Ptr<u8>>()).cast();\n    |                                                                          ^^^^ the trait `integer::Integer` is not implemented for `()`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<()>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `()` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int trie_insert_binary(Trie *trie, unsigned char *key, int key_length, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    int p, c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)key[p];\n\n        if (p == key_length)\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
            "rust_code": "pub fn trie_insert_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: i32 = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()) {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = value;\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node);\n    p = 0;\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()) {\n            node = c_calloc!(1, c_sizeof!(TrieNode)).cast::<Ptr<TrieNode>>();\n\n            if (node == NULL!()) {\n                trie_insert_rollback(trie, key);\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n            *rover = node;\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = key[p].cast::<u8>().cast::<i32>();\n\n        if (p == key_length) {\n            node.data = value;\n            break;\n        }\n\n        rover = c_ref!(node.next[c]);\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898486428)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/c_alignment/libraries/c_calloc.rs:8:9\n    |\n8   |         calloc($count.cast(), $size.cast()).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/trie_c.rs:178:20\n    |\n178 |             node = c_calloc!(1, c_sizeof!(TrieNode)).cast::<Ptr<TrieNode>>();\n    |                    --------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `c_calloc` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int trie_remove(Trie *trie, char *key)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    char *p;\n    int c;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        c = (unsigned char)*p;\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (c == '\\0')\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}",
            "rust_code": "pub fn trie_remove(mut trie: Ptr<Trie>, mut key: Ptr<u8>) -> i32 {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut next: Ptr<TrieNode> = Default::default();\n    let mut last_next_ptr: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: u8 = Default::default();\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = TRIE_NULL!();\n    } else {\n        return 0;\n    }\n\n    node = trie.root_node;\n    last_next_ptr = c_ref!(trie.root_node);\n    p = key;\n\n    loop {\n        c = (*p);\n        next = node.next[c];\n\n        node.use_count -= 1;\n\n        if (node.use_count <= 0) {\n            c_free!(node);\n\n            if (last_next_ptr != NULL!()) {\n                *last_next_ptr = NULL!();\n                last_next_ptr = NULL!();\n            }\n        }\n\n        if (c == '\\0') {\n            break;\n        } else {\n            p += 1;\n        }\n\n        if (last_next_ptr != NULL!()) {\n            last_next_ptr = c_ref!(node.next[c]);\n        }\n\n        node = next;\n    }\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898492137)\nerror[E0282]: type annotations needed\n   --> src/src/trie_c.rs:236:26\n    |\n236 |             c_free!(node.cast());\n    |                          ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n236 |             c_free!(node.cast::<T>());\n    |                              +++++\n\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:244:18\n    |\n244 |         if (c == '\\0').as_bool() {\n    |             -    ^^^^ expected `u8`, found `char`\n    |             |\n    |             expected because this is `u8`\n    |\nhelp: if you meant to write a byte literal, prefix with `b`\n    |\n244 |         if (c == b'\\0').as_bool() {\n    |                  ~~~~~\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}",
            "rust_code": "pub fn set_allocate_table(mut set: Ptr<Set>) -> i32 {\n    if (set.prime_index < set_num_primes!()) {\n        let tmp0 = set.prime_index;\n        set.table_size = set_primes[tmp0];\n    } else {\n        set.table_size = (set.entries * 10);\n    }\n\n    set.table = c_calloc!(set.table_size, c_sizeof!(Ptr<SetEntry>));\n\n    return (set.table != NULL!()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898499791)\nerror: cannot find macro `set_num_primes` in this scope\n  --> src/src/set_c.rs:36:27\n   |\n36 |     if (set.prime_index < set_num_primes!()).as_bool() {\n   |                           ^^^^^^^^^^^^^^\n   |\n   = note: `set_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int set_insert(Set *set, SetValue data)\n{\n    SetEntry *newentry;\n    SetEntry *rover;\n    unsigned int index;\n\n    if ((set->entries * 3) / set->table_size > 0)\n    {\n\n        if (!set_enlarge(set))\n        {\n            return 0;\n        }\n    }\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 0;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (SetEntry *)malloc(sizeof(SetEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->data = data;\n\n    newentry->next = set->table[index];\n    set->table[index] = newentry;\n\n    ++set->entries;\n\n    return 1;\n}",
            "rust_code": "pub fn set_insert(mut set: Ptr<Set>, mut data: SetValue) -> i32 {\n    let mut newentry: Ptr<SetEntry> = Default::default();\n    let mut rover: Ptr<SetEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    if ((set.entries * 3) / set.table_size > 0) {\n        if !set_enlarge(set).as_bool() {\n            return 0;\n        }\n    }\n\n    index = (set.hash_func(data) % set.table_size);\n\n    rover = set.table[index];\n\n    while (rover != NULL!()) {\n        if (set.equal_func(data, rover.data) != 0) {\n            return 0;\n        }\n\n        rover = rover.next;\n    }\n\n    newentry = c_malloc!(c_sizeof!(SetEntry));\n\n    if (newentry == NULL!()) {\n        return 0;\n    }\n\n    newentry.data = data;\n\n    newentry.next = set.table[index];\n    set.table[index] = newentry;\n\n    set.entries.prefix_plus_plus();\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898512417)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:152:18\n    |\n152 |     index = (set.hash_func(data.cast()) % set.table_size).cast();\n    |                  ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n152 |     index = ((set.hash_func)(data.cast()) % set.table_size).cast();\n    |              +             +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:157:17\n    |\n157 |         if (set.equal_func(data.cast(), rover.data.cast()) != 0).as_bool() {\n    |                 ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n157 |         if ((set.equal_func)(data.cast(), rover.data.cast()) != 0).as_bool() {\n    |             +              +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int set_remove(Set *set, SetValue data)\n{\n    SetEntry **rover;\n    SetEntry *entry;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = &set->table[index];\n\n    while (*rover != NULL)\n    {\n        if (set->equal_func(data, (*rover)->data) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            --set->entries;\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return 0;\n}",
            "rust_code": "pub fn set_remove(mut set: Ptr<Set>, mut data: SetValue) -> i32 {\n    let mut rover: Ptr<Ptr<SetEntry>> = Default::default();\n    let mut entry: Ptr<SetEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    index = (set.hash_func(data) % set.table_size);\n\n    rover = c_ref!(set.table[index]);\n\n    while (*rover != NULL!()) {\n        if (set.equal_func(data, (*rover).data) != 0) {\n\n            entry = *rover;\n\n            *rover = entry.next;\n\n            set.entries -= 1;\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = c_ref!((*rover).next);\n    }\n\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898518478)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:151:18\n    |\n151 |     index = (set.hash_func(data) % set.table_size).cast();\n    |                  ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n151 |     index = ((set.hash_func)(data) % set.table_size).cast();\n    |              +             +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:156:17\n    |\n156 |         if (set.equal_func(data, (*rover).data) != 0).as_bool() {\n    |                 ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n156 |         if ((set.equal_func)(data, (*rover).data) != 0).as_bool() {\n    |             +              +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int set_query(Set *set, SetValue data)\n{\n    SetEntry *rover;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    return 0;\n}",
            "rust_code": "pub fn set_query(mut set: Ptr<Set>, mut data: SetValue) -> i32 {\n    let mut rover: Ptr<SetEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    index = (set.hash_func(data) % set.table_size);\n\n    rover = set.table[index];\n\n    while (rover != NULL!()) {\n        if (set.equal_func(data, rover.data) != 0) {\n            return 1;\n        }\n\n        rover = rover.next;\n    }\n\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898521390)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:155:18\n    |\n155 |     index = (set.hash_func(data) % set.table_size).cast();\n    |                  ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n155 |     index = ((set.hash_func)(data) % set.table_size).cast();\n    |              +             +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_Set>` in the current scope\n   --> src/src/set_c.rs:160:17\n    |\n160 |         if (set.equal_func(data, rover.data) != 0).as_bool() {\n    |                 ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n160 |         if ((set.equal_func)(data, rover.data) != 0).as_bool() {\n    |             +              +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "Set *set_union(Set *set1, Set *set2)\n{\n    SetIterator iterator;\n    Set *new_set;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set1->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (!set_insert(new_set, value))\n        {\n\n            set_free(new_set);\n            return NULL;\n        }\n    }\n\n    set_iterate(set2, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(new_set, value) == 0)\n        {\n            if (!set_insert(new_set, value))\n            {\n\n                set_free(new_set);\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}",
            "rust_code": "pub fn set_union(mut set1: Ptr<Set>, mut set2: Ptr<Set>) -> Ptr<Set> {\n    let mut iterator: SetIterator = Default::default();\n    let mut new_set: Ptr<Set> = Default::default();\n    let mut value: SetValue = Default::default();\n\n    new_set = set_new(set1.hash_func, set1.equal_func);\n\n    if (new_set == NULL!()) {\n        return NULL!();\n    }\n\n    set_iterate(set1, c_ref!(iterator));\n\n    while (set_iter_has_more(c_ref!(iterator)) {\n        value = set_iter_next(c_ref!(iterator));\n\n        if !set_insert(new_set, value) {\n            set_free(new_set);\n            return NULL!();\n        }\n    }\n\n    set_iterate(set2, c_ref!(iterator));\n\n    while (set_iter_has_more(c_ref!(iterator)) {\n        value = set_iter_next(c_ref!(iterator));\n\n        if (set_query(new_set, value) == 0) {\n            if !set_insert(new_set, value) {\n                set_free(new_set);\n                return NULL!();\n            }\n        }\n    }\n\n    return new_set;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898524774)\nerror: mismatched closing delimiter: `}`\n   --> src/src/set_c.rs:214:11\n    |\n190 | pub fn set_union(mut set1: Ptr<Set>, mut set2: Ptr<Set>) -> Ptr<Set> {\n    |                                                                      - closing delimiter possibly meant for this\n...\n214 |     while (set_iter_has_more(c_ref!(iterator).cast()).as_bool() {\n    |           ^ unclosed delimiter\n...\n226 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "BinaryHeapValue binary_heap_pop(BinaryHeap *heap)\n{\n    BinaryHeapValue result;\n    BinaryHeapValue new_value;\n    unsigned int index;\n    unsigned int next_index;\n    unsigned int child1, child2;\n\n    if (heap->num_values == 0)\n    {\n        return BINARY_HEAP_NULL;\n    }\n\n    result = heap->values[0];\n\n    new_value = heap->values[heap->num_values - 1];\n    --heap->num_values;\n\n    index = 0;\n\n    for (;;)\n    {\n\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child1]) > 0)\n        {\n\n            if (child2 < heap->num_values && binary_heap_cmp(heap, heap->values[child1], heap->values[child2]) > 0)\n            {\n                next_index = child2;\n            }\n            else\n            {\n                next_index = child1;\n            }\n        }\n        else if (child2 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child2]) > 0)\n        {\n\n            next_index = child2;\n        }\n        else\n        {\n\n            heap->values[index] = new_value;\n            break;\n        }\n\n        heap->values[index] = heap->values[next_index];\n\n        index = next_index;\n    }\n\n    return result;\n}",
            "rust_code": "pub fn binary_heap_pop(mut heap: Ptr<BinaryHeap>) -> BinaryHeapValue {\n    let mut result: BinaryHeapValue = Default::default();\n    let mut new_value: BinaryHeapValue = Default::default();\n    let mut index: u32 = Default::default();\n    let mut next_index: u32 = Default::default();\n    let mut child1: u32 = Default::default();\n    let mut child2: u32 = Default::default();\n\n    if (heap.num_values == 0) {\n        return BINARY_HEAP_NULL!();\n    }\n\n    result = heap.values[0];\n\n    let tmp0 = heap.num_values - 1;\n    new_value = heap.values[tmp0];\n    heap.num_values -= 1;\n\n    index = 0;\n\n    loop {\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap.num_values) && (binary_heap_cmp(heap, new_value, heap.values[child1]) > 0) {\n            if (child2 < heap.num_values) && (binary_heap_cmp(heap, heap.values[child1], heap.values[child2]) > 0 {\n                next_index = child2;\n            } else {\n                next_index = child1;\n            }\n        } else if (child2 < heap.num_values) && (binary_heap_cmp(heap, new_value, heap.values[child2]) > 0 {\n            next_index = child2;\n        } else {\n            heap.values[index] = new_value;\n            break;\n        }\n\n        heap.values[index] = heap.values[next_index];\n\n        index = next_index;\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898531338)\nerror: mismatched closing delimiter: `}`\n   --> src/src/binary_heap_c.rs:114:56\n    |\n113 | ...   if (child1 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), new_value.cast(), heap.values[child1].cast()) > 0).as_bool() {\n    |                                                                                                                                             - closing delimiter possibly meant for this\n114 | ...       if (child2 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), heap.values[child1].cast(), heap.values[child2].cast()) > ...\n    |                                                      ^ unclosed delimiter\n...\n119 | ...   } else if (child2 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), new_value.cast(), heap.values[child2].cast()) > 0 {\n    |       ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `}`\n   --> src/src/binary_heap_c.rs:119:59\n    |\n109 |     loop {\n    |          - closing delimiter possibly meant for this\n...\n119 |         } else if (child2 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), new_value.cast(), heap.values[child2].cast()) > 0 {\n    |                                                           ^ unclosed delimiter\n...\n129 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}",
            "rust_code": "pub fn hash_table_allocate_table(mut hash_table: Ptr<HashTable>) -> i32 {\n    let mut new_table_size: u32 = Default::default();\n\n    if (hash_table.prime_index < hash_table_num_primes!()) {\n        let tmp0 = hash_table.prime_index;\n        new_table_size = hash_table_primes[tmp0];\n    } else {\n        new_table_size = (hash_table.entries * 10);\n    }\n\n    hash_table.table_size = new_table_size;\n\n    hash_table.table = c_calloc!(hash_table.table_size, c_sizeof!(Ptr<HashTableEntry>));\n\n    return (hash_table.table != NULL!()).cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898558011)\nerror: cannot find macro `hash_table_num_primes` in this scope\n  --> src/src/hash_table_c.rs:39:34\n   |\n39 |     if (hash_table.prime_index < hash_table_num_primes!()).as_bool() {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `hash_table_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int hash_table_insert(HashTable *hash_table, HashTableKey key, HashTableValue value)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *newentry;\n    unsigned int index;\n\n    if ((hash_table->entries * 3) / hash_table->table_size > 0)\n    {\n\n        if (!hash_table_enlarge(hash_table))\n        {\n\n            return 0;\n        }\n    }\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(pair->key, key) != 0)\n        {\n\n            if (hash_table->value_free_func != NULL)\n            {\n                hash_table->value_free_func(pair->value);\n            }\n\n            if (hash_table->key_free_func != NULL)\n            {\n                hash_table->key_free_func(pair->key);\n            }\n\n            pair->key = key;\n            pair->value = value;\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (HashTableEntry *)malloc(sizeof(HashTableEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->pair.key = key;\n    newentry->pair.value = value;\n\n    newentry->next = hash_table->table[index];\n    hash_table->table[index] = newentry;\n\n    ++hash_table->entries;\n\n    return 1;\n}",
            "rust_code": "pub fn hash_table_insert(mut hash_table: Ptr<HashTable>, mut key: HashTableKey, mut value: HashTableValue) -> i32 {\n    let mut rover: Ptr<HashTableEntry> = Default::default();\n    let mut pair: Ptr<HashTablePair> = Default::default();\n    let mut newentry: Ptr<HashTableEntry> = Default::default();\n    let mut index: u32 = Default::default();\n\n    if ((hash_table.entries * 3) / hash_table.table_size > 0) {\n        if !hash_table_enlarge(hash_table) {\n            return 0;\n        }\n    }\n\n    index = (hash_table.hash_func)(key) % hash_table.table_size;\n    rover = hash_table.table[index];\n\n    while (rover != NULL!()) {\n        pair = c_ref!(rover.pair);\n\n        if (hash_table.equal_func)(pair.key, key) != 0 {\n            if (hash_table.value_free_func != NULL!()) {\n                (hash_table.value_free_func)(pair.value);\n            }\n\n            if (hash_table.key_free_func != NULL!()) {\n                (hash_table.key_free_func)(pair.key);\n            }\n\n            pair.key = key;\n            pair.value = value;\n\n            return 1;\n        }\n\n        rover = rover.next;\n    }\n\n    newentry = c_malloc!(c_sizeof!(HashTableEntry)).cast::<Ptr<HashTableEntry>>();\n\n    if (newentry == NULL!()) {\n        return 0;\n    }\n\n    newentry.pair.key = key;\n    newentry.pair.value = value;\n\n    newentry.next = hash_table.table[index];\n    hash_table.table[index] = newentry;\n\n    hash_table.entries.prefix_plus_plus();\n\n    return 1;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898567850)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/c_alignment/libraries/c_malloc.rs:22:9\n    |\n22  |         malloc($size.cast()).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/hash_table_c.rs:189:16\n    |\n189 |     newentry = c_malloc!(c_sizeof!(HashTableEntry)).cast::<Ptr<HashTableEntry>>();\n    |                ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `c_malloc` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    unsigned int index;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            return pair->value;\n        }\n\n        rover = rover->next;\n    }\n\n    return HASH_TABLE_NULL;\n}",
            "rust_code": "pub fn hash_table_lookup(mut hash_table: Ptr<HashTable>, mut key: HashTableKey) -> HashTableValue {\n    let mut rover: Ptr<HashTableEntry> = Default::default();\n    let mut pair: Ptr<HashTablePair> = Default::default();\n    let mut index: u32 = Default::default();\n\n    index = (hash_table.hash_func(key) % hash_table.table_size);\n\n    rover = hash_table.table[index];\n\n    while (rover != NULL!()) {\n        pair = c_ref!(rover.pair);\n\n        if (hash_table.equal_func(key, pair.key) != 0) {\n            return pair.value;\n        }\n\n        rover = rover.next;\n    }\n\n    return HASH_TABLE_NULL!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898575263)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_HashTable>` in the current scope\n   --> src/src/hash_table_c.rs:163:25\n    |\n163 |     index = (hash_table.hash_func(key) % hash_table.table_size).cast();\n    |                         ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n163 |     index = ((hash_table.hash_func)(key) % hash_table.table_size).cast();\n    |              +                    +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_HashTable>` in the current scope\n   --> src/src/hash_table_c.rs:170:24\n    |\n170 |         if (hash_table.equal_func(key, pair.key) != 0).as_bool() {\n    |                        ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n170 |         if ((hash_table.equal_func)(key, pair.key) != 0).as_bool() {\n    |             +                     +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int hash_table_remove(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry **rover;\n    HashTableEntry *entry;\n    HashTablePair *pair;\n    unsigned int index;\n    int result;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    result = 0;\n    rover = &hash_table->table[index];\n\n    while (*rover != NULL)\n    {\n\n        pair = &((*rover)->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            --hash_table->entries;\n\n            result = 1;\n\n            break;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return result;\n}",
            "rust_code": "pub fn hash_table_remove(mut hash_table: Ptr<HashTable>, mut key: HashTableKey) -> i32 {\n    let mut rover: Ptr<Ptr<HashTableEntry>> = Default::default();\n    let mut entry: Ptr<HashTableEntry> = Default::default();\n    let mut pair: Ptr<HashTablePair> = Default::default();\n    let mut index: u32 = Default::default();\n    let mut result: i32 = 0;\n\n    index = (hash_table.hash_func(key) % hash_table.table_size);\n\n    rover = c_ref!(hash_table.table[index]);\n\n    while (*rover != NULL!()) {\n        pair = c_ref!((*rover).pair);\n\n        if (hash_table.equal_func(key, pair.key) != 0) {\n            entry = *rover;\n\n            *rover = entry.next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            hash_table.entries -= 1;\n\n            result = 1;\n\n            break;\n        }\n\n        rover = c_ref!((*rover).next);\n    }\n\n    return result;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/c-algorithms_1741898579042)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_HashTable>` in the current scope\n   --> src/src/hash_table_c.rs:170:25\n    |\n170 |     index = (hash_table.hash_func(key) % hash_table.table_size).cast();\n    |                         ^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `hash_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n    |\n170 |     index = ((hash_table.hash_func)(key) % hash_table.table_size).cast();\n    |              +                    +\n\nerror[E0599]: no method named `equal_func` found for struct `memory::ptr::Ptr<_HashTable>` in the current scope\n   --> src/src/hash_table_c.rs:177:24\n    |\n177 |         if (hash_table.equal_func(key, pair.key) != 0).as_bool() {\n    |                        ^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `equal_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `equal_func`, surround the field access with parentheses\n    |\n177 |         if ((hash_table.equal_func)(key, pair.key) != 0).as_bool() {\n    |             +                     +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        }
    ]
}