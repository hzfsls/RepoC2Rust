{
    "All": 128,
    "Compilation Pass": 66,
    "Compilation Error": 62,
    "Pass Rate": 0.515625,
    "Error Information": [
        {
            "c_code": "static inline int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                                      EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n\n    decCtx->remainLen = 0;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecCtxPrepare(mut decCtx: Ptr<CmptLzDecCtx>, mut pSrcIn: Ptr<u8>, mut srcInLen: usize, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut readCodeLen: usize = CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize;\n    readCodeLen = if srcInLen < readCodeLen { srcInLen } else { readCodeLen };\n    while (readCodeLen > 0) {\n        let tmp0 = decCtx.tempBufSize;\n        decCtx.tempBuf[tmp0] = *pSrcIn;\n        decCtx.tempBufSize += 1;\n        pSrcIn += 1;\n        readCodeLen -= 1;\n    }\n\n    if (decCtx.tempBufSize != 0) && (decCtx.tempBuf[0] != 0) {\n        decCtx.tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n        return CMPT_ERROR_DATA!();\n    }\n    if (decCtx.tempBufSize < CMPTLZ_RANGE_CODE_SIZE!()) {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    CmptLzRangeCodeInit(decCtx);\n\n    if (decCtx.remainLen > CMPTLZ_MATCH_MAX_LEN!() + 1) {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx.reps[0] = 1;\n        decCtx.reps[1] = 1;\n        decCtx.reps[2] = 1;\n        decCtx.reps[3] = 1;\n    }\n\n    decCtx.remainLen = 0;\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608494728)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_c.rs:60:34\n   |\n60 |     let mut readCodeLen: usize = CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize;\n   |                          -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |                          |\n   |                          expected due to this\n   |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n60 |     let mut readCodeLen: usize = (CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize).try_into().unwrap();\n   |                                  +                                              +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}",
            "rust_code": "pub fn CmptLzDecDecodeToDic(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut pSrcIn: Ptr<u8>, mut pStrInLen: Ptr<usize>, mut finMode: EnCmptLzFinMode, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut res: i32;\n    let mut carefulDecDone: bool = false;\n    let mut srcDecLenTmp: usize;\n    let mut srcDecLen: usize = 0;\n    let mut srcInLen: usize = *pStrInLen;\n\n    if (decCtx.remainLen > CMPTLZ_MATCH_MAX_LEN!()) {\n        let mut oldTempBufSize: usize = decCtx.tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize);\n        if (res != CMPT_OK!()) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT!()) {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx.tempBufSize = 0;\n    }\n\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) {\n        if (decCtx.code != 0) {\n            return CMPT_ERROR_DATA!();\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n\n    if (decCtx.remainLen != 0) {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n\n    if (decCtx.tempBufSize != 0) {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, c_ref!(srcDecLenTmp));\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA!()) {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n            return CMPT_ERROR_DATA!();\n        } else if (res == CMPTLZ_DEC_INPUT_EOF!()) {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n            return CMPT_OK!();\n        } else {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while (decCtx.dictPos < dicPosLimit) && (carefulDecDone == false) {\n        decCtx.buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX!()) {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, (pSrcIn + srcInLen));\n            carefulDecDone = true;\n        } else {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, (pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX!()));\n        }\n        srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA!()) {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n            return CMPT_ERROR_DATA!();\n        }\n    }\n\n    *pStrInLen = srcDecLen;\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) && (decCtx.code == 0) {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n    if (decCtx.dictPos < dicPosLimit) {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen == 0) && (decCtx.code == 0) {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK!();\n        return CMPT_OK!();\n    }\n    if (finMode == CMPTLZ_FINISH_ANY!()) {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen != 0) {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n        return CMPT_ERROR_DATA!();\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, c_ref!(srcDecLenTmp));\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF!()) {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) && (decCtx.code == 0) {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n    return CMPT_ERROR_DATA!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608497664)\nerror[E0659]: `CMPTLZ_REQUIRED_INPUT_MAX` is ambiguous\n   --> src/src/decode/cmptlz_dec_c.rs:115:25\n    |\n115 |         if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX!()).as_bool() {\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ ambiguous name\n    |\n    = note: ambiguous because of multiple glob imports of a name in the same module\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:2:9\n    |\n2   | pub use crate::src::decode::cmptlz_dec_inner_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could also refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:3:9\n    |\n3   | pub use crate::src::public::cmptlz_log_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\n\nerror[E0659]: `CMPTLZ_REQUIRED_INPUT_MAX` is ambiguous\n   --> src/src/decode/cmptlz_dec_c.rs:119:98\n    |\n119 | ...   res = CmptLzDecDirectProcess(decCtx.cast(), dicPosLimit.cast(), (pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX!()).cast()).cast();\n    |                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ ambiguous name\n    |\n    = note: ambiguous because of multiple glob imports of a name in the same module\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:2:9\n    |\n2   | pub use crate::src::decode::cmptlz_dec_inner_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\nnote: `CMPTLZ_REQUIRED_INPUT_MAX` could also refer to the macro imported here\n   --> src/src/decode/cmptlz_dec_c.rs:3:9\n    |\n3   | pub use crate::src::public::cmptlz_log_h::*;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider adding an explicit import of `CMPTLZ_REQUIRED_INPUT_MAX` to disambiguate\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_c.rs:72:41\n   |\n72 |         let mut oldTempBufSize: usize = decCtx.tempBufSize;\n   |                                 -----   ^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |                                 |\n   |                                 expected due to this\n   |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n72 |         let mut oldTempBufSize: usize = decCtx.tempBufSize.try_into().unwrap();\n   |                                                           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_c.rs:74:46\n   |\n74 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize);\n   |                                              ^^^^^^^^^^^^^^ expected `u32`, found `usize`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_c.rs:74:24\n   |\n67 |     let mut srcDecLenTmp: usize;\n   |                           ----- expected due to this type\n...\n74 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `usize` from `u32`\n  --> src/src/decode/cmptlz_dec_c.rs:74:44\n   |\n74 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize);\n   |                                            ^ no implementation for `u32 - usize`\n   |\n   = help: the trait `std::ops::Sub<usize>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n             `&u32` implements `std::ops::Sub<u32>`\n             `&u32` implements `std::ops::Sub`\n             `u32` implements `std::ops::Sub<&u32>`\n             `u32` implements `std::ops::Sub<types::num::Num>`\n             `u32` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_c.rs:121:64\n    |\n121 |         srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n    |                                                                ^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot add `u32` to `usize`\n   --> src/src/decode/cmptlz_dec_c.rs:121:62\n    |\n121 |         srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n    |                                                              ^ no implementation for `usize + u32`\n    |\n    = help: the trait `std::ops::Add<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Add<Rhs>`:\n              `&usize` implements `std::ops::Add<usize>`\n              `&usize` implements `std::ops::Add`\n              `usize` implements `std::ops::Add<&usize>`\n              `usize` implements `std::ops::Add<types::num::Num>`\n              `usize` implements `std::ops::Add`\n\nSome errors have detailed explanations: E0277, E0308, E0659.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
        },
        {
            "c_code": "int CmptlzDecompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzDecParam *param)\n{\n    if (src == NULL || dst == NULL || dstSize == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The input parameter NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"dstSize:0x%zx srcSize:0x%zx\", *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (param == NULL || param->memHook == NULL || param->protData == NULL || param->protSize != CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The compress param NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecIn decIn = {.pSrcIn = src, .strInLen = srcSize, .strInCostLen = 0};\n    CmptLzDecOut decOut = {.pDestOut = dst, .destOutLen = *dstSize, .destOutFillLen = 0};\n    EnCmptLzStatus enFinStat = CMPTLZ_STATUS_BUT;\n    int ret = CmptLzDecode(&decIn, &decOut, param->protData, CMPTLZ_FINISH_ANY, &enFinStat, param->memHook);\n\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}",
            "rust_code": "pub fn CmptlzDecompress(mut src: Ptr<Void>, mut srcSize: usize, mut dst: Ptr<Void>, mut dstSize: Ptr<usize>, mut param: Ptr<CmptlzDecParam>) -> i32 {\n    if (src == NULL!() || dst == NULL!() || dstSize == NULL!()) {\n        CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The input parameter NULL is incorrect.\"));\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff) {\n        CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"dstSize:0x{} srcSize:0x{}\"), *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    if (param == NULL!() || param.memHook == NULL!() || param.protData == NULL!() || param.protSize != CMPTLZ_PROPS_SIZE!()) {\n        CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The compress param NULL is incorrect.\"));\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    let mut decIn: CmptLzDecIn = CmptLzDecIn {\n        pSrcIn: src,\n        strInLen: srcSize,\n        strInCostLen: 0,\n    };\n    let mut decOut: CmptLzDecOut = CmptLzDecOut {\n        pDestOut: dst,\n        destOutLen: *dstSize,\n        destOutFillLen: 0,\n    };\n    let mut enFinStat: EnCmptLzStatus = CMPTLZ_STATUS_BUT!();\n    let mut ret: i32 = CmptLzDecode(c_ref!(decIn), c_ref!(decOut), param.protData, CMPTLZ_FINISH_ANY!(), c_ref!(enFinStat), param.memHook);\n\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608517026)\nerror[E0412]: cannot find type `size_t` in this scope\n   --> src/src/public/cmptlz_log_h.rs:11:39\n    |\n11  |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n    |                                       ^^^^^^ not found in this scope\n    |\n   ::: src/src/decode/cmptlz_dec_c.rs:127:9\n    |\n127 |         CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The input parameter NULL is incorrect.\"));\n    |         --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n   --> src/src/public/cmptlz_log_h.rs:14:39\n    |\n14  |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[$(&$args), *]);\n    |                                       ^^^^^^ not found in this scope\n    |\n   ::: src/src/decode/cmptlz_dec_c.rs:132:9\n    |\n132 |         CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"dstSize:0x{} srcSize:0x{}\"), *dstSize, srcSize);\n    |         --------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n   --> src/src/public/cmptlz_log_h.rs:11:39\n    |\n11  |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n    |                                       ^^^^^^ not found in this scope\n    |\n   ::: src/src/decode/cmptlz_dec_c.rs:137:9\n    |\n137 |         CMPTLZ_LOG!(CMPT_ERROR_UNSUPPORTED!(), cstr!(\"The compress param NULL is incorrect.\"));\n    |         -------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "static inline int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzPropsDecode(mut protData: Ptr<u8>, mut protSize: u32, mut decProt: Ptr<CmptLzDecProt>) -> i32 {\n    let mut dictSize: u32;\n\n    if (protSize < CMPTLZ_PROPS_SIZE!()) {\n        return CMPT_ERROR_UNSUPPORTED!();\n    } else {\n        dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN!()) {\n        dictSize = CMPTLZ_DICT_MIN_LEN!();\n    }\n    decProt.dicSize = dictSize;\n\n    let mut firstData: u8 = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX!() * CMPTLZ_POS_STATE_MAX!() * CMPTLZ_LIT_POS_MAX!())) {\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n\n    decProt.litCtx = (firstData % CMPTLZ_LIT_CTX_MAX!());\n    firstData /= CMPTLZ_LIT_CTX_MAX!();\n    decProt.posBits = (firstData / CMPTLZ_POS_STATE_MAX!());\n    decProt.litPos = (firstData % CMPTLZ_LIT_POS_MAX!());\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608521291)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:35\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:33\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                 ^ no implementation for `u8 | u32`\n   |\n   = help: the trait `BitOr<u32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n             `&u8` implements `BitOr<u8>`\n             `&u8` implements `BitOr`\n             `u8` implements `BitOr<&u8>`\n             `u8` implements `BitOr`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:65\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:63\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                               ^ no implementation for `u8 | u32`\n   |\n   = help: the trait `BitOr<u32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n             `&u8` implements `BitOr<u8>`\n             `&u8` implements `BitOr`\n             `u8` implements `BitOr<&u8>`\n             `u8` implements `BitOr`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:96\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n  --> src/src/decode/cmptlz_dec_init_c.rs:34:94\n   |\n34 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n   |                                                                                              ^ no implementation for `u8 | u32`\n   |\n   = help: the trait `BitOr<u32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitOr<Rhs>`:\n             `&u8` implements `BitOr<u8>`\n             `&u8` implements `BitOr`\n             `u8` implements `BitOr<&u8>`\n             `u8` implements `BitOr`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "static inline void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}",
            "rust_code": "pub fn CmptLzDecMemFree(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut freeAddress: Ptr<Void>) {\n    memHook.CmptLzFree(memHandle, freeAddress);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608525847)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/decode/cmptlz_dec_init_c.rs:48:13\n   |\n48 |     memHook.CmptLzFree(memHandle.cast(), freeAddress.cast());\n   |             ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n48 |     (memHook.CmptLzFree)(memHandle.cast(), freeAddress.cast());\n   |     +                  +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecAllocateProbs(mut decCtx: Ptr<CmptLzDecCtx>, mut decProt: Ptr<CmptLzDecProt>, mut memHook: Ptr<CmptLzMemHook>) -> i32 {\n    let mut numProbs: u32 = CmptLzGetNumProbs(decProt);\n\n    if (decCtx.probs == NULL!()) {\n        decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n    } else {\n        if (numProbs != decCtx.numProbs) {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n        }\n    }\n\n    if (decCtx.probs == NULL!()) {\n        return CMPT_ERROR_MEM!();\n    }\n\n    decCtx.probsPlus1664 = (decCtx.probs + 1664);\n    decCtx.numProbs = numProbs;\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608528097)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:72:81\n   |\n72 | ...obs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n   |          -----------------                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |          |\n   |          arguments to this function are incorrect\n   |\nnote: function defined here\n  --> src/src/decode/cmptlz_dec_init_c.rs:42:8\n   |\n42 | pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> Ptr<Void> {\n   |        ^^^^^^^^^^^^^^^^^                                                      --------------------\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n72 |         decCtx.probs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), (numProbs * c_sizeof!(CmptLzDecProb)).try_into().unwrap()).cast::<Ptr<CmptLzDecProb>>();\n   |                                                                                 +                                   +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_init_c.rs:76:85\n   |\n76 | ...obs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n   |          -----------------                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n   |          |\n   |          arguments to this function are incorrect\n   |\nnote: function defined here\n  --> src/src/decode/cmptlz_dec_init_c.rs:42:8\n   |\n42 | pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> Ptr<Void> {\n   |        ^^^^^^^^^^^^^^^^^                                                      --------------------\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n   |\n76 |             decCtx.probs = CmptLzDecMemAlloc(memHook.cast(), CMPTLZ_PROB_HANDLE!(), (numProbs * c_sizeof!(CmptLzDecProb)).try_into().unwrap()).cast::<Ptr<CmptLzDecProb>>();\n   |                                                                                     +                                   +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                         uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                         const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzTryDecLenAndDist(mut decCtx: Ptr<CmptLzDecCtx>, mut mkState: u32, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut probSlot: Ptr<CmptLzDecProb>, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut offset: u32;\n    let mut bits2BeDec: u32;\n    let mut pbMask: u32 = ((1 as u32) << decCtx.prop.posBits) - 1;\n    let mut posState: u32 = CMPTLZ_CALC_POS_STATE!(decCtx.processedPos, pbMask);\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n    let mut probBit: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    let mut probLen: Ptr<CmptLzDecProb> = probSlot + CMPTLZ_LEN_CHOICE!();\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n    if (rangeCode < rangeBound) {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    } else {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n    let mut decSym: u32 = 1;\n    c_do!({\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    } while decSym < ((1 as u32) << bits2BeDec));\n    decSym -= ((1 as u32) << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4) {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK!();\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n\n    decSym = 1;\n    c_do!({\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    } while decSym < (1 << CMPTLZ_POS_SLOT_BITS!()));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS!());\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT!()) {\n        if (decSym < CMPTLZ_HIGH_POSSLOT!()) {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        } else {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS!();\n            c_do!({\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while bits2BeDec.prefix_minus_minus() > 0);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS!();\n        }\n\n        decSym = 1;\n        offset = 1;\n        c_do!({\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n            if (rangeCode < rangeBound) {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while bits2BeDec.prefix_minus_minus() > 0);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608551571)\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n78 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |     ------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                        ^^ no implementation for `u32 |= u8`\n...\n78 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |     ------------------------------------------------------------------ in this macro invocation\n   |\n   = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n             `u32` implements `BitOrAssign<&u32>`\n             `u32` implements `BitOrAssign`\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:80:53\n   |\n80 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n   |                                                     ^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n  --> src/src/decode/cmptlz_dec_try_c.rs:80:51\n   |\n80 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n   |                                                   ^ no implementation for `u32 * u16`\n   |\n   = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n             `&u32` implements `std::ops::Mul<u32>`\n             `&u32` implements `std::ops::Mul`\n             `u32` implements `std::ops::Mul<&u32>`\n             `u32` implements `std::ops::Mul<Duration>`\n             `u32` implements `std::ops::Mul<types::num::Num>`\n             `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n88 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                        ^^ no implementation for `u32 |= u8`\n...\n88 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n             `u32` implements `BitOrAssign<&u32>`\n             `u32` implements `BitOrAssign`\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:91:57\n   |\n91 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n   |                                                         ^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n  --> src/src/decode/cmptlz_dec_try_c.rs:91:55\n   |\n91 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n   |                                                       ^ no implementation for `u32 * u16`\n   |\n   = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n             `&u32` implements `std::ops::Mul<u32>`\n             `&u32` implements `std::ops::Mul`\n             `u32` implements `std::ops::Mul<&u32>`\n             `u32` implements `std::ops::Mul<Duration>`\n             `u32` implements `std::ops::Mul<types::num::Num>`\n             `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n105 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n105 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:63\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                               ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n110 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:61\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                             ^ no implementation for `u32 * u16`\n...\n110 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n111 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n111 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:63\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                               ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n126 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:61\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                             ^ no implementation for `u32 * u16`\n...\n126 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n127 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n127 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n138 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n138 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n149 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n149 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:151:61\n    |\n151 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n    |                                                             ^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:151:59\n    |\n151 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n    |                                                           ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n164 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n164 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 26 previous errors\n"
        },
        {
            "c_code": "static inline int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                        const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzTryDecLitPacket(mut decCtx: Ptr<CmptLzDecCtx>, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut probBit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut procPos: u32 = decCtx.processedPos;\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> decCtx.prop.litCtx);\n\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut dicPos: usize = decCtx.dictPos;\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut bufLimit: Ptr<u8> = (*pbufLimit);\n\n    if (decCtx.dictPos >= decCtx.dictBufSize) {\n        return CMPT_ERROR_DATA!();\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0) || (decCtx.checkDicSize != 0) {\n        probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask)\n                                   << decCtx.prop.litCtx);\n    }\n\n    let mut decSym: u32 = 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()) {\n        c_do!({\n            probBit = (probSlot + decSym);\n            CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    } else {\n        let mut bit: u32 = Default::default();\n        let tmp0 = dicPos - decCtx.reps[0;\n        let mut matchSym: u32 = dict[tmp0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })];\n        let mut offset: u32 = 0x100;\n        c_do!({\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = (probSlot + (offset + bit + decSym));\n            CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608555915)\nerror: expected expression, found `$`\n   --> src/src/decode/cmptlz_dec_try_c.rs:59:13\n    |\n59  |             $offset ^= $bit;\n    |             ^^^^^^^ expected expression\n...\n112 |             CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |             ------------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_MATCH_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:92:54\n   |\n92 |         probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask)\n   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n  --> src/src/decode/cmptlz_dec_try_c.rs:92:52\n   |\n92 |         probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask)\n   |                                                    ^ no implementation for `u32 + u8`\n   |\n   = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Add<Rhs>`:\n             `&u32` implements `std::ops::Add<u32>`\n             `&u32` implements `std::ops::Add`\n             `u32` implements `std::ops::Add<&u32>`\n             `u32` implements `std::ops::Add<types::num::Num>`\n             `u32` implements `std::ops::Add`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:63\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                               ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n100 |             CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |             ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:39:61\n    |\n39  |             $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                             ^ no implementation for `u32 * u16`\n...\n100 |             CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |             ------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n101 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n101 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:105:47\n    |\n105 |         let mut matchSym: u32 = dict[dicPos - decCtx.reps[0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })].cast();\n    |                                               ^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/decode/cmptlz_dec_try_c.rs:105:45\n    |\n105 |         let mut matchSym: u32 = dict[dicPos - decCtx.reps[0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })].cast();\n    |                                             ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:105:77\n    |\n105 |         let mut matchSym: u32 = dict[dicPos - decCtx.reps[0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })].cast();\n    |                                                                    ------   ^^^^^^^^^^^^^^ expected `usize`, found `u32`\n    |                                                                    |\n    |                                                                    expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n105 |         let mut matchSym: u32 = dict[dicPos - decCtx.reps[0] + (if dicPos < decCtx.reps[0].try_into().unwrap() { dictBufSize } else { 0 })].cast();\n    |                                                                                           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:55:59\n    |\n55  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n112 |             CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |             ------------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_MATCH_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_try_c.rs:55:57\n    |\n55  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n112 |             CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n    |             ------------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_MATCH_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n113 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n113 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n117 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n117 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 16 previous errors\n"
        },
        {
            "c_code": "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}",
            "rust_code": "pub fn CmptLzTryDecOnePacket(mut decCtx: Ptr<CmptLzDecCtx>, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut rangeBound: u32 = 0;\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut mkState: u32 = decCtx.state;\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot1: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot2: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n\n    let mut pbMask: u32 = ((1).cast::<u32>() << decCtx.prop.posBits) - 1;\n    let mut posState: u32 = CMPTLZ_CALC_POS_STATE!(decCtx.processedPos, pbMask);\n\n    probSlot1 = (CmptLzGetIsMatchProb(probsMatrix) + posState + mkState);\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1).cast();\n    if (rangeCode < rangeBound) {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = (CmptLzGetIsRepProb(probsMatrix) + mkState);\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2).cast();\n    if (rangeCode < rangeBound) {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    } else {\n        if (decCtx.dictPos >= decCtx.dictBufSize) {\n            return CMPT_ERROR_DATA!();\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = (CmptLzGetIsRepG0Prob(probsMatrix) + mkState);\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot).cast();\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = (CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState);\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot).cast();\n            if (rangeCode < rangeBound) {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK!();\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            }\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = (CmptLzGetIsRepG1Prob(probsMatrix) + mkState);\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot).cast();\n            if (rangeCode < rangeBound) {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = (CmptLzGetIsRepG2Prob(probsMatrix) + mkState);\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot).cast();\n                if (rangeCode < rangeBound) {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                } else {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM!();\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608560668)\nerror[E0282]: type annotations needed\n  --> src/src/decode/cmptlz_dec_try_c.rs:84:44\n   |\n84 |     let mut bufLimit: Ptr<u8> = *pbufLimit.cast();\n   |                                            ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n84 |     let mut bufLimit: Ptr<u8> = *pbufLimit.cast::<T>();\n   |                                                +++++\n\nerror[E0308]: mismatched types\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n98 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n  --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n   |\n29 |             $rangeCode |= *$bufTryDec.plus_plus();\n   |                        ^^ no implementation for `u32 |= u8`\n...\n98 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n   |         ------------------------------------------------------------------ in this macro invocation\n   |\n   = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `BitOrAssign<Rhs>`:\n             `u32` implements `BitOrAssign<&u32>`\n             `u32` implements `BitOrAssign`\n   = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n103 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n103 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |     ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n116 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n116 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |         ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n122 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n122 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n128 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n128 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n136 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n136 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |             ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:27\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n144 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_try_c.rs:29:24\n    |\n29  |             $rangeCode |= *$bufTryDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n144 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    |                 ------------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0282, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 15 previous errors\n"
        },
        {
            "c_code": "int CmptLzDecCarefulProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    int res = CMPT_OK;\n    uint32_t remainLen;\n    const unsigned char *bufLimitTmp;\n    const unsigned char *pSrcIn;\n\n    do\n    {\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx->buf;\n\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, &bufLimitTmp);\n        if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if ((res != CMPT_OK) || (decCtx->buf != bufLimitTmp))\n        {\n            return CMPT_ERROR_DATA;\n        }\n        if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n        {\n            break;\n        }\n    } while (decCtx->dictPos < dicPosLimit);\n\n    if ((res == CMPTLZ_DEC_INPUT_EOF) && (decCtx->buf < bufLimit))\n    {\n        remainLen = (uint32_t)(bufLimit - decCtx->buf);\n        decCtx->tempBufSize = remainLen;\n        for (uint32_t idx = 0; idx < remainLen; idx++)\n        {\n            decCtx->tempBuf[idx] = decCtx->buf[idx];\n        }\n    }\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecCarefulProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    let mut res: i32 = CMPT_OK!();\n    let mut remainLen: u32;\n    let mut bufLimitTmp: Ptr<u8>;\n    let mut pSrcIn: Ptr<u8>;\n\n    c_do!({\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx.buf;\n\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, c_ref!(bufLimitTmp));\n        if (res == CMPTLZ_DEC_INPUT_EOF!()) {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if (res != CMPT_OK!()) || (decCtx.buf != bufLimitTmp) {\n            return CMPT_ERROR_DATA!();\n        }\n        if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) {\n            break;\n        }\n    } while (decCtx.dictPos < dicPosLimit);\n\n    if (res == CMPTLZ_DEC_INPUT_EOF!()) && (decCtx.buf < bufLimit) {\n        remainLen = (bufLimit - decCtx.buf).cast::<u32>();\n        decCtx.tempBufSize = remainLen;\n        c_for!(let mut idx: u32 = 0; idx < remainLen; idx.suffix_plus_plus(); {\n            let tmp0 = idx;\n            decCtx.tempBuf[tmp0];\n        });\n    }\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608595889)\nerror: mismatched closing delimiter: `}`\n   --> src/src/decode/cmptlz_dec_try_c.rs:90:10\n    |\n84  | pub fn CmptLzDecCarefulProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    |                                                                                                                     - closing delimiter possibly meant for this\n...\n90  |     c_do!({\n    |          ^ unclosed delimiter\n...\n116 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}",
            "rust_code": "pub fn CmptLzDistDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probsMatrix: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut decLen: u32) -> usize {\n    let mut assistBits: u32;\n    let mut posSlot: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut distDec: u32;\n\n    let mut probPosSlot: Ptr<CmptLzDecProb> = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < CMPTLZ_POS_SLOT_BITS!(); i.suffix_plus_plus(); {\n        CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    });\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT!()) {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n        if (distDec == 0xFFFFFFFF.cast::<usize>()) {\n            return distDec.cast();\n        } else {\n            return (distDec + 1).cast();\n        }\n    }\n\n    let mut directBitNum: u32 = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT!()) {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        c_do!({\n            if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound) {\n                CMPTLZ_RANGE_UPDATE_0!((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while directBitNum.prefix_minus_minus() > 0);\n        distDec -= assistBits;\n    } else {\n        directBitNum -= CMPTLZ_REP4!();\n        c_do!({\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((rangeCode >> 31).cast::<u32>()));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while directBitNum.prefix_minus_minus() > 0);\n\n        let mut probDist: Ptr<CmptLzDecProb>;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS!();\n        assistBits = 1;\n\n        let mut cycleSym: u32 = 1;\n        c_for!(i = 0; i < 3; i.suffix_plus_plus(); {\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        });\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_0!(probDist, range, rangeBound);\n            assistBits -= 8;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n    if (distDec == 0xFFFFFFFF.cast::<usize>()) {\n        return distDec.cast();\n    } else {\n        return (distDec + 1).cast();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608598352)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound) {\n    |                --------------------------------------------------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound); {\n    |                                                                                           +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:59\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:57\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n153 |         CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    |         ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:24\n    |\n161 |         if (distDec == 0xFFFFFFFF.cast::<usize>()).as_bool() {\n    |             -------    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n    |             |\n    |             expected because this is `u32`\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n161 |         if (distDec == 0xFFFFFFFF.cast::<usize>().try_into().unwrap()).as_bool() {\n    |                                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound) {\n    |                --------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:9\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound) {\n    |                --------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n    |\n30  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n177 |             if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound) {\n    |                --------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n179 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n179 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n184 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n184 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n193 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n193 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n209 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n209 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:95:59\n    |\n95  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n210 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n    |             ----------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:95:57\n    |\n95  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n210 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n    |             ----------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n213 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n213 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:215:57\n    |\n215 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n    |                                                         ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:215:55\n    |\n215 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n    |                                                       ^ no implementation for `u32 * u16`\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n222 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n222 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:228:20\n    |\n228 |     if (distDec == 0xFFFFFFFF.cast::<usize>()).as_bool() {\n    |         -------    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n    |         |\n    |         expected because this is `u32`\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n228 |     if (distDec == 0xFFFFFFFF.cast::<usize>().try_into().unwrap()).as_bool() {\n    |                                              ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 26 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    return decLen;\n}",
            "rust_code": "pub fn CmptLzLenDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probSlot: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut posState: u32) -> u32 {\n    let mut decLen: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut probLen: Ptr<CmptLzDecProb> = (probSlot + CMPTLZ_LEN_CHOICE!());\n\n    let mut i: i32 = 0;\n    if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_0!(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probLen = (probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState);\n        c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT!(); i.suffix_plus_plus(); {\n            CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        });\n        decLen -= 8;\n    } else {\n        CMPTLZ_RANGE_UPDATE_1!(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n        probLen = (probSlot + CMPTLZ_LEN_CHOICE2!());\n        if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n            probLen = (probSlot + (CMPTLZ_LEN_CHOICE2!() + posState));\n            c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT!(); i.suffix_plus_plus(); {\n                CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            });\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n            probLen = (probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!());\n            c_for!(i = 0; i < CMPTLZ_HIGH_LEN_BIT!(); i.suffix_plus_plus(); {\n                CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            });\n            decLen -= CMPTLZ_HIGH_LEN_CLASS!();\n            decLen += (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx.buf = bufToDec;\n\n    return decLen;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608614053)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |        ----------------------------------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                   +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |            ----------------------------------------------------------- caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                       +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |        ----------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:154:68\n    |\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |                                                                    ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n154 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |        ----------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n156 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n156 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:59\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n159 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |             --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:57\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n159 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |             --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n159 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |             --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n159 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |             --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n164 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n164 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |            ----------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:167:72\n    |\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |                                                                        ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n167 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound).as_bool() {\n    |            ----------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n169 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n169 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:59\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n173 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:57\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n173 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n173 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n173 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n177 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n177 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:59\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n181 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:58:57\n    |\n58  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n181 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n181 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n181 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n    |                 --------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 28 previous errors; 2 warnings emitted\n"
        },
        {
            "c_code": "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n    let mut dicCopyPos: usize;\n    let mut dicPos: usize = decCtx.dictPos;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut remainDicLen: u32 = (dicPosLimit - dicPos).cast();\n    let mut dict: Ptr<u8> = decCtx.dict;\n\n    if (remainDicLen == 0) {\n        return CMPT_ERROR_DATA!();\n    }\n\n    let mut decDicLen: u32 = if remainDicLen < matchLen { remainDicLen } else { matchLen };\n    decCtx.processedPos += decDicLen;\n    decCtx.dictPos += decDicLen.cast();\n    decCtx.remainLen = (matchLen - decDicLen);\n\n    if (dicPos < matchDist) {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    } else {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    c_do!({\n        dict[dicPos] = dict[dicCopyPos];\n        dicPos += 1;\n        if (dicCopyPos.prefix_plus_plus() == dictBufSize) {\n            dicCopyPos = 0;\n        }\n    } while decDicLen.suffix_minus_minus() != 0);\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608619295)\nerror[E0308]: mismatched types\n   --> src/include/cmptlz_base_h.rs:160:52\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/decode/cmptlz_dec_process_c.rs:150:129\n    |\n150 | pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n    |                                                                                                                                 --- expected `u32` because of return type\n...\n158 |         return CMPT_ERROR_DATA!();\n    |                ------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n    |                                                    +                                               +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}",
            "rust_code": "pub fn CmptLzShortRepDec(mut decCtx: Ptr<CmptLzDecCtx>) {\n    let mut rep0: u32 = decCtx.reps[0];\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut dictPos: usize = decCtx.dictPos;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n\n    dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }];\n    decCtx.dictPos += 1;\n    decCtx.processedPos += 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()) {\n        decCtx.state = 9;\n    } else {\n        decCtx.state = 11;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608624392)\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:36\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    |                                    ^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:34\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    |                                  ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:161:56\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }].cast();\n    |                                              -------   ^^^^ expected `usize`, found `u32`\n    |                                              |\n    |                                              expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n161 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0.try_into().unwrap() { dictBufSize } else { 0 }].cast();\n    |                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                                    size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}",
            "rust_code": "pub fn CmptLzRepDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n    let mut repLen: u32;\n    let mut repDist: u32;\n    let mut mkState: u32 = decCtx.state;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n\n    probSlot = (CmptLzGetIsRepG0Prob(probsMatrix) + mkState);\n    if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n        probSlot = (CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx.buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK!();\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[0];\n        }\n    } else {\n        CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n        probSlot = (CmptLzGetIsRepG1Prob(probsMatrix) + mkState);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[1];\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n\n            probSlot = (CmptLzGetIsRepG2Prob(probsMatrix) + mkState);\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP2!()];\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP3!()];\n                let tmp0 = CMPTLZ_REP3!();\n                decCtx.reps[tmp0];\n            }\n            decCtx.reps[CMPTLZ_REP2!()] = decCtx.reps[1];\n        }\n        decCtx.reps[1] = decCtx.reps[0];\n        decCtx.reps[0] = repDist;\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx.buf = bufToDec;\n\n    decCtx.state = if mkState < CMPTLZ_LIT_STATES!() { 8 } else { 11 };\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    return CmptLzDecByDistAndLen(decCtx, repDist.cast(), (repLen + 2), dicPosLimit);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608627267)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |        ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                    +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                            +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |        ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:173:69\n    |\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                     ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n173 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |        ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n175 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n175 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:178:73\n    |\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                         ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n178 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n180 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n180 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n189 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n189 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |         --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:197:73\n    |\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                         ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n197 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n199 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n199 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n203 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n203 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |             --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:206:77\n    |\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                             ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n206 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n208 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n208 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n212 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n212 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n    |                 --------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 32 previous errors; 4 warnings emitted\n"
        },
        {
            "c_code": "static inline uint32_t CmptLzMatchDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode,\n                                      uint32_t *pRangeBound, size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t matchLen;\n    size_t matchDist;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n    if (matchDist > decCtx->dictBufSize)\n    {\n        if (matchDist == (size_t)0xFFFFFFFF)\n        {\n            decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN;\n            decCtx->state -= CMPTLZ_MKSTATE_NUM;\n            return CMPT_OK;\n        }\n        else\n        {\n            return CMPT_ERROR_DATA;\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, matchLen + 2, dicPosLimit);\n}",
            "rust_code": "pub fn CmptLzMatchDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n    let mut matchLen: u32;\n    let mut matchDist: usize;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n    if (matchDist > decCtx.dictBufSize) {\n        if (matchDist == 0xFFFFFFFF) {\n            decCtx.remainLen = CMPTLZ_MATCH_MAX_LEN!();\n            decCtx.state -= CMPTLZ_MKSTATE_NUM!();\n            return CMPT_OK!();\n        } else {\n            return CMPT_ERROR_DATA!();\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, (matchLen + 2), dicPosLimit);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608639711)\nerror[E0308]: mismatched types\n   --> src/include/cmptlz_base_h.rs:160:52\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/decode/cmptlz_dec_process_c.rs:165:175\n    |\n165 | ...chDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u3...\n    |                                                                                                                                                                  --- expected `u32` because of return type\n...\n180 | ...rn CMPT_ERROR_DATA!();\n    |       ------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n    |\n160 | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n    |                                                    +                                               +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptLzLitDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>) -> u32 {\n    let mut decSym: u32 = 1;\n    let mut mkState: u32 = decCtx.state;\n    let mut procPos: u32 = decCtx.processedPos;\n    let mut checkDicSize: u32 = decCtx.checkDicSize;\n    let mut litCtx: u32 = decCtx.prop.litCtx.cast();\n    let mut litPosMask: u32 = ((0x100 << decCtx.prop.litPos) - (0x100 >> litCtx));\n\n    let mut probLit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut dictPos: usize = decCtx.dictPos;\n\n    let mut range: u32 = *pRange.cast();\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut rangeCode: u32 = *pRangeCode.cast();\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0) || (checkDicSize != 0) {\n        probSlot += (CMPTLZ_REP3!() * ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx));\n    }\n\n    let mut i: i32 = 0;\n    if (mkState < CMPTLZ_LIT_STATES!()) {\n        mkState -= if (mkState < 4) { mkState } else { 3 };\n        c_for!(; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_NORMAL_BIT_DEC!((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        });\n    } else {\n        let mut bit: u32 = Default::default();\n        let mut offset: u32 = 0x100;\n        let mut rep0: u32 = decCtx.reps[0];\n        let tmp0 = dictPos - rep0 + (if (dictPos < rep0) { dictBufSize } else { 0 });\n        let mut matchSym: u32 = dict[tmp0].cast();\n        mkState -= if (mkState < 10) { CMPTLZ_REP3!() } else { 6 };\n        c_for!(; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        });\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n\n    dict[dictPos] = decSym.cast::<u8>();\n    dictPos += 1;\n    decCtx.processedPos += 1;\n    decCtx.state = mkState;\n    decCtx.dictPos = dictPos;\n    decCtx.buf = bufToDec;\n\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608646137)\nerror: expected expression, found `$`\n   --> src/src/decode/cmptlz_dec_process_c.rs:76:9\n    |\n76  |         $probLit = $probSlot + ($offset + $bit + $decSym);\n    |         ^^^^^^^^ expected expression\n...\n210 |             CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n    |             ------------------------------------------------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_MATCH_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0282]: type annotations needed\n   --> src/src/decode/cmptlz_dec_process_c.rs:187:34\n    |\n187 |     let mut range: u32 = *pRange.cast();\n    |                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n187 |     let mut range: u32 = *pRange.cast::<T>();\n    |                                      +++++\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:193:59\n    |\n193 | ... * ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx)).cast();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n   --> src/src/decode/cmptlz_dec_process_c.rs:193:57\n    |\n193 | ...   probSlot += (CMPTLZ_REP3!() * ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << li...\n    |                                                       ^ no implementation for `u32 + u8`\n    |\n    = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Add<Rhs>`:\n              `&u32` implements `std::ops::Add<u32>`\n              `&u32` implements `std::ops::Add`\n              `u32` implements `std::ops::Add<&u32>`\n              `u32` implements `std::ops::Add<types::num::Num>`\n              `u32` implements `std::ops::Add`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:207:48\n    |\n207 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                                ^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/decode/cmptlz_dec_process_c.rs:207:46\n    |\n207 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                              ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:207:70\n    |\n207 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                                            -------   ^^^^ expected `usize`, found `u32`\n    |                                                            |\n    |                                                            expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n207 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0.try_into().unwrap()).as_bool() { dictBufSize } else { 0 })].cast();\n    |                                                                          ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0282, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
        },
        {
            "c_code": "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n\n    return (int)decRes;\n}",
            "rust_code": "pub fn CmptLzDecDirectProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    let mut decRes: u32;\n    let mut pbMask: u32 = ((1).cast::<u32>() << decCtx.prop.posBits) - 1;\n    let mut procPos: u32;\n    let mut mkState: u32;\n    let mut posState: u32;\n\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut rangeBound: u32 = 0;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n\n    c_do!({\n        procPos = decCtx.processedPos;\n        mkState = decCtx.state;\n        posState = CMPTLZ_CALC_POS_STATE!(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n            decRes = CmptLzLitDec(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound));\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n                decRes = CmptLzMatchDec(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound), dicPosLimit, posState);\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n                decRes = CmptLzRepDec(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound), dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK!()) {\n                break;\n            }\n        }\n    } while (decCtx.dictPos < dicPosLimit) && (decCtx.buf < bufLimit) && (decCtx.remainLen < CMPTLZ_MATCH_MAX_LEN!()));\n\n    decCtx.range = range;\n    decCtx.code = rangeCode;\n\n    return decRes.cast::<i32>();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608663748)\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n   --> src/src/decode/cmptlz_dec_process_c.rs:31:9\n    |\n31  |         if $rangeCode < $rangeBound\n    |         ^^\n...\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ caused by the macro expansion here\n    |\n    = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n    |\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound);.as_bool() {\n    |                                                                            +\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |         ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n194 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |         ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:195:73\n    |\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                         ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n195 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |            ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n197 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n197 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n201 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n201 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |             ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:59\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bool` found for unit type `()` in the current scope\n   --> src/src/decode/cmptlz_dec_process_c.rs:205:77\n    |\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                                                                             ^^^^^^^ method not found in `()`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `integer::Integer` defines an item `as_bool`, perhaps you need to implement it\n   --> src/translation_utils/types/integer.rs:3:1\n    |\n3   | pub trait Integer: PrimitiveType {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: cannot multiply `u32` by `u16`\n   --> src/src/decode/cmptlz_dec_process_c.rs:30:57\n    |\n30  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n    |                                                         ^ no implementation for `u32 * u16`\n...\n205 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n    |                ------------------------------------------------------------ in this macro invocation\n    |\n    = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n              `&u32` implements `std::ops::Mul<u32>`\n              `&u32` implements `std::ops::Mul`\n              `u32` implements `std::ops::Mul<&u32>`\n              `u32` implements `std::ops::Mul<Duration>`\n              `u32` implements `std::ops::Mul<types::num::Num>`\n              `u32` implements `std::ops::Mul`\n    = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n207 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n207 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:27\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                           ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n211 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n   --> src/src/decode/cmptlz_dec_process_c.rs:21:24\n    |\n21  |             $rangeCode |= *$bufToDec.plus_plus();\n    |                        ^^ no implementation for `u32 |= u8`\n...\n211 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n    |                 ----------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitOrAssign<Rhs>`:\n              `u32` implements `BitOrAssign<&u32>`\n              `u32` implements `BitOrAssign`\n    = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 18 previous errors; 2 warnings emitted\n"
        },
        {
            "c_code": "static inline uint32_t CmptlzSwap32(uint32_t val)\n    {\n#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)))\n        return (uint32_t)__builtin_bswap32(val);\n#endif\n        return ((0xff000000 & (val << 24)) | (0x000000ff & (val >> 24)) | (0x00ff0000 & (val << 8)) |\n                (0x0000ff00 & (val >> 8)));\n    }",
            "rust_code": "pub fn CmptlzSwap32(mut val: u32) -> u32 {\n    #[cfg(all(target_arch = \"x86_64\", target_feature = \"bswap\"))]\n    {\n        return val.swap_bytes();\n    }\n    #[cfg(not(all(target_arch = \"x86_64\", target_feature = \"bswap\"))]\n    {\n        return ((0xff000000 & (val << 24)) | (0x000000ff & (val >> 24)) | (0x00ff0000 & (val << 8)) |\n                (0x0000ff00 & (val >> 8)));\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608673996)\nerror: mismatched closing delimiter: `]`\n  --> src/src/public/cmptlz_utils_h.rs:41:10\n   |\n41 |     #[cfg(not(all(target_arch = \"x86_64\", target_feature = \"bswap\"))]\n   |      -   ^ unclosed delimiter                                       ^ mismatched closing delimiter\n   |      |\n   |      closing delimiter possibly meant for this\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        CmptRcCtx *rc = encCtx->rcCtx;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n        probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n        CmptlzState state = encCtx->state;\n        CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n        if (state < 7)\n        {\n            shiftRes = CmptRcLitProcess(rc, probs, curByte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        else\n        {\n            const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n            shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncLit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut rc: Ptr<CmptRcCtx> = encCtx.rcCtx;\n    let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = rc.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    rc.range = range;\n    let mut litProb: Ptr<CmptlzProb> = c_ref!(encCtx.litMarcov.literal[0][0]);\n    let mut curByte: u8 = mf.srcStart[mf.readPos - mf.readAhead];\n    probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n    let mut state: CmptlzState = encCtx.state;\n    CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n    if (state < 7) {\n        shiftRes = CmptRcLitProcess(rc, probs, curByte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut match_byte: u8 = mf.srcStart[mf.readPos - encCtx.reps[0] - 1 - mf.readAhead];\n        shiftRes = CmptRcLitAfterMatch(rc, probs, curByte.cast(), match_byte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608675203)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:33\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:27:5\n   |\n27 |     CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |     ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:20:41\n   |\n20 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask).cast();\n   |                                         ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:20:39\n   |\n20 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask).cast();\n   |                                       ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:22:23\n   |\n22 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n26 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:27:5\n   |\n27 |     CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |     ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:32:59\n   |\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:11:42\n   |\n11 |         $litProb + 3u32 * (((($pos << 8) + $prevByte) & (*$encCtx.lock()).lpMask) << (*$encCtx.lock()).litMarcov.lcBits)\n   |                                          ^ no implementation for `u32 + u8`\n...\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |             ----------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::Add<Rhs>`:\n             `&u32` implements `std::ops::Add<u32>`\n             `&u32` implements `std::ops::Add`\n             `u32` implements `std::ops::Add<&u32>`\n             `u32` implements `std::ops::Add<types::num::Num>`\n             `u32` implements `std::ops::Add`\n   = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptLzEncCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:11:67\n   |\n11 |         $litProb + 3u32 * (((($pos << 8) + $prevByte) & (*$encCtx.lock()).lpMask) << (*$encCtx.lock()).litMarcov.lcBits)\n   |                                                                   ^^^^ method not found in `Ptr<TagCmptLzEncCtx>`\n...\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |             ----------------------------------------------------------------------------------------- in this macro invocation\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n   = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptLzEncCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:11:96\n   |\n11 |         $litProb + 3u32 * (((($pos << 8) + $prevByte) & (*$encCtx.lock()).lpMask) << (*$encCtx.lock()).litMarcov.lcBits)\n   |                                                                                                ^^^^ method not found in `Ptr<TagCmptLzEncCtx>`\n...\n32 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n   |             ----------------------------------------------------------------------------------------- in this macro invocation\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n   = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
        },
        {
            "c_code": "static inline int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608682828)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:33\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:41:5\n   |\n41 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:33\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:46:5\n   |\n46 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:34\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                  ^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:51:20\n   |\n51 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |                    --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:56\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                                        ^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:51:20\n   |\n51 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |                    --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:24:40\n   |\n24 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:24:38\n   |\n24 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n30 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:31:5\n    |\n31  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n35 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:36:5\n    |\n36  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n40 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:41:5\n   |\n41 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:26:23\n   |\n26 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n45 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:46:5\n   |\n46 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 14 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static inline int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        encCtx->rcCtx->range = range;\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n\n        shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        backRes -= CMPTLZ_NUM_REPS;\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = backRes;\n\n        encCtx->matchPriceCount++;\n\n        uint32_t posSlot = PosSloter(backRes);\n        shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        if (backRes >= 4)\n        {\n            shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncNormalMatch(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32, mut backRes: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    encCtx.rcCtx.range = range;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.matchLenEncoder), encCtx.rcCtx, lenRes, posState.cast());\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n\n    backRes -= CMPTLZ_NUM_REPS!();\n    encCtx.reps[3] = encCtx.reps[2];\n    encCtx.reps[2] = encCtx.reps[1];\n    encCtx.reps[1] = encCtx.reps[0];\n    encCtx.reps[0] = backRes;\n\n    encCtx.matchPriceCount += 1;\n\n    let mut posSlot: u32 = PosSloter(backRes);\n    shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    if (backRes >= 4) {\n        shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608685570)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:33\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:42:5\n   |\n42 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:29:40\n   |\n29 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:29:38\n   |\n29 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:31:23\n   |\n31 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n36 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:37:5\n    |\n37  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:31:23\n   |\n31 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n41 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:42:5\n   |\n42 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_inner_h.rs:67:9\n   |\n67 |         $state = if $state < 7 { LIT_MATCH!() } else { NOTLIT_MATCH!() };\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:47:5\n   |\n47 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n   |     ------------   ------------------------------------ in this macro invocation\n   |     |\n   |     expected due to the type of this binding\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_MATCH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static inline int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n\n        uint32_t range, bit0Prob, newBound;\n        uint32_t realDist;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n\n        switch (repIndex)\n        {\n        case 0:\n            CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRep0Long[encCtx->state][posState];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        case 1:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 2:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 3:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx->reps[3];\n            encCtx->reps[3] = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        default:\n            break;\n        }\n        CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        --encCtx->repLenPriceCount;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptlzEncLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut repIndex: u32, mut nowpos32: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut realDist: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    c_switch!(repIndex, {\n        0 => {\n            CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n        },\n        1 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n        },\n        2 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n        },\n        3 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[3];\n            encCtx.reps[3] = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n        },\n        _ => {},\n    });\n    CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.repLenEncoder), encCtx.rcCtx, lenRes, posState.cast());\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.repLenPriceCount -= 1;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608695678)\nerror: no rules expected `,`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:50:23\n   |\n50 |     c_switch!(repIndex, {\n   |                       ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n   |\n3  | macro_rules! c_switch {\n   | --------------------- when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_switch.rs:5:17\n   |\n5  |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n   |                 ^\n\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:75:34\n    |\n75  |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n    |                                  ^^^^^^^^^^^ not a value\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:108:20\n    |\n108 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n    |                    -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:75:55\n    |\n75  |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n    |                                                       ^^^^^^^^^^ not a value\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:108:20\n    |\n108 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n    |                    -------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:34:40\n   |\n34 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n  --> src/src/encode/cmptlz_enc_symbol_h.rs:34:38\n   |\n34 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n   |                                      ^ no implementation for `u32 & u64`\n   |\n   = help: the trait `BitAnd<u64>` is not implemented for `u32`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u32` implements `BitAnd<u32>`\n             `&u32` implements `BitAnd`\n             `u32` implements `BitAnd<&u32>`\n             `u32` implements `BitAnd`\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:36:23\n   |\n36 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n41 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:42:5\n    |\n42  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:36:23\n   |\n36 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n45 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_symbol_h.rs:46:5\n    |\n46  |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_symbol_h.rs:36:23\n   |\n36 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n49 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors; 1 warning emitted\n"
        },
        {
            "c_code": "static inline int CmptRcLitProcess(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, bit0Prob, newBound, curBit;\n\n        for (sym |= 0x100; sym < 0x10000; sym <<= 1)\n        {\n            CmptlzProb *litProbTableIndex = prob + (sym >> 8);\n            curBit = (sym >> 7) & 1;\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptRcLitProcess(mut rcCtx: Ptr<CmptRcCtx>, mut prob: Ptr<CmptlzProb>, mut sym: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut curBit: u32;\n    c_for!(sym |= 0x100; sym < 0x10000; sym <<= 1; {\n        let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (sym >> 8));\n        curBit = (sym >> 7) & 1;\n        CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    });\n    rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608700827)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n    |\n83  |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n    |                      ^^^^^^^^^^^^^^^^^^^ not a value\n...\n140 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n    |\n65  |         $bit0Prob = *$prob;\n    |                     ^^^^^^ expected `u32`, found `u16`\n...\n134 |     let mut bit0Prob: u32;\n    |                       --- expected due to this type\n...\n140 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n    |\n80  |             (*$rcCtx.lock()).low += mask;\n    |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n...\n140 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n140 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                       ^^ no implementation for `u32 += i32`\n...\n140 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n    |         ------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n        for (sym |= 0x100; sym < 0x10000;)\n        {\n            matchByte <<= 1;\n            CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n            curBit = (sym >> 7) & 1;\n            sym <<= 1;\n            offs &= ~(matchByte ^ sym);\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }",
            "rust_code": "pub fn CmptRcLitAfterMatch(mut rcCtx: Ptr<CmptRcCtx>, mut prob: Ptr<CmptlzProb>, mut sym: u32, mut matchByte: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut offs: u32 = 0x100;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut curBit: u32;\n    c_for!(sym |= 0x100; sym < 0x10000; {\n        matchByte <<= 1;\n        let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (offs + (matchByte & offs) + (sym >> 8)));\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= !(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    });\n    rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608702777)\nerror: unexpected end of macro invocation\n   --> src/src/encode/cmptlz_enc_rc_h.rs:151:6\n    |\n151 |     });\n    |      ^ missing tokens in macro arguments\n    |\n   ::: src/translation_utils/c_alignment/c_for.rs:3:1\n    |\n3   | macro_rules! c_for {\n    | ------------------ when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_for.rs:13:53\n    |\n13  |     ($($init: stmt),+; $cond: expr; $($step: expr),+; $body: block) => {\n    |                                                     ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                      CMPT_PRICE_BITS_MOVING_NUM];\n    }",
            "rust_code": "pub fn CmptPriceOneBit(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb, mut curbit: u32) -> u32 {\n    let tmp0 = ((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!();\n    return encCtx.priceRootTable[tmp0];\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608704770)\nerror: mismatched closing delimiter: `]`\n  --> src/src/encode/cmptlz_enc_price_h.rs:23:34\n   |\n23 | ...ceRootTable[((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!()].cast();\n   |               -^ unclosed delimiter                                                                                      ^ mismatched closing delimiter\n   |               |\n   |               closing delimiter possibly meant for this\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceBit1(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM - 1)) >> CMPT_PRICE_BITS_MOVING_NUM];\n    }",
            "rust_code": "pub fn CmptPriceBit1(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb) -> u32 {\n    return (*encCtx.priceRootTable)[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM!() - 1)) >> CMPT_PRICE_BITS_MOVING_NUM!()];\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608705586)\nerror[E0614]: type `types::array::Array<u32, 128>` cannot be dereferenced\n  --> src/src/encode/cmptlz_enc_price_h.rs:33:12\n   |\n33 |     return (*encCtx.priceRootTable)[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM!() - 1)) >> CMPT_PRICE_BITS_MOVING_NUM!()].cast();\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline uint32_t CmptPriceSymbolReverse(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                                  uint32_t symbol)\n    {\n        uint32_t price = 0;\n        uint32_t i = 1;\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[i], bit);\n            i = (i << 1) + bit;\n        } while (--symbolBitsNum);\n\n        return price;\n    }",
            "rust_code": "pub fn CmptPriceSymbolReverse(mut encCtx: Ptr<CmptLzEncCtx>, mut symbolProbs: Ptr<CmptlzProb>, mut symbolBitsNum: u32, mut symbol: u32) -> u32 {\n    let mut price: u32 = 0;\n    let mut i: u32 = 1;\n    c_do!({\n        let mut bit: u32 = symbol & 1;\n        symbol >>= 1;\n        price += CmptPriceOneBit(encCtx, symbolProbs[i], bit).cast::<u32>();\n        i = (i << 1) + bit;\n    } while symbolBitsNum.prefix_minus_minus());\n    return price;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608709750)\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_price_h.rs:57:13\n   |\n57 |     } while symbolBitsNum.prefix_minus_minus());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `u32`\n   |\n  ::: src/translation_utils/c_alignment/c_do_while.rs:7:15\n   |\n7  |         while core::mem::replace(&mut __first, false) || $cond\n   |               --------------------------------------- expected because this is `bool`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "CMPTLZ_static int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n#ifdef CMPTLZ_PRINTF_ENC_PROCESS\n        printf(\" now in CmptEncodeOneBlock process, backRes is %u, lenRes is %u\\n\", backRes, lenRes);\n        printf(\" nowpos32 is %u\\n\", nowpos32);\n#endif\n\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n\n        if (mf->readAhead == 0)\n        {\n\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}",
            "rust_code": "pub fn CmptEncodeOneBlock(mut encCtx: Ptr<CmptLzEncCtx>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = encCtx.mfCtx;\n    let mut nowpos32: u32 = encCtx.nowpos64.cast();\n    let mut startpos: u32 = nowpos32;\n    let mut backRes: u32;\n    let mut lenRes: u32;\n    let mut shiftRes: i32 = CMPT_OK!();\n    loop {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx.backRes;\n        lenRes = encCtx.lenRes;\n        CMPTLZ_PRINTF_ENC_PROCESS!(cstr!(\" now in CmptEncodeOneBlock process, backRes is {}, lenRes is {}\"), backRes, lenRes);\n        CMPTLZ_PRINTF_ENC_PROCESS!(cstr!(\" nowpos32 is {}\"), nowpos32);\n\n        c_switch!(backRes, {\n            CMPTLZ_UINT32_MAX!() => {\n                shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            0 => {\n                shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            1 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            2 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            3 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            _ => {\n                shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n        });\n\n        nowpos32 += lenRes;\n        mf.mfStart += lenRes;\n        mf.readAhead -= lenRes;\n\n        if (mf.readAhead == 0) {\n            CmptPriceCheck(encCtx);\n            if (mf.srcLen <= mf.mfStart) {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE!()) {\n                encCtx.nowpos64 += (nowpos32 - startpos).cast();\n                return 0;\n            }\n        }\n    }\n    encCtx.nowpos64 += (nowpos32 - startpos).cast();\n    return CmptlzFlush(encCtx);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608712875)\nerror: no rules expected `,`\n  --> src/src/encode/cmptlz_enc_blocks_c.rs:64:26\n   |\n64 |         c_switch!(backRes, {\n   |                          ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n   |\n3  | macro_rules! c_switch {\n   | --------------------- when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_switch.rs:5:17\n   |\n5  |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n   |                 ^\n\nerror: cannot find macro `CMPTLZ_PRINTF_ENC_PROCESS` in this scope\n  --> src/src/encode/cmptlz_enc_blocks_c.rs:61:9\n   |\n61 |         CMPTLZ_PRINTF_ENC_PROCESS!(cstr!(\" now in CmptEncodeOneBlock process, backRes is {}, lenRes is {}\"), backRes, lenRes);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: cannot find macro `CMPTLZ_PRINTF_ENC_PROCESS` in this scope\n  --> src/src/encode/cmptlz_enc_blocks_c.rs:62:9\n   |\n62 |         CMPTLZ_PRINTF_ENC_PROCESS!(cstr!(\" nowpos32 is {}\"), nowpos32);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_blocks_c.rs:103:30\n    |\n103 |             if (mf.srcLen <= mf.mfStart).as_bool() {\n    |                 ---------    ^^^^^^^^^^ expected `usize`, found `u32`\n    |                 |\n    |                 expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n103 |             if (mf.srcLen <= mf.mfStart.try_into().unwrap()).as_bool() {\n    |                                        ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "int CmptEncodeAll(CmptLzEncCtx *encCtx)\n{\n    CmptRcCtx *rc = encCtx->rcCtx;\n    CmptMfCtx *mf = encCtx->mfCtx;\n\n    if (mf->srcLen == 0)\n    {\n        return CmptlzFlush(encCtx);\n    }\n\n    if (encCtx->nowpos64 == 0)\n    {\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][0];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        int shiftRes = CMPT_OK;\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        uint8_t curByte = *(mf->srcStart);\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        mf->mfStart++;\n        encCtx->nowpos64++;\n        mf->readPos++;\n        if (mf->srcLen == 1)\n        {\n            return CmptlzFlush(encCtx);\n        }\n    }\n\n    int res;\n    while (true)\n    {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0 || encCtx->encNeedFinish)\n        {\n            break;\n        }\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptEncodeAll(mut encCtx: Ptr<CmptLzEncCtx>) -> i32 {\n    let mut rc: Ptr<CmptRcCtx> = encCtx.rcCtx;\n    let mut mf: Ptr<CmptMfCtx> = encCtx.mfCtx;\n\n    if (mf.srcLen == 0) {\n        return CmptlzFlush(encCtx);\n    }\n\n    if (encCtx.nowpos64 == 0) {\n        let mut range: u32;\n        let mut bit0Prob: u32;\n        let mut newBound: u32;\n        range = rc.range;\n        let tmp0 = encCtx.state;\n        let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][0]);\n        CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n        let mut shiftRes: i32 = CMPT_OK!();\n        CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        rc.range = range;\n        let mut curByte: u8 = *(mf.srcStart);\n        let mut litProb: Ptr<CmptlzProb> = c_ref!(encCtx.litMarcov.literal[0][0]);\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        mf.mfStart += 1;\n        encCtx.nowpos64 += 1;\n        mf.readPos += 1;\n        if (mf.srcLen == 1) {\n            return CmptlzFlush(encCtx);\n        }\n    }\n\n    let mut res: i32;\n    loop {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0) || encCtx.encNeedFinish {\n            break;\n        }\n    }\n    return res;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608731373)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:33\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_blocks_c.rs:71:9\n   |\n71 |         CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |         ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_blocks_c.rs:65:27\n   |\n65 |         let mut bit0Prob: u32;\n   |                           --- expected due to this type\n...\n69 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |         ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_blocks_c.rs:71:9\n   |\n71 |         CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n   |         ---------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
        },
        {
            "c_code": "int CmptHeadWrite(CmptLzEncCtx *encCtx, uint8_t *protData, size_t *propsSize)\n{\n    if (protData == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"protData is NULL\");\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"propsSize need 5 bytes, get %zu\", *propsSize);\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    CmptlzWriteLE32Bit(protData + 1, encCtx->dicSize);\n    protData[0] = (encCtx->posBits * CMPTLZ_POS_STATE_MAX + encCtx->litPos) * CMPTLZ_LIT_CTX_MAX + encCtx->litCtx;\n    *propsSize = CMPTLZ_PROPS_SIZE;\n    return 0;\n}",
            "rust_code": "pub fn CmptHeadWrite(mut encCtx: Ptr<CmptLzEncCtx>, mut protData: Ptr<u8>, mut propsSize: Ptr<usize>) -> i32 {\n    if (protData == NULL!()) {\n        CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"protData is NULL\"));\n        return CMPT_ENC_ERROR_HEAD!();\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE!()) {\n        CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"propsSize need 5 bytes, get {}\"), *propsSize);\n        return CMPT_ENC_ERROR_HEAD!();\n    }\n\n    CmptlzWriteLE32Bit((protData + 1), encCtx.dicSize);\n    protData[0] = ((encCtx.posBits * CMPTLZ_POS_STATE_MAX!() + encCtx.litPos) * CMPTLZ_LIT_CTX_MAX!() + encCtx.litCtx).cast();\n    *propsSize = CMPTLZ_PROPS_SIZE!();\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608738749)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_head_c.rs:16:9\n   |\n16 |         CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"protData is NULL\"));\n   |         ---------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:14:39\n   |\n14 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[$(&$args), *]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_head_c.rs:21:9\n   |\n21 |         CMPTLZ_LOG!(CMPT_ERROR_DATA!(), cstr!(\"propsSize need 5 bytes, get {}\"), *propsSize);\n   |         ------------------------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}",
            "rust_code": "pub fn CmptlzFreeAll(mut encCtx: Ptr<CmptLzEncCtx>, mut alloc: Ptr<CmptLzMemHook>) {\n    if (encCtx == NULL!()) {\n        return;\n    }\n\n    if (encCtx.mfCtx != NULL!()) {\n        if (encCtx.mfCtx.hash != NULL!()) {\n            alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n            encCtx.mfCtx.hash = NULL!();\n        }\n        if (encCtx.mfCtx.son != NULL!()) {\n            alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n            encCtx.mfCtx.son = NULL!();\n        }\n        alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n        encCtx.mfCtx = NULL!();\n    }\n\n    if (encCtx.rcCtx != NULL!()) {\n        if (encCtx.rcCtx.bufBase != NULL!()) {\n            alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n            encCtx.rcCtx.bufBase = NULL!();\n        }\n        alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n        encCtx.rcCtx = NULL!();\n    }\n\n    alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n    encCtx = NULL!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608741365)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:12:19\n   |\n12 |             alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n   |                   ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n12 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n   |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:16:19\n   |\n16 |             alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n   |                   ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n16 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n   |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:19:15\n   |\n19 |         alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n   |               ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n19 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n   |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:25:19\n   |\n25 |             alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n   |                   ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n25 |             (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n   |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:28:15\n   |\n28 |         alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n   |               ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n28 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n   |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:32:11\n   |\n32 |     alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |           ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n32 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |     +                +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx);\n\n    res = CmptEncodeAll(encCtx);\n\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n\n    *destLen -= encCtx->rcCtx->outBufLeft;\n\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}",
            "rust_code": "pub fn CmptlzEncodeIO(mut encCtx: Ptr<CmptLzEncCtx>, mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptMfPrepare Fail!\"));\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptRcPrepare Fail!\"));\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx);\n\n    res = CmptEncodeAll(encCtx);\n\n    if (res != 0) {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG!(res, cstr!(\"CmptEncode Process Fail!\"));\n        return res;\n    }\n\n    *destLen -= encCtx.rcCtx.outBufLeft;\n\n    if (encCtx.nowpos64 != srcLen) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptEncode FileSize Fail!\"));\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE!();\n    }\n\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608745566)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:15:9\n   |\n15 |         CMPTLZ_LOG!(res, cstr!(\"CmptMfPrepare Fail!\"));\n   |         ---------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:22:9\n   |\n22 |         CMPTLZ_LOG!(res, cstr!(\"CmptRcPrepare Fail!\"));\n   |         ---------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:33:9\n   |\n33 |         CMPTLZ_LOG!(res, cstr!(\"CmptEncode Process Fail!\"));\n   |         --------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:40:9\n   |\n40 |         CMPTLZ_LOG!(res, cstr!(\"CmptEncode FileSize Fail!\"));\n   |         ---------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_c.rs:39:28\n   |\n39 |     if (encCtx.nowpos64 != srcLen).as_bool() {\n   |         ---------------    ^^^^^^ expected `u64`, found `usize`\n   |         |\n   |         expected because this is `u64`\n   |\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n   |\n39 |     if (encCtx.nowpos64 != srcLen.try_into().unwrap()).as_bool() {\n   |                                  ++++++++++++++++++++\n\nSome errors have detailed explanations: E0308, E0412.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptlzEncode(mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut src: Ptr<u8>, mut srcLen: usize, mut props: Ptr<CmptlzEncParam>, mut propsEncoded: Ptr<u8>, mut propsSize: Ptr<usize>, mut writeEndMark: i32, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n    if (alloc == NULL!()) || (alloc.CmptLzAlloc == NULL!()) || (alloc.CmptLzFree == NULL!()) {\n        CMPTLZ_LOG!(CMPT_ENC_ERROR_PARAM!(), cstr!(\"Cmptlz input wrong param!\"));\n        return CMPT_ENC_ERROR_PARAM!();\n    }\n    let mut encCtx: Ptr<CmptLzEncCtx> = CmptInitCctx(alloc, writeEndMark).cast::<Ptr<CmptLzEncCtx>>();\n    if (encCtx == NULL!()) {\n        CMPTLZ_LOG!(CMPT_ENC_CTX_INIT_FAIL!(), cstr!(\"CmptInitCctx Fail!\"));\n        return CMPT_ENC_CTX_INIT_FAIL!();\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0) {\n        alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n        CMPTLZ_LOG!(res, cstr!(\"CmptHeadWrite Fail!\"));\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptlzEncode I / O Fail!\"));\n    }\n    return res;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608753754)\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:18:9\n   |\n18 |         CMPTLZ_LOG!(CMPT_ENC_ERROR_PARAM!(), cstr!(\"Cmptlz input wrong param!\"));\n   |         ------------------------------------------------------------------------ in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:23:9\n   |\n23 |         CMPTLZ_LOG!(CMPT_ENC_CTX_INIT_FAIL!(), cstr!(\"CmptInitCctx Fail!\"));\n   |         ------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:30:9\n   |\n30 |         CMPTLZ_LOG!(res, cstr!(\"CmptHeadWrite Fail!\"));\n   |         ---------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0412]: cannot find type `size_t` in this scope\n  --> src/src/public/cmptlz_log_h.rs:11:39\n   |\n11 |         CmptlzLogWrite($error_code as size_t, __FUNCTION__!().cast(), __LINE__!().cast(), $fmt.cast(), &[]);\n   |                                       ^^^^^^ not found in this scope\n   |\n  ::: src/src/encode/cmptlz_enc_c.rs:35:9\n   |\n35 |         CMPTLZ_LOG!(res, cstr!(\"CmptlzEncode I / O Fail!\"));\n   |         --------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPTLZ_LOG` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_c.rs:29:15\n   |\n29 |         alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |               ^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzFree` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n   |\n29 |         (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n   |         +                +\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t CmptMfAvail(const CmptMfCtx *mf)\n    {\n        return mf->srcLen - mf->readPos;\n    }",
            "rust_code": "pub fn CmptMfAvail(mut mf: Ptr<CmptMfCtx>) -> u32 {\n    return (mf.srcLen - mf.readPos).cast();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608761601)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_inner_h.rs:109:25\n    |\n109 |     return (mf.srcLen - mf.readPos).cast();\n    |                         ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:109:23\n    |\n109 |     return (mf.srcLen - mf.readPos).cast();\n    |                       ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t PosSlotHelper(uint32_t n)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return 31 - (uint32_t)__builtin_clz(n);\n#else\n    uint32_t i = 31;\n    if ((n & 0xFFFF0000) == 0)\n    {\n        n <<= 16;\n        i = 15;\n    }\n    if ((n & 0xFF000000) == 0)\n    {\n        n <<= 8;\n        i -= 8;\n    }\n    if ((n & 0xF0000000) == 0)\n    {\n        n <<= 4;\n        i -= 4;\n    }\n    if ((n & 0xC0000000) == 0)\n    {\n        n <<= 2;\n        i -= 2;\n    }\n    if ((n & 0x80000000) == 0)\n        --i;\n    return i;\n#endif\n    }",
            "rust_code": "pub fn PosSlotHelper(mut n: u32) -> u32 {\n    #[cfg(all(defined(__GNUC__), __GNUC__ >= 3)]\n    return (31 - __builtin_clz!(n).cast::<u32>());\n    #[cfg(not(all(defined(__GNUC__), __GNUC__ >= 3))]\n    let mut i: u32 = 31;\n    if (n & 0xFFFF0000 == 0) {\n        n <<= 16;\n        i = 15;\n    }\n    if (n & 0xFF000000 == 0) {\n        n <<= 8;\n        i -= 8;\n    }\n    if (n & 0xF0000000 == 0) {\n        n <<= 4;\n        i -= 4;\n    }\n    if (n & 0xC0000000 == 0) {\n        n <<= 2;\n        i -= 2;\n    }\n    if (n & 0x80000000 == 0) {\n        i -= 1;\n    }\n    return i;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608763506)\nerror: mismatched closing delimiter: `]`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:119:10\n    |\n119 |     #[cfg(all(defined(__GNUC__), __GNUC__ >= 3)]\n    |      -   ^                                     ^ mismatched closing delimiter\n    |      |   |\n    |      |   unclosed delimiter\n    |      closing delimiter possibly meant for this\n\nerror: mismatched closing delimiter: `]`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:121:10\n    |\n121 |     #[cfg(not(all(defined(__GNUC__), __GNUC__ >= 3))]\n    |      -   ^ unclosed delimiter                       ^ mismatched closing delimiter\n    |      |\n    |      closing delimiter possibly meant for this\n\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t PosSloter(uint32_t dist)\n    {\n        if (dist <= 4)\n        {\n            return dist;\n        }\n        uint32_t helper = PosSlotHelper(dist);\n        return (helper + helper + ((dist >> (helper - 1)) & 1));\n    }",
            "rust_code": "pub fn PosSloter(mut dist: u32) -> u32 {\n    if (dist <= 4) {\n        return dist;\n    }\n    let mut helper: u32 = PosSlotHelper(dist);\n    return (helper + helper + ((dist >> (helper - 1)) & 1);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608764446)\nerror: mismatched closing delimiter: `}`\n   --> src/src/encode/cmptlz_enc_inner_h.rs:128:12\n    |\n123 | pub fn PosSloter(mut dist: u32) -> u32 {\n    |                                        - closing delimiter possibly meant for this\n...\n128 |     return (helper + helper + ((dist >> (helper - 1)) & 1).cast();\n    |            ^ unclosed delimiter\n129 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static void CmptlzMfGenHashTable(CmptMfCtx *mf)\n{\n    uint32_t *hashRootTable = mf->hashRootTable;\n    const uint32_t poly32 = 0xEDB88320;\n    uint32_t i, j;\n    for (i = 0; i < CMPT_MF_HASH_TABLE_SIZE; i++)\n    {\n        uint32_t value = i;\n        for (j = 0; j < 8; j++)\n        {\n            if (value & 1)\n            {\n                value = (value >> 1) ^ poly32;\n            }\n            else\n            {\n                value >>= 1;\n            }\n        }\n        hashRootTable[i] = value;\n    }\n    return;\n}",
            "rust_code": "pub fn CmptlzMfGenHashTable(mut mf: Ptr<CmptMfCtx>) {\n    let mut hashRootTable: Ptr<u32> = mf.hashRootTable.cast();\n    let mut poly32: u32 = 0xEDB88320;\n    let mut i: u32 = Default::default();\n    let mut j: u32 = Default::default();\n    c_for!(i = 0; i < CMPT_MF_HASH_TABLE_SIZE!(); i.suffix_plus_plus(); {\n        let mut value: u32 = i;\n        c_for!(j = 0; j < 8; j.suffix_plus_minus(); {\n            if (value & 1).as_bool() {\n                value = (value >> 1) ^ poly32;\n            } else {\n                value >>= 1;\n            }\n        });\n        hashRootTable[i] = value;\n    });\n    return;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608765268)\nerror[E0599]: no method named `suffix_plus_minus` found for type `u32` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:142:32\n    |\n142 |         c_for!(j = 0; j < 8; j.suffix_plus_minus(); {\n    |                                ^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `suffix_minus_minus` with a similar name\n    |\n142 |         c_for!(j = 0; j < 8; j.suffix_minus_minus(); {\n    |                                ~~~~~~~~~~~~~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}",
            "rust_code": "pub fn CmptMfPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    if (mf == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    c_memset_s!(mf, c_sizeof!(CmptMfCtx), 0, c_sizeof!(CmptMfCtx)).cast::<Void>();\n\n    encCtx.mfCtx = mf;\n    mf.cycleSize = encCtx.dicSize + 1;\n    let mut hashMask: u32 = encCtx.dicSize - 1;\n    CMPT_HASH_MASK_CALC!(hashMask);\n    mf.hashMask = hashMask;\n    hashMask += 1;\n    hashMask += CMPTLZ_HASH_2_SIZE!();\n    hashMask += CMPTLZ_HASH_3_SIZE!();\n    mf.hashCount = hashMask;\n    mf.sonsCount = mf.cycleSize * 2;\n    mf.hash = NULL!();\n    mf.son = NULL!();\n    mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    c_memset_s!(mf.hash, mf.hashCount * c_sizeof!(u32), 0, mf.hashCount * c_sizeof!(u32)).cast::<Void>();\n    if (mf.hash == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    c_memset_s!(mf.son, mf.sonsCount * c_sizeof!(u32), 0, mf.sonsCount * c_sizeof!(u32)).cast::<Void>();\n    if (mf.son == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n\n    CmptlzMfGenHashTable(mf);\n    mf.srcStart = src;\n    mf.srcLen = srcLen;\n    mf.offset = mf.cycleSize;\n    mf.niceLen = encCtx.numFastBytes;\n    mf.depth = CMPT_MF_BASE_DEPTH!() + mf.niceLen / 2;\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608767984)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:141:80\n    |\n141 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n    |                                  |\n    |                                  arguments to this function are incorrect\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:141:34\n    |\n141 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    |                 --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<TagCmptMatchFinder>`, found `Ptr<u8>`\n    |                 |\n    |                 expected due to this\n    |\n    = note: expected struct `memory::ptr::Ptr<TagCmptMatchFinder>`\n               found struct `memory::ptr::Ptr<u8>`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:159:61\n    |\n159 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    |               -------------------                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n    |               |\n    |               arguments to this function are incorrect\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n159 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), (mf.hashCount * c_sizeof!(u32)).try_into().unwrap());\n    |                                                             +                             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:159:15\n    |\n159 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    |     -------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u32>`, found `Ptr<u8>`\n    |     |\n    |     expected due to the type of this binding\n    |\n    = note: expected struct `memory::ptr::Ptr<u32>`\n               found struct `memory::ptr::Ptr<u8>`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:164:59\n    |\n164 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    |              -------------------                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n    |              |\n    |              arguments to this function are incorrect\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n164 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), (mf.sonsCount * c_sizeof!(u32)).try_into().unwrap());\n    |                                                           +                             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:164:14\n    |\n164 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    |     ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u32>`, found `Ptr<u8>`\n    |     |\n    |     expected due to the type of this binding\n    |\n    = note: expected struct `memory::ptr::Ptr<u32>`\n               found struct `memory::ptr::Ptr<u8>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "static uint32_t CmptlzBt4Finder(CmptMfCtx *mf, CmptlzMatchPair *matches)\n{\n    const uint32_t niceLen = mf->niceLen;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t temp, hash2Value, hash3Value, hashValue;\n    uint32_t longestLen = 1, matchesCount = 0;\n    CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    uint32_t delta2 = pos - mf->hash[hash2Value];\n    uint32_t delta3 = pos - mf->hash[CMPTLZ_FIX_3_HASH + hash3Value];\n    uint32_t curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n    CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0)\n    {\n        longestLen = CmptMemCmpLenSafe(cur, cur - delta2, longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen)\n        {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS(mf);\n            return matchesCount;\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES)\n    {\n        longestLen = CMPT_MF_MATCH_3_BYTES;\n    }\n    matchesCount = (uint32_t)(CmptBtFind(mf, curMatch, matches + matchesCount, longestLen) - matches);\n\n    CMPT_MF_MOVE_POS(mf);\n    return matchesCount;\n}",
            "rust_code": "pub fn CmptlzBt4Finder(mut mf: Ptr<CmptMfCtx>, mut matches: Ptr<CmptlzMatchPair>) -> u32 {\n    let niceLen: u32 = mf.niceLen;\n    let cur: Ptr<u8> = (mf.srcStart + mf.readPos).cast::<Ptr<u8>>();\n    let pos: u32 = (mf.readPos + mf.offset);\n    let mut temp: u32 = Default::default();\n    let mut hash2Value: u32 = Default::default();\n    let mut hash3Value: u32 = Default::default();\n    let mut hashValue: u32 = Default::default();\n    let mut longestLen: u32 = 1;\n    let mut matchesCount: u32 = 0;\n    CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    let delta2: u32 = (pos - mf.hash[hash2Value]);\n    let delta3: u32 = (pos - mf.hash[CMPTLZ_FIX_3_HASH!() + hash3Value]);\n    let curMatch: u32 = mf.hash[CMPTLZ_FIX_4_HASH!() + hashValue];\n    CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES!(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES!(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0) {\n        longestLen = CmptMemCmpLenSafe(cur, (cur - delta2), longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen) {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS!(mf);\n            return matchesCount;\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES!()) {\n        longestLen = CMPT_MF_MATCH_3_BYTES!();\n    }\n    matchesCount = (CmptBtFind(mf, curMatch, (matches + matchesCount), longestLen) - matches).cast::<u32>();\n\n    CMPT_MF_MOVE_POS!(mf);\n    return matchesCount;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608771445)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:55:23\n    |\n55  |         $temp = (*$mf.lock()).hashRootTable[$cur[0]] ^ $cur[1];\n    |                       ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n257 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |     ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:64\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n257 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |     ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:110\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                                                              ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n257 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |     ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:66:15\n    |\n66  |         (*$mf.lock()).hash[$hash2Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n262 |     CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |     ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:67:15\n    |\n67  |         (*$mf.lock()).hash[CMPTLZ_FIX_3_HASH!() + $hash3Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n262 |     CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |     ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:68:15\n    |\n68  |         (*$mf.lock()).hash[CMPTLZ_FIX_4_HASH!() + $hashValue] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n262 |     CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |     ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:76:28\n    |\n76  |         if $delta2 < (*$mf.lock()).cycleSize && *($cur - $delta2) == *$cur {\n    |                            ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n263 |     CMPT_HASH_FIND_2_BYTES!(mf, delta2, longestLen, matchesCount, cur, matches);\n    |     --------------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_FIND_2_BYTES` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:89:50\n    |\n89  |         if $delta2 != $delta3 && $delta3 < (*$mf.lock()).cycleSize && *($cur - $delta3) == *$cur {\n    |                                                  ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n264 |     CMPT_HASH_FIND_3_BYTES!(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n    |     ----------------------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_FIND_3_BYTES` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
        },
        {
            "c_code": "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}",
            "rust_code": "pub fn CmptlzMatchSkiper(mut mf: Ptr<CmptMfCtx>, mut amount: u32) {\n    mf.readAhead += amount;\n    let mut pos: u32;\n    let mut temp: u32;\n    let mut hash2Value: u32;\n    let mut hash3Value: u32;\n    let mut hashValue: u32;\n    let mut curMatch: u32;\n    let niceLen: u32 = mf.niceLen;\n    c_do!({\n        let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n        if CMPTLZ_LIKELY!(niceLen <= lenLimit) {\n            lenLimit = niceLen;\n        } else {\n            mf.readPos += 1;\n            continue;\n        }\n        let mut cur: Ptr<u8> = (mf.srcStart + mf.readPos);\n        pos = mf.readPos + mf.offset;\n        CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf.hash[CMPTLZ_FIX_4_HASH!() + hashValue];\n        CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS!(mf);\n    } while amount.prefix_minus_minus() != 0);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608778735)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:262:45\n    |\n262 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n    |                                             ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:262:33\n    |\n262 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n    |                           ---   ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n    |                           |\n    |                           expected due to this\n    |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n    |\n262 |         let mut lenLimit: u32 = (mf.srcLen - mf.readPos).try_into().unwrap();\n    |                                 +                      +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:262:43\n    |\n262 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n    |                                           ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:55:23\n    |\n55  |         $temp = (*$mf.lock()).hashRootTable[$cur[0]] ^ $cur[1];\n    |                       ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n271 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |         ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:64\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n271 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |         ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:58:110\n    |\n58  |         $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ((*$mf.lock()).hashRootTable[$cur[3]] << 5)) & (*$mf.lock()).hashMask;\n    |                                                                                                              ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n271 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    |         ------------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:66:15\n    |\n66  |         (*$mf.lock()).hash[$hash2Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n273 |         CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |         ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:67:15\n    |\n67  |         (*$mf.lock()).hash[CMPTLZ_FIX_3_HASH!() + $hash3Value] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n273 |         CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |         ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<TagCmptMatchFinder>` in the current scope\n   --> src/src/encode/cmptlz_enc_mf_c.rs:68:15\n    |\n68  |         (*$mf.lock()).hash[CMPTLZ_FIX_4_HASH!() + $hashValue] = $pos;\n    |               ^^^^ method not found in `Ptr<TagCmptMatchFinder>`\n...\n273 |         CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n    |         ------------------------------------------------------------- in this macro invocation\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n    = note: this error originates in the macro `CMPT_HASH_UPDATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
        },
        {
            "c_code": "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}",
            "rust_code": "pub fn CmptlzMatchFinder(mut mf: Ptr<CmptMfCtx>, mut pCount: Ptr<u32>, mut matches: Ptr<CmptlzMatchPair>) -> u32 {\n    if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen) {\n        *pCount = 0;\n        mf.readPos += 1;\n        mf.readAhead += 1;\n        return 0;\n    }\n    let mut count: u32 = CmptlzBt4Finder(mf, matches);\n    if (count == 0) {\n        *pCount = 0;\n        mf.readAhead += 1;\n        return 0;\n    }\n    let mut longestLen: u32 = matches[count - 1].len;\n    if (longestLen == mf.niceLen) {\n        let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n        let mut p1: Ptr<u8> = (mf.srcStart + mf.readPos - 1);\n        let mut p2: Ptr<u8> = (p1 - matches[count - 1].dist - 1);\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf.readAhead += 1;\n    return longestLen;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608781961)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:258:37\n    |\n258 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen).as_bool() {\n    |                                     ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:258:35\n    |\n258 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen).as_bool() {\n    |                                   ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:258:50\n    |\n258 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen).as_bool() {\n    |                         ----------------------   ^^^^^^^^^^ expected `usize`, found `u32`\n    |                         |\n    |                         expected because this is `usize`\n    |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    |\n258 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen.try_into().unwrap()).as_bool() {\n    |                                                            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_mf_c.rs:272:64\n    |\n272 |         let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n    |                                                                ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n   --> src/src/encode/cmptlz_enc_mf_c.rs:272:62\n    |\n272 |         let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n    |                                                              ^ no implementation for `usize - u32`\n    |\n    = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n    = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n              `&usize` implements `std::ops::Sub<usize>`\n              `&usize` implements `std::ops::Sub`\n              `usize` implements `std::ops::Sub<&usize>`\n              `usize` implements `std::ops::Sub<types::num::Num>`\n              `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n\n    encCtx->rcCtx = rc;\n\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}",
            "rust_code": "pub fn CmptRcPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx));\n    if (rc == NULL!()) {\n        return CMPT_ENC_RC_INIT_FAIL!();\n    }\n    c_memset_s!(rc, c_sizeof!(CmptRcCtx), 0, c_sizeof!(CmptRcCtx)).cast::<Void>();\n\n    encCtx.rcCtx = rc;\n\n    rc.bufBase = (alloc.CmptLzAlloc)(CMPTLZ_RC_BUF_HANDLE!(), CMPTLZ_RC_BUFFER_SIZE!());\n    c_memset_s!(rc.bufBase, CMPTLZ_RC_BUFFER_SIZE!(), 0, CMPTLZ_RC_BUFFER_SIZE!()).cast::<Void>();\n    if (rc.bufBase == NULL!()) {\n        return CMPT_ENC_RC_INIT_FAIL!();\n    }\n\n    rc.outBufLeft = *destLen;\n    rc.outBuf = dest;\n\n    rc.buf = rc.bufBase;\n    rc.range = 0xFFFFFFFF;\n    rc.cacheSize = 0;\n    rc.cache = 0;\n    rc.low = 0;\n    return 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608789048)\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_c.rs:13:80\n   |\n13 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx));\n   |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n   |                                  |\n   |                                  arguments to this function are incorrect\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_c.rs:13:34\n   |\n13 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx));\n   |                 --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<CmptRcCtx>`, found `Ptr<u8>`\n   |                 |\n   |                 expected due to this\n   |\n   = note: expected struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>`\n              found struct `memory::ptr::Ptr<u8>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptRcShiftLow(mut rcCtx: Ptr<CmptRcCtx>) -> i32 {\n    let mut res: i32 = CMPT_OK!();\n    let mut lowLow32: u32 = rcCtx.low.cast::<u32>();\n    let mut high: u64 = (rcCtx.low >> 32).cast::<u32>().cast::<u64>();\n    rcCtx.low = (lowLow32 << 8).cast();\n    CMPT_RC_BREAK_CHECK!(rcCtx, rcCtx.buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0) {\n        let mut buf: Ptr<u8> = rcCtx.buf;\n        *buf = (rcCtx.cache + high).cast::<u8>();\n        buf += 1;\n        rcCtx.buf = buf;\n        rcCtx.cache = (lowLow32 >> 24).cast::<u8>();\n        CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n        high += 0xFF;\n        loop {\n            let mut buf1: Ptr<u8> = rcCtx.buf;\n            CMPT_RC_BREAK_SHIFTING!(rcCtx, buf1, res);\n            *buf1 = high.cast::<u8>();\n            buf1 += 1;\n            rcCtx.buf = buf1;\n            rcCtx.cacheSize -= 1;\n        }\n        CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n    } else {\n        rcCtx.cacheSize += 1;\n    }\n    return res;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608791903)\nerror[E0423]: expected value, found macro `CMPT_OK`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:45:20\n   |\n45 |             return CMPT_OK;\n   |                    ^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:42:9\n   |\n42 |         CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n   |         ---------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BREAK_SHIFTING` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_OK`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:45:20\n   |\n45 |             return CMPT_OK;\n   |                    ^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:46:13\n   |\n46 |             CMPT_RC_BREAK_SHIFTING!(rcCtx, buf1, res);\n   |             ----------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BREAK_SHIFTING` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_OK`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:45:20\n   |\n45 |             return CMPT_OK;\n   |                    ^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:52:9\n   |\n52 |         CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n   |         ---------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BREAK_SHIFTING` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_c.rs:41:23\n   |\n41 |         rcCtx.cache = (lowLow32 >> 24).cast::<u8>();\n   |         -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `u8`\n   |         |\n   |         expected due to the type of this binding\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "int CmptRcFlushData(CmptRcCtx *rcCtx)\n{\n    int i;\n    int res;\n    for (i = 0; i < 5; i++)\n    {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n    }\n    return res;\n}",
            "rust_code": "pub fn CmptRcFlushData(mut rcCtx: Ptr<CmptRcCtx>) -> i32 {\n    let mut i: i32;\n    let mut res: i32;\n    c_for!(i = 0; i < 5; i.suffix_plus_plus(); {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK!()) {\n            break;\n        }\n    });\n    return res;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608796132)\nerror[E0381]: used binding `res` is possibly-uninitialized\n  --> src/src/encode/cmptlz_enc_rc_c.rs:44:12\n   |\n37 |     let mut res: i32;\n   |         ------- binding declared here but left uninitialized\n38 |     c_for!(i = 0; i < 5; i.suffix_plus_plus(); {\n39 |         res = CmptRcShiftLow(rcCtx.cast()).cast();\n   |         ----------------------------------------- binding initialized here in some conditions\n...\n44 |     return res.cast();\n   |            ^^^ `res` used here but it is possibly-uninitialized\n\nFor more information about this error, try `rustc --explain E0381`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int CmptRcLenProcess(CmptLenEncoder *lenEncoder, CmptRcCtx *rcCtx, uint32_t len, uint64_t posState)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t newBound, bit0Prob;\n    len -= CMPTLZ_MATCH_LEN_MIN;\n\n    CmptlzProb *probs = lenEncoder->low;\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND)\n    {\n        CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs += CMPT_LEN_BOUND;\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND * CMPT_DOUBLE)\n        {\n            CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            rcCtx->range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder->high, len - CMPT_LEN_BOUND * CMPT_DOUBLE);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            return CMPT_OK;\n        }\n        len -= CMPT_LEN_BOUND;\n    }\n\n    uint32_t m, bit;\n    CMPT_RC_BIT_0_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs += (posState << (1 + 3));\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcLenProcess(mut lenEncoder: Ptr<CmptLenEncoder>, mut rcCtx: Ptr<CmptRcCtx>, mut len: u32, mut posState: u64) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut newBound: u32;\n    let mut bit0Prob: u32;\n    len -= CMPTLZ_MATCH_LEN_MIN!();\n\n    let mut probs: Ptr<CmptlzProb> = lenEncoder.low.cast();\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND!()) {\n        CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        if (shiftRes != CMPT_OK!()) {\n            return shiftRes;\n        }\n        probs += CMPT_LEN_BOUND!();\n        CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND!() * CMPT_DOUBLE!()) {\n            CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            if (shiftRes != CMPT_OK!()) {\n                return shiftRes;\n            }\n            rcCtx.range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder.high.cast(), len - CMPT_LEN_BOUND!() * CMPT_DOUBLE!());\n            if (shiftRes != CMPT_OK!()) {\n                return shiftRes;\n            }\n            return CMPT_OK!();\n        }\n        len -= CMPT_LEN_BOUND!();\n    }\n\n    let mut m: u32;\n    let mut bit: u32;\n    CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    if (shiftRes != CMPT_OK!()) {\n        return shiftRes;\n    }\n    probs += (posState << (1 + 3)).cast::<u32>();\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    if (shiftRes != CMPT_OK!()) {\n        return shiftRes;\n    }\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    if (shiftRes != CMPT_OK!()) {\n        return shiftRes;\n    }\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    if (shiftRes != CMPT_OK!()) {\n        return shiftRes;\n    }\n    rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608798608)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:33\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:82:5\n   |\n82 |     CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     ------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:94:5\n   |\n94 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n    |\n83  |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n    |                      ^^^^^^^^^^^^^^^^^^^ not a value\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:100:5\n    |\n100 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:53:23\n   |\n53 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n57 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |     ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:59:9\n    |\n59  |         CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |         ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:53:23\n   |\n53 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n64 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n   |         ------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:106:18\n    |\n106 |         (*$rcCtx.lock()).low += $newBound;\n    |                  ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:66:13\n    |\n66  |             CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    |             ------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:97:18\n   |\n97 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5) as CmptlzProb);\n   |         ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n   |         |\n   |         expected due to the type of this binding\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:82:5\n   |\n82 |     CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n   |     ------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:53:23\n   |\n53 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:88:5\n   |\n88 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:53:23\n   |\n53 |     let mut bit0Prob: u32;\n   |                       --- expected due to this type\n...\n94 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:94:5\n   |\n94 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:94:5\n   |\n94 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:94:5\n   |\n94 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |     -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n    |\n65  |         $bit0Prob = *$prob;\n    |                     ^^^^^^ expected `u32`, found `u16`\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:53:23\n    |\n53  |     let mut bit0Prob: u32;\n    |                       --- expected due to this type\n...\n100 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n   --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n    |\n80  |             (*$rcCtx.lock()).low += mask;\n    |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:100:5\n    |\n100 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:100:5\n    |\n100 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n   --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n    |\n85  |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n    |                       ^^ no implementation for `u32 += i32`\n    |\n   ::: src/src/encode/cmptlz_enc_rc_c.rs:100:5\n    |\n100 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    |     -------------------------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n              `u32` implements `std::ops::AddAssign<&u32>`\n              `u32` implements `std::ops::AddAssign`\n    = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 21 previous errors\n"
        },
        {
            "c_code": "inline int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcPosSlotProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut len: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = encCtx.rcCtx.range;\n    let mut sym: u32 = posSlot + (1 << 6);\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut bit: u32;\n    let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n    c_do!({\n        let mut posSlotProbTableIndex: Ptr<CmptlzProb> = probs + (sym >> CMPTLZ_DIST_SLOT_BITS!());\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS!() - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } while sym < (1 << (CMPTLZ_DIST_SLOT_BITS!() * 2)));\n    encCtx.rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608806371)\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:24:64\n   |\n24 | macro_rules! GET_LEN_TO_POS_STATE { ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 ...\n   |                                                                ^^^^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:58\n   |\n61 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n   |                                                          -------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:24:111\n   |\n24 | ... < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 } } }\n   |                                                      ^^^^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:61:58\n   |\n61 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n   |                                                          -------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:66:9\n   |\n66 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:66:9\n   |\n66 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:66:9\n   |\n66 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:66:9\n   |\n66 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n   |         --------------------------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
        },
        {
            "c_code": "static inline int CmptRcReverseProcess(CmptRcCtx *rcCtx, CmptlzProb *probs, uint32_t numBits, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    uint32_t m = 1;\n    do\n    {\n        bit = sym & 1;\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        m = (m << 1) | bit;\n    } while (--numBits);\n\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcReverseProcess(mut rcCtx: Ptr<CmptRcCtx>, mut probs: Ptr<CmptlzProb>, mut numBits: u32, mut sym: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut bit0Prob: u32 = Default::default();\n    let mut newBound: u32 = Default::default();\n    let mut bit: u32 = Default::default();\n    let mut m: u32 = 1;\n    c_do!({\n        bit = (sym & 1);\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        m = ((m << 1) | bit);\n    } while numBits.prefix_minus_minus() != 0);\n\n    rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608808416)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:83:22\n   |\n83 |             mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));\n   |                      ^^^^^^^^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:69:9\n   |\n69 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:65:21\n   |\n65 |         $bit0Prob = *$prob;\n   |                     ^^^^^^ expected `u32`, found `u16`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:62:23\n   |\n62 |     let mut bit0Prob: u32 = Default::default();\n   |                       --- expected due to this type\n...\n69 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<cmptlz_enc_struct_h::CmptRcCtx>` in the current scope\n  --> src/src/encode/cmptlz_enc_rc_h.rs:80:22\n   |\n80 |             (*$rcCtx.lock()).low += mask;\n   |                      ^^^^ method not found in `Ptr<CmptRcCtx>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `lock` not found for this struct\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:69:9\n   |\n69 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:26\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:69:9\n   |\n69 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n  --> src/src/encode/cmptlz_enc_rc_h.rs:85:23\n   |\n85 |             $bit0Prob += (mask - ($bit0Prob as u32)) as i32 >> 5;\n   |                       ^^ no implementation for `u32 += i32`\n   |\n  ::: src/src/encode/cmptlz_enc_rc_c.rs:69:9\n   |\n69 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n   |         -------------------------------------------------------------------------------- in this macro invocation\n   |\n   = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n   = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n             `u32` implements `std::ops::AddAssign<&u32>`\n             `u32` implements `std::ops::AddAssign`\n   = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}",
            "rust_code": "pub fn CmptRcDistProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut dist: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n\n    let mut footerBits: u32 = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2!()) {\n        let mut base: u32 = ((2 | (posSlot & 1)) << footerBits;\n        shiftRes = CmptRcReverseProcess(encCtx.rcCtx, (encCtx.probDistSpecial + base), footerBits, dist);\n        if (shiftRes != CMPT_OK!()) {\n            return shiftRes;\n        }\n    } else {\n        let mut pos2: u32 = (dist | 0xF) << (32 - footerBits);\n        let mut range: u32 = encCtx.rcCtx.range;\n        c_do!({\n            range >>= 1;\n            encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n            if (shiftRes != CMPT_OK!()) {\n                return shiftRes;\n            }\n        } while pos2 != 0xF0000000);\n\n        let mut m: u32 = 1;\n        let mut bit: u32;\n        let mut bit0Prob: u32 = Default::default();\n        let mut newBound: u32 = Default::default();\n        let mut k: i32;\n        c_for!(k = 0; k < CMPTLZ_ALIGN_BITS!() - 1; k.suffix_plus_plus(); {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            if (shiftRes != CMPT_OK!()) {\n                return shiftRes;\n            }\n            m = (m << 1) + bit;\n        });\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        if (shiftRes != CMPT_OK!()) {\n            return shiftRes;\n        }\n        encCtx.rcCtx.range = range;\n    }\n    return CMPT_OK!();\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608810916)\nerror: mismatched closing delimiter: `}`\n  --> src/src/encode/cmptlz_enc_rc_c.rs:69:29\n   |\n68 |     if (dist < CMPT_DIST_LIMIT_2!()).as_bool() {\n   |                                                - closing delimiter possibly meant for this\n69 |         let mut base: u32 = ((2 | (posSlot & 1)) << footerBits;\n   |                             ^ unclosed delimiter\n...\n74 |     } else {\n   |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void CmptlzSetParam(CmptLzEncCtx *encCtx, const CmptlzEncParam *props)\n{\n    CmptlzEncParam param = *props;\n\n    CmptlzParamNormalize(&param);\n\n    encCtx->dicSize = param.dictSize;\n    encCtx->numFastBytes = param.fastBytes;\n    encCtx->litCtx = param.litCtx;\n    encCtx->litPos = param.litPos;\n    encCtx->posBits = param.posBits;\n    uint32_t i;\n    for (i = 7; i < 32; i++)\n    {\n        if (encCtx->dicSize <= (uint32_t)(1 << i))\n        {\n            break;\n        }\n    }\n    encCtx->distTableSize = i * 2;\n}",
            "rust_code": "pub fn CmptlzSetParam(mut encCtx: Ptr<CmptLzEncCtx>, mut props: Ptr<CmptlzEncParam>) {\n    let mut param: CmptlzEncParam = *props;\n\n    CmptlzParamNormalize(c_ref!(param));\n\n    encCtx.dicSize = param.dictSize;\n    encCtx.numFastBytes = param.fastBytes.cast();\n    encCtx.litCtx = param.litCtx;\n    encCtx.litPos = param.litPos;\n    encCtx.posBits = param.posBits;\n    let mut i: u32 = 7;\n    c_for!(; i < 32; {\n        if (encCtx.dicSize <= (1 << i)) {\n            break;\n        }\n        i.suffix_plus_plus();\n    });\n    encCtx.distTableSize = (i * 2);\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608812502)\nerror: unexpected end of macro invocation\n  --> src/src/encode/cmptlz_enc_init_c.rs:70:6\n   |\n70 |     });\n   |      ^ missing tokens in macro arguments\n   |\n  ::: src/translation_utils/c_alignment/c_for.rs:3:1\n   |\n3  | macro_rules! c_for {\n   | ------------------ when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_for.rs:13:53\n   |\n13 |     ($($init: stmt),+; $cond: expr; $($step: expr),+; $body: block) => {\n   |                                                     ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n\n    CmptlzPriceInit(encCtx);\n\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}",
            "rust_code": "pub fn CmptlzEncPrepare(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut i: u32 = Default::default();\n    let mut j: u32 = Default::default();\n\n    encCtx.encNeedFinish = false;\n    encCtx.cmptlzResponse = 0;\n    encCtx.nowpos64 = 0;\n\n    encCtx.state = 0;\n    encCtx.pbMask = (1 << encCtx.posBits) - 1;\n    encCtx.lpMask = (0x100 << encCtx.litPos) - (0x100 >> encCtx.litCtx);\n    encCtx.posMask = (1 << encCtx.posBits) - 1;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.reps[i] = 0;\n    });\n\n    encCtx.optsCurIndex = 0;\n    encCtx.optEndIndex = 0;\n    c_for!(i = 0; i < CMPT_DP_OPTMAX!(); i.suffix_plus_plus(); {\n        encCtx.opts[i].price = CMPT_INFINITY_PRICE!();\n    });\n\n    c_for!(i = 0; i < CMPTLZ_NUM_STATES!(); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < CMPTLZ_NUM_PB_STATES_MAX!(); j.suffix_plus_plus(); {\n            encCtx.isMatch[i][j] = CMPTLZ_PROB_INIT!();\n            encCtx.isRep0Long[i][j] = CMPTLZ_PROB_INIT!();\n        });\n        encCtx.isRep[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG0[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG1[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG2[i] = CMPTLZ_PROB_INIT!();\n    });\n\n    c_for!(i = 0; i < CMPTLZ_DIST_STATE_TOTAL!(); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS!()); j.suffix_plus_plus(); {\n            encCtx.probDistSlot[i][j] = CMPTLZ_PROB_INIT!();\n        });\n    });\n    c_for!(i = 0; i < CMPT_DIST_LIMIT_2!(); i.suffix_plus_plus(); {\n        encCtx.probDistSpecial[i] = CMPTLZ_PROB_INIT!();\n    });\n    c_for!(i = 0; i < (1 << CMPTLZ_ALIGN_BITS!()); i.suffix_plus_plus(); {\n        encCtx.probAlign[i] = CMPTLZ_PROB_INIT!();\n    });\n\n    encCtx.litMarcov.lcBits = encCtx.litCtx;\n    encCtx.litMarcov.posMask = (1 << encCtx.litPos) - 1;\n\n    c_for!(i = 0; i < (1 << CMPTLZ_LCLP_MAX!()); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < CMPTLZ_LIT_MAX_SIZE!(); j.suffix_plus_plus(); {\n            encCtx.litMarcov.literal[i][j] = CMPTLZ_PROB_INIT!();\n        });\n    });\n\n    c_for!(i = 0; i < (1 << CMPT_LEN_HIGH_BITS!()); i.suffix_plus_plus(); {\n        encCtx.matchLenEncoder.high[i] = CMPTLZ_PROB_INIT!();\n        encCtx.repLenEncoder.high[i] = CMPTLZ_PROB_INIT!();\n        encCtx.matchLenEncoder.low[i] = CMPTLZ_PROB_INIT!();\n        encCtx.repLenEncoder.low[i] = CMPTLZ_PROB_INIT!();\n    });\n\n    CmptlzPriceInit(encCtx);\n\n    encCtx.repLenEncoder.tableSize = encCtx.numFastBytes - 1;\n    encCtx.matchLenEncoder.tableSize = encCtx.numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, c_ref!(encCtx.matchLenEncoder));\n    CmptPriceGenLenTable(encCtx, c_ref!(encCtx.repLenEncoder));\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608817125)\nerror[E0308]: mismatched types\n   --> src/src/encode/cmptlz_enc_init_c.rs:111:31\n    |\n111 |     encCtx.litMarcov.lcBits = encCtx.litCtx;\n    |     -----------------------   ^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}",
            "rust_code": "pub fn CmptInitCctx(mut alloc: Ptr<CmptLzMemHook>, mut writeEndMark: i32) -> Ptr<Void> {\n    let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n    if (handle == NULL!()) {\n        return NULL!();\n    }\n    c_memset_s!(handle, c_sizeof!(CmptLzEncCtx), 0, c_sizeof!(CmptLzEncCtx)).cast::<Void>();\n    let mut encCtx: Ptr<CmptLzEncCtx> = handle;\n    encCtx.endMarker = writeEndMark;\n    encCtx.rcCtx = NULL!();\n    encCtx.mfCtx = NULL!();\n    return encCtx;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608819698)\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<cmptlz_base_h::CmptLzMemHook>` in the current scope\n  --> src/src/encode/cmptlz_enc_init_c.rs:72:39\n   |\n72 |     let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n   |                                       ^^^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `CmptLzAlloc` not found for this struct\n   |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n   |\n72 |     let mut handle: Ptr<Void> = (alloc.CmptLzAlloc)(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n   |                                 +                 +\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/encode/cmptlz_enc_init_c.rs:79:20\n    |\n79  |     encCtx.rcCtx = NULL!();\n    |                    ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/encode/cmptlz_enc_init_c.rs:80:20\n    |\n80  |     encCtx.mfCtx = NULL!();\n    |                    ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/encode/cmptlz_enc_init_c.rs:73:19\n    |\n73  |     if (handle == NULL!()).as_bool() {\n    |                   ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
        },
        {
            "c_code": "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n\n    encCtx->matchPriceCount = 0;\n}",
            "rust_code": "pub fn CmptPriceGenDistTable(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut distState: u32 = 0;\n\n    c_do!({\n        let mut tmpPriceDistSlot: Ptr<u32> = encCtx.priceDistSlotTable[distState].cast();\n\n        c_for!(let mut i: u32 = 0; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx.probDistSlot[distState].cast(), CMPTLZ_DIST_SLOT_BITS!(), i);\n        });\n\n        c_for!(let mut i: u32 = 14; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect(((i >> 1) - 1 - CMPTLZ_ALIGN_BITS!()));\n        });\n\n        c_for!(let mut i: u32 = 0; i < 4; i.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        });\n\n        distState.suffix_plus_plus();\n    } while distState < CMPTLZ_DIST_STATE_TOTAL!());\n\n    c_for!(let mut i: u32 = 4; i < 128; i.suffix_plus_plus(); {\n        let mut distSlot: u32 = PosSloter(i);\n        let mut footerBits: u32 = ((distSlot >> 1) - 1);\n        let mut base: u32 = ((2 | (distSlot & 1)) << footerBits);\n        let mut price: u32 = CmptPriceSymbolReverse(encCtx, (encCtx.probDistSpecial + base - distSlot - 1), footerBits, (i - base));\n\n        c_for!(distState = 0; distState < 4; distState.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = (price + encCtx.priceDistSlotTable[distState][distSlot]);\n        });\n    });\n\n    encCtx.matchPriceCount = 0;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608822329)\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n  --> src/src/encode/cmptlz_enc_price_c.rs:61:92\n   |\n61 | ...   let mut price: u32 = CmptPriceSymbolReverse(encCtx.cast(), (encCtx.probDistSpecial + base - distSlot - 1).cast(), footerBits.cast()...\n   |                                                                   ---------------------- ^ ---- u32\n   |                                                                   |\n   |                                                                   types::array::Array<u16, 128>\n   |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  | pub struct Array<T, const N: usize>(pub [T; N]);\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n  --> /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/ops/arith.rs:77:1\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}",
            "rust_code": "pub fn CmptPriceLiteral(mut encCtx: Ptr<CmptLzEncCtx>, mut matchMode: bool, mut matchByte: u32, mut symbol: u32) -> u32 {\n    let mut pos: u32 = encCtx.litMarcov.pos;\n    let mut prevByte: u32 = encCtx.litMarcov.prevByte;\n    let mut litCtx: u32 = encCtx.litMarcov.lcBits;\n    let mut lpMask: u32 = encCtx.litMarcov.posMask;\n    let mut subCoder: Ptr<CmptlzProb> = CMPT_LIT_SUBCODER!(encCtx.litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    let mut price: u32 = 0;\n    if !matchMode {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    } else {\n        let mut offset: u32 = 0x100;\n        symbol += 1 << 8;\n        c_do!({\n            matchByte <<= 1;\n            let mut matchBit: u32 = (matchByte & offset);\n            let mut subCoderIndex: u32 = (offset + matchBit + (symbol >> 8));\n            let mut bit: u32 = ((symbol >> 7) & 1);\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= !(matchByte ^ symbol);\n        } while symbol < (1 << 16));\n    }\n    return price;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608834823)\nerror[E0308]: mismatched types\n  --> src/src/encode/cmptlz_enc_price_c.rs:6:9\n   |\n6  |         $probs[((($pos) & ($lpMask)) << ($litCtx)) + (($prevByte as u32) >> (8u32 - ($litCtx)))]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u16>`, found `Array<u16, 768>`\n...\n53 |     let mut subCoder: Ptr<CmptlzProb> = CMPT_LIT_SUBCODER!(encCtx.litMarcov.literal, litCtx, lpMask, pos, prevByte);\n   |                       ---------------   --------------------------------------------------------------------------- in this macro invocation\n   |                       |\n   |                       expected due to this\n   |\n   = note: expected struct `memory::ptr::Ptr<u16>`\n              found struct `types::array::Array<u16, 768>`\n   = note: this error originates in the macro `CMPT_LIT_SUBCODER` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n\n    uint32_t b;\n\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}",
            "rust_code": "pub fn CmptPriceGenLenTable(mut encCtx: Ptr<CmptLzEncCtx>, mut lenEncoder: Ptr<CmptLenEncoder>) {\n    let numPosStates: u32 = 1 << encCtx.posBits;\n    let mut b: u32;\n    let mut prob: u32 = lenEncoder.low[0];\n    let mut a: u32;\n    let mut c: u32;\n    let mut posState: u32;\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = (b + CmptPriceBit0(encCtx, lenEncoder.low[1 << CMPT_LEN_LOW_BITS!()]));\n    c_for!(posState = 0; posState < numPosStates; posState.suffix_plus_plus(); {\n        let mut prices: Ptr<u32> = lenEncoder.prices[posState];\n        let mut probs: Ptr<CmptlzProb> = (lenEncoder.low + (posState << (1 + CMPT_LEN_LOW_BITS!())));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, (probs + (1 << CMPT_LEN_LOW_BITS!())), c, (prices + (1 << CMPT_LEN_LOW_BITS!())));\n    });\n    let mut i: u32 = lenEncoder.tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) {\n        let mut probs: Ptr<CmptlzProb> = lenEncoder.high;\n        let mut prices: Ptr<u32> = (lenEncoder.prices[0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!());\n        i -= (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!() - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder.low[(1 << CMPT_LEN_LOW_BITS!())]);\n        c_do!({\n            let mut sym: u32 = (i.prefix_minus_minus() + (1 << (CMPT_LEN_HIGH_BITS!() - 1)));\n            let mut price: u32 = b;\n            c_do!({\n                let mut bit: u32 = (sym & 1);\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while sym >= 2);\n            prob = probs[(i + (1 << (CMPT_LEN_HIGH_BITS!() - 1))];\n            let tmp0 = (i * CMPT_DOUBLE!()).cast::<usize>();\n            prices[tmp0] = (price + CmptPriceBit0(encCtx, prob));\n            prices[(i * CMPT_DOUBLE!() + 1).cast::<usize>()] = (price + CmptPriceBit1(encCtx, prob));\n        } while i != 0);\n        let mut num: usize = (lenEncoder.tableSize - (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) * c_sizeofval!(lenEncoder.prices[0][0]);\n        c_for!(posState = 1; posState < numPosStates; posState.suffix_plus_plus(); {\n            c_memcpy_s!((lenEncoder.prices[posState] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()), CMPT_MF_LONGEST_MATCH!() - 1, (lenEncoder.prices[0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()), num);\n        });\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608848488)\nerror: mismatched closing delimiter: `]`\n  --> src/src/encode/cmptlz_enc_price_c.rs:98:26\n   |\n98 |             prob = probs[(i + (1 << (CMPT_LEN_HIGH_BITS!() - 1))].cast();\n   |                         -^                                      ^ mismatched closing delimiter\n   |                         ||\n   |                         |unclosed delimiter\n   |                         closing delimiter possibly meant for this\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceShortRep(CmptLzEncCtx *encCtx, CmptlzState state, uint32_t posState)\n{\n    return CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRep0Long[state][posState]);\n}",
            "rust_code": "pub fn CmptPriceShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut state: CmptlzState, mut posState: u32) -> u32 {\n    let tmp0 = state;\n    return (CmptPriceBit0(encCtx, encCtx.isRepG0[tmp0][posState]));\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608852180)\nerror: mismatched closing delimiter: `}`\n  --> src/src/encode/cmptlz_enc_price_c.rs:78:12\n   |\n77 | pub fn CmptPriceShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut state: CmptlzState, mut posState: u32) -> u32 {\n   |                                                                                                           - closing delimiter possibly meant for this\n78 |     return (CmptPriceBit0(encCtx.cast(), encCtx.isRepG0[state].cast()).cast() + (CmptPriceBit0(encCtx.cast(), encCtx.isRep0Long[state][po...\n   |            ^ unclosed delimiter\n79 | }\n   | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}",
            "rust_code": "pub fn CmptPriceLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut longRepIndex: u32, mut state: CmptlzState, mut posState: u32) -> u32 {\n    let mut price: u32 = 0;\n    c_switch!(longRepIndex, {\n        0 => {\n            let tmp0 = state;\n            price = (CmptPriceBit0(encCtx, encCtx.isRepG0[tmp0][posState]));\n            break;\n        },\n        1 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit0(encCtx, encCtx.isRepG1[state]));\n            break;\n        },\n        2 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit1(encCtx, encCtx.isRepG1[state]) + CmptPriceBit0(encCtx, encCtx.isRepG2[state]));\n            break;\n        },\n        3 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit1(encCtx, encCtx.isRepG1[state]) + CmptPriceBit1(encCtx, encCtx.isRepG2[state]));\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    return price;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608854214)\nerror: no rules expected `,`\n  --> src/src/encode/cmptlz_enc_price_c.rs:84:27\n   |\n84 |     c_switch!(longRepIndex, {\n   |                           ^ no rules expected this token in macro call\n   |\n  ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n   |\n3  | macro_rules! c_switch {\n   | --------------------- when calling this macro\n   |\nnote: while trying to match `;`\n  --> src/translation_utils/c_alignment/c_switch.rs:5:17\n   |\n5  |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n   |                 ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "uint32_t CmptPriceDistWithLen(CmptLzEncCtx *encCtx, uint32_t dist, uint32_t len, uint32_t posState)\n{\n    const uint32_t distState = CMPT_GET_DIST_STATE(len);\n    uint32_t price;\n    if (dist < 128)\n    {\n        price = encCtx->priceDistTable[distState][dist];\n    }\n    else\n    {\n\n        uint32_t distSlot = PosSloter(dist);\n        price = encCtx->priceDistSlotTable[distState][distSlot] +\n                encCtx->priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS) - 1)];\n    }\n\n    price += CmptPriceLen(&encCtx->matchLenEncoder, len, posState);\n\n    return price;\n}",
            "rust_code": "pub fn CmptPriceDistWithLen(mut encCtx: Ptr<CmptLzEncCtx>, mut dist: u32, mut len: u32, mut posState: u32) -> u32 {\n    let mut distState: u32 = CMPT_GET_DIST_STATE!(len);\n    let mut price: u32;\n    if (dist < 128) {\n        price = encCtx.priceDistTable[distState][dist];\n    } else {\n        let mut distSlot: u32 = PosSloter(dist);\n        let tmp0 = distState;\n        price = encCtx.priceDistSlotTable[tmp0];\n    }\n    price += CmptPriceLen(c_ref!(encCtx.matchLenEncoder), len, posState);\n    return price;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608861243)\nerror[E0283]: type annotations needed\n  --> src/src/encode/cmptlz_enc_price_c.rs:96:95\n   |\n96 |     price += CmptPriceLen(c_ref!(encCtx.matchLenEncoder).cast(), len.cast(), posState.cast()).cast();\n   |           -- type must be known at this point                                                 ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\n   = note: multiple `impl`s satisfying `u32: std::ops::AddAssign<_>` found in the `core` crate:\n           - impl std::ops::AddAssign for u32;\n           - impl std::ops::AddAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n   |\n96 |     price += CmptPriceLen(c_ref!(encCtx.matchLenEncoder).cast(), len.cast(), posState.cast()).cast::<T>();\n   |                                                                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[0].state = encCtx->state;\n\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}",
            "rust_code": "pub fn CmptlzDpInit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut position: u32) -> u32 {\n    let niceLen: u32 = mf.niceLen;\n    let mut lenMain: u32;\n    let mut matchesCount: u32 = 0;\n\n    if (mf.readAhead == 0) {\n        lenMain = CmptlzMatchFinder(mf, c_ref!(matchesCount), encCtx.matches);\n    } else {\n        lenMain = encCtx.longestMatchLen;\n        matchesCount = encCtx.matchesCount;\n    }\n\n    let buf: Ptr<u8> = (CmptMfGetPtr(mf) - 1);\n    let bufAvail: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH!());\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN!()) {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    let mut repLens: Array<u32, { CMPTLZ_NUM_REPS!() }> = Default::default();\n    let mut repMaxIndex: u32 = 0;\n\n    let mut i: u32;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        let bufBack: Ptr<u8> = (buf - encCtx.reps[i] - 1);\n\n        if NOT_EQUAL_2_BYTES!(buf, bufBack) {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN!(), bufAvail);\n        if (repLens[i] > repLens[repMaxIndex]) {\n            repMaxIndex = i;\n        }\n    });\n\n    if (repLens[repMaxIndex] >= niceLen) {\n        encCtx.backRes = repMaxIndex;\n        encCtx.lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, (repLens[repMaxIndex] - 1));\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    if (lenMain >= niceLen) {\n        encCtx.backRes = (encCtx.matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS!());\n        encCtx.lenRes = lenMain;\n        CmptlzMatchSkiper(mf, (lenMain - 1));\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    let currentByte: u8 = *buf;\n    let matchByte: u8 = *(buf - encCtx.reps[0] - 1);\n    let lenEnd: u32 = CMPTLZ_FIND_MAX!(lenMain, repLens[repMaxIndex]);\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()) && (currentByte != matchByte) {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    encCtx.opts[0].state = encCtx.state;\n\n    let posState: u32 = position & encCtx.posMask;\n\n    encCtx.litMarcov.pos = position;\n    encCtx.litMarcov.prevByte = *(buf - 1);\n    let isLiteralState: bool = (encCtx.state < 7);\n    let isMatchMode: bool = !isLiteralState;\n\n    let tmp0 = 1;\n    encCtx.opts[tmp0][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx.opts[1].backPrev = CMPTLZ_UINT32_MAX!();\n\n    let matchPrice: u32 = CmptPriceBit1(encCtx, encCtx.isMatch[encCtx.state][posState]);\n    let repMatchPrice: u32 = (matchPrice + CmptPriceBit1(encCtx, encCtx.isRep[encCtx.state]));\n\n    if (matchByte == currentByte) {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()) {\n        encCtx.backRes = encCtx.opts[1].backPrev;\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n\n    encCtx.opts[1].posPrev = 0;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.opts[0].backs[i] = encCtx.reps[i];\n    });\n\n    let mut len: u32 = lenEnd;\n    c_do!({\n        encCtx.opts[len].price = CMPT_INFINITY_PRICE!();\n        len.suffix_minus_minus();\n    } while len >= CMPTLZ_MATCH_LEN_MIN!());\n\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n\n    let normalMatchPrice: u32 = (matchPrice + CmptPriceBit0(encCtx, encCtx.isRep[encCtx.state]));\n    len = if repLens[0] > CMPTLZ_MATCH_LEN_MIN!() { repLens[0] + 1 } else { CMPTLZ_MATCH_LEN_MIN!() };\n\n    if (len <= lenMain) {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608865639)\nerror: mismatched closing delimiter: `}`\n   --> src/src/encode/cmptlz_enc_dp_c.rs:129:28\n    |\n59  | pub fn CmptlzDpInit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut position: u32) -> u32 {\n    |                                                                                                      - closing delimiter possibly meant for this\n...\n129 |     encCtx.opts[1].price = (CmptPriceBit0(encCtx.cast(), encCtx.isMatch[encCtx.state][posState].cast()).cast() +\n    |                            ^ unclosed delimiter\n...\n166 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "static inline void CmptlzDpPre(CmptLzEncCtx *encCtx, uint32_t *mainReps, const uint32_t cur)\n{\n    uint32_t posPointer = encCtx->opts[cur].posPrev;\n    CmptlzState state = encCtx->opts[posPointer].state;\n\n    if (posPointer == cur - 1)\n    {\n        if (encCtx->opts[cur].backPrev == 0)\n        {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_LIT(state);\n        }\n    }\n    else\n    {\n        uint32_t backPointer;\n        backPointer = encCtx->opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_MATCH(state);\n        }\n\n        uint32_t i;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            mainReps[0] = encCtx->opts[posPointer].backs[backPointer];\n\n            for (i = 1; i <= backPointer; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n            for (; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i];\n            }\n        }\n        else\n        {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS;\n            for (i = 1; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n        }\n    }\n\n    encCtx->opts[cur].state = state;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[cur].backs[i] = mainReps[i];\n    }\n}",
            "rust_code": "pub fn CmptlzDpPre(mut encCtx: Ptr<CmptLzEncCtx>, mut mainReps: Ptr<u32>, mut cur: u32) {\n    let mut posPointer: u32 = encCtx.opts[cur].posPrev;\n    let mut state: CmptlzState = encCtx.opts[posPointer].state;\n\n    if (posPointer == cur - 1) {\n        if (encCtx.opts[cur].backPrev == 0) {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n        } else {\n            CMPT_STATE_UPDATE_WHEN_LIT!(state);\n        }\n    } else {\n        let mut backPointer: u32;\n        backPointer = encCtx.opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS!()) {\n            CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n        } else {\n            CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n        }\n\n        let mut i: u32;\n        if (backPointer < CMPTLZ_NUM_REPS!()) {\n            mainReps[0] = encCtx.opts[posPointer].backs[backPointer];\n\n            c_for!(i = 1; i <= backPointer; i.suffix_plus_plus(); {\n                mainReps[i] = encCtx.opts[posPointer].backs[i - 1];\n            });\n            c_for!(; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_minus(); {\n                mainReps[i] = encCtx.opts[posPointer].backs[i];\n            });\n        } else {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS!();\n            c_for!(i = 1; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n                mainReps[i] = encCtx.opts[posPointer].backs[i - 1];\n            });\n        }\n    }\n\n    encCtx.opts[cur].state = state;\n\n    let mut i: u32;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.opts[cur].backs[i] = mainReps[i];\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608871008)\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:34\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                  ^^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:70:13\n   |\n70 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |             --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:83:56\n   |\n83 |         $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP };\n   |                                                        ^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:70:13\n   |\n70 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n   |             --------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:75:34\n   |\n75 |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n   |                                  ^^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:79:13\n   |\n79 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n   |             -------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n  --> src/src/encode/cmptlz_enc_inner_h.rs:75:55\n   |\n75 |         $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP };\n   |                                                       ^^^^^^^^^^ not a value\n   |\n  ::: src/src/encode/cmptlz_enc_dp_c.rs:79:13\n   |\n79 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n   |             -------------------------------------- in this macro invocation\n   |\n   = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `suffix_plus_minus` found for type `u32` in the current scope\n  --> src/src/encode/cmptlz_enc_dp_c.rs:91:48\n   |\n91 |             c_for!(; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_minus(); {\n   |                                                ^^^^^^^^^^^^^^^^^\n   |\nhelp: there is a method `suffix_minus_minus` with a similar name\n   |\n91 |             c_for!(; i < CMPTLZ_NUM_REPS!(); i.suffix_minus_minus(); {\n   |                                                ~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "static inline void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                        const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                        const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}",
            "rust_code": "pub fn CmptlzDpTryCurAndLit(mut encCtx: Ptr<CmptLzEncCtx>, mut curPrice: u32, mut curState: CmptlzState, mut posState: u32, mut cur: u32, mut latestMatchByte: u8, mut curByte: u8) {\n    let mut isLiteralState: bool = (curState < 7);\n    let mut isMatchMode: bool = !isLiteralState;\n    let mut curAndLitPrice: u32 = curPrice + CmptPriceBit0(encCtx, encCtx.isMatch[curState][posState]) + CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte.cast());\n    if (curAndLitPrice < encCtx.opts[cur + 1].price) {\n        encCtx.opts[cur + 1].price = curAndLitPrice;\n        encCtx.opts[cur + 1].posPrev = cur;\n        encCtx.opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX!();\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608875032)\nerror[E0284]: type annotations needed\n  --> src/src/encode/cmptlz_enc_dp_c.rs:72:118\n   |\n72 | ...tPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast() + CmptPriceLiteral(encCtx.cast...\n   |                           - type must be known at this point                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\n   = note: cannot satisfy `<u32 as std::ops::Add<_>>::Output == _`\nhelp: consider specifying the generic argument\n   |\n72 |     let mut curAndLitPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast::<T>() + CmptPriceLiteral(encCtx.cast(), isMatchMode.cast(), latestMatchByte.cast(), curByte.cast()).cast();\n   |                                                                                                                          +++++\n\nerror[E0283]: type annotations needed\n  --> src/src/encode/cmptlz_enc_dp_c.rs:72:118\n   |\n72 | ...tPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast() + CmptPriceLiteral(encCtx.cast...\n   |                           - type must be known at this point                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nnote: multiple `impl`s satisfying `u32: std::ops::Add<_>` found\n  --> src/translation_utils/types/num.rs:72:1\n   |\n72 | impl Add<Num> for u32 {\n   | ^^^^^^^^^^^^^^^^^^^^^\n   = note: and more `impl`s found in the following crates: `core`:\n           - impl std::ops::Add for u32;\n           - impl std::ops::Add<&u32> for u32;\nhelp: consider specifying the generic argument\n   |\n72 |     let mut curAndLitPrice: u32 = curPrice + CmptPriceBit0(encCtx.cast(), encCtx.isMatch[curState][posState].cast()).cast::<T>() + CmptPriceLiteral(encCtx.cast(), isMatchMode.cast(), latestMatchByte.cast(), curByte.cast()).cast();\n   |                                                                                                                          +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        },
        {
            "c_code": "static inline uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                       uint32_t position, const uint32_t cur)\n{\n\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n\n        const uint32_t lenEqualMem = lenEqual;\n\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}",
            "rust_code": "pub fn CmptlzDpProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut mainReps: Ptr<u32>, mut lenEnd: u32, mut position: u32, mut cur: u32) -> u32 {\n    let mut curState: CmptlzState = encCtx.opts[cur].state;\n    let mut bufAvailFull: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX!() - 1 - cur);\n    let mut buf: Ptr<u8> = (CmptMfGetPtr(mf) - 1);\n    let mut niceLen: u32 = mf.niceLen;\n    let mut curPrice: u32 = encCtx.opts[cur].price;\n    let mut curByte: u8 = *buf;\n    let mut latestMatchByte: u8 = *(buf - mainReps[0] - 1);\n    let mut posState: u32 = (position & encCtx.posMask);\n\n    encCtx.litMarcov.pos = position;\n    encCtx.litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n\n    let mut matchPrice: u32 = (curPrice + CmptPriceBit1(encCtx, encCtx.isMatch[curState][posState]));\n    let mut repMatchPrice: u32 = (matchPrice + CmptPriceBit1(encCtx, encCtx.isRep[curState]));\n\n    let tmp0 = cur + 1;\n    if (curByte == latestMatchByte) && !(encCtx.opts[tmp0].backPrev == 0) {\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN!()) {\n        return lenEnd;\n    }\n    let mut bufAvail: u32 = CMPTLZ_FIND_MIN!(bufAvailFull, niceLen);\n    let mut startLen: u32 = CMPTLZ_MATCH_LEN_MIN!();\n\n    let mut mainRepIndex: u32;\n    c_for!(mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS!(); mainRepIndex.suffix_plus_plus(); {\n        let mut bufRepBack: Ptr<u8> = (buf - mainReps[mainRepIndex] - 1);\n\n        if NOT_EQUAL_2_BYTES!(buf, bufRepBack) {\n            continue;\n        }\n\n        let mut lenEqual: u32;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN!(), bufAvail);\n        while (lenEnd < cur + lenEqual) {\n            lenEnd.suffix_plus_plus();\n            encCtx.opts[lenEnd].price = CMPT_INFINITY_PRICE!();\n        }\n\n        let mut lenEqualMem: u32 = lenEqual;\n\n        let mut prefixPrice: u32 = (repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState));\n\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0) {\n            startLen = (lenEqual + 1);\n        }\n    });\n\n    let mut newLongestLen: u32 = encCtx.longestMatchLen;\n    let mut matchCount: u32 = encCtx.matchesCount;\n\n    if (newLongestLen > bufAvail) {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx.matches[matchCount].len) {\n            matchCount.suffix_plus_plus();\n        }\n        encCtx.matches[matchCount].len = newLongestLen;\n        matchCount.suffix_plus_plus();\n    }\n\n    if (newLongestLen >= startLen) {\n        let mut normalmatch_prefixPrice: u32 = (matchPrice + CmptPriceBit0(encCtx, encCtx.isRep[curState]));\n\n        while (lenEnd < cur + newLongestLen) {\n            lenEnd.suffix_plus_plus();\n            encCtx.opts[lenEnd].price = CMPT_INFINITY_PRICE!();\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/cmptlz_1744608883702)\nerror[E0282]: type annotations needed\n   --> src/src/encode/cmptlz_enc_dp_c.rs:130:44\n    |\n130 |     encCtx.litMarcov.prevByte = *(buf - 1).cast();\n    |                                            ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n130 |     encCtx.litMarcov.prevByte = *(buf - 1).cast::<T>();\n    |                                                +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        }
    ]
}