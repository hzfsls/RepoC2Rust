{"void *VOS_AVL_Insert_Or_Find(AVL_TREE *pstTree, AVL_NODE *pstNode)\n{\n    AVL_NODE *pstParentNode;\n    int iResult;\n\n    if ((pstTree == AVL_NULL_PTR) || (pstNode == AVL_NULL_PTR) || (VOS_AVL_IN_TREE(*pstNode)))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    pstNode->sRHeight = 0;\n    pstNode->sLHeight = 0;\n\n    if (pstTree->pstRoot == AVL_NULL_PTR)\n    {\n        pstTree->pstRoot = pstNode;\n        pstTree->pstFirst = pstNode;\n        pstTree->pstLast = pstNode;\n        return AVL_NULL_PTR;\n    }\n\n    for (pstParentNode = pstTree->pstRoot; pstParentNode != AVL_NULL_PTR;)\n    {\n\n        iResult = pstTree->pfnCompare(pstNode->pKey, pstParentNode->pKey);\n        if (iResult > 0)\n        {\n\n            if (pstParentNode->pstRight != AVL_NULL_PTR)\n            {\n\n                pstParentNode = pstParentNode->pstRight;\n                continue;\n            }\n\n            VosAvlNodeRightInsert((AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot)), (AVLBASE_NODE_S *)pstParentNode,\n                                  (AVLBASE_NODE_S *)pstNode);\n\n            break;\n        }\n        else if (iResult < 0)\n        {\n\n            if (pstParentNode->pstLeft != AVL_NULL_PTR)\n            {\n\n                pstParentNode = pstParentNode->pstLeft;\n                continue;\n            }\n\n            VosAvlNodeLeftInsert((AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot)), (AVLBASE_NODE_S *)pstParentNode,\n                                 (AVLBASE_NODE_S *)pstNode);\n\n            break;\n        }\n\n        pstNode->sRHeight = -1;\n        pstNode->sLHeight = -1;\n        return pstParentNode->pSelf;\n    }\n\n    if (pstParentNode != AVL_NULL_PTR)\n    {\n        VosAvlBalanceTree((AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot)), (AVLBASE_NODE_S *)pstParentNode);\n    }\n\n    return AVL_NULL_PTR;\n}": "1", "void VOS_AVL_Delete(AVL_TREE *pstTree, AVL_NODE *pstNode)\n{\n    AVLBASE_NODE_S *pstBaseNode;\n    AVLBASE_TREE_S *pstBaseTree;\n\n    if ((pstTree == AVL_NULL_PTR) || (pstNode == AVL_NULL_PTR) || (!VOS_AVL_IN_TREE(*pstNode)))\n    {\n        return;\n    }\n\n    pstBaseNode = (AVLBASE_NODE_S *)pstNode;\n    pstBaseTree = (AVLBASE_TREE_S *)(void *)(&(pstTree->pstRoot));\n    VosAvlDelete(pstBaseNode, pstBaseTree);\n    return;\n}": "2", "void *VOS_AVL_Find(AVL_TREE *pstTree, const void *pKey)\n{\n\n    AVL_NODE *pstNode;\n    int iResult;\n\n    if (pstTree == AVL_NULL_PTR)\n    {\n        return AVL_NULL_PTR;\n    }\n    pstNode = pstTree->pstRoot;\n\n    while (pstNode != AVL_NULL_PTR)\n    {\n\n        iResult = pstTree->pfnCompare(pKey, pstNode->pKey);\n        if (iResult > 0)\n        {\n\n            pstNode = pstNode->pstRight;\n        }\n        else if (iResult < 0)\n        {\n\n            pstNode = pstNode->pstLeft;\n        }\n        else\n        {\n\n            break;\n        }\n    }\n\n    return ((pstNode != AVL_NULL_PTR) ? pstNode->pSelf : AVL_NULL_PTR);\n}": "3", "void *VOS_AVL_Next(AVL_NODE *pstNode)\n{\n    AVL_NODE *pstNodeTmp = pstNode;\n    if ((pstNodeTmp == AVL_NULL_PTR) || (!VOS_AVL_IN_TREE(*pstNodeTmp)))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    if (pstNodeTmp->pstRight != AVL_NULL_PTR)\n    {\n\n        pstNodeTmp = pstNodeTmp->pstRight;\n        FIND_LEFTMOST_NODE(pstNodeTmp);\n    }\n    else\n    {\n\n        while (pstNodeTmp != AVL_NULL_PTR)\n        {\n            if ((pstNodeTmp->pstParent == AVL_NULL_PTR) || (pstNodeTmp->pstParent->pstLeft == pstNodeTmp))\n            {\n                pstNodeTmp = pstNodeTmp->pstParent;\n                break;\n            }\n\n            pstNodeTmp = pstNodeTmp->pstParent;\n        }\n    }\n\n    return ((pstNodeTmp != AVL_NULL_PTR) ? pstNodeTmp->pSelf : AVL_NULL_PTR);\n}": "4", "void *VOS_AVL_Prev(AVL_NODE *pstNode)\n{\n    AVL_NODE *pstNodeTmp = pstNode;\n    if ((pstNodeTmp == AVL_NULL_PTR) || (!VOS_AVL_IN_TREE(*pstNodeTmp)))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    if (pstNodeTmp->pstLeft != AVL_NULL_PTR)\n    {\n\n        pstNodeTmp = pstNodeTmp->pstLeft;\n        FIND_RIGHTMOST_NODE(pstNodeTmp);\n    }\n    else\n    {\n\n        while (pstNodeTmp != AVL_NULL_PTR)\n        {\n            if ((pstNodeTmp->pstParent == AVL_NULL_PTR) || (pstNodeTmp->pstParent->pstRight == pstNodeTmp))\n            {\n                pstNodeTmp = pstNodeTmp->pstParent;\n                break;\n            }\n\n            pstNodeTmp = pstNodeTmp->pstParent;\n        }\n    }\n\n    return ((pstNodeTmp != AVL_NULL_PTR) ? pstNodeTmp->pSelf : AVL_NULL_PTR);\n}": "5", "void *VOS_AVL_Find_Or_Find_Next(AVL_TREE *pstTree, const void *pKey, unsigned int bValue)\n{\n    AVL_NODE *pstNode;\n    void *pFoundNode = AVL_NULL_PTR;\n    int iResult;\n\n    if (pstTree == AVL_NULL_PTR)\n    {\n        return AVL_NULL_PTR;\n    }\n    pstNode = pstTree->pstRoot;\n\n    if (pstNode == AVL_NULL_PTR)\n    {\n        return (pFoundNode);\n    }\n\n    for (;;)\n    {\n\n        iResult = pstTree->pfnCompare(pKey, pstNode->pKey);\n        if (iResult > 0)\n        {\n\n            if (pstNode->pstRight == AVL_NULL_PTR)\n            {\n\n                pFoundNode = VOS_AVL_Next(pstNode);\n                break;\n            }\n\n            pstNode = pstNode->pstRight;\n        }\n        else if (iResult < 0)\n        {\n\n            if (pstNode->pstLeft == AVL_NULL_PTR)\n            {\n\n                pFoundNode = pstNode->pSelf;\n                break;\n            }\n\n            pstNode = pstNode->pstLeft;\n        }\n        else\n        {\n\n            if (bValue != 0)\n            {\n\n                pFoundNode = VOS_AVL_Next(pstNode);\n            }\n            else\n            {\n                pFoundNode = pstNode->pSelf;\n            }\n            break;\n        }\n    }\n\n    return (pFoundNode);\n}": "6", "unsigned int VOS_V_AVL3Init(const char *pscKey)\n{\n    (void)pscKey;\n    return 0;\n}": "7", "unsigned int VOS_V_AVL3Fini(void)\n{\n    return 0;\n}": "8", "void *AVL3_Find_Or_Find_Next(AVL3_TREE *pstTree, const void *pKey, unsigned int bFlag, AVL3_TREE_INFO *pstTreeInfo)\n{\n    AVL3_NODE *pstNode;\n    void *pFoundNode = AVL_NULL_PTR;\n    int iResult;\n    int iKeyOffset;\n\n    if (TREE_OR_TREEINFO_IS_NULL(pstTree, pstTreeInfo))\n    {\n        return AVL_NULL_PTR;\n    }\n    pstNode = pstTree->pstRoot;\n    if (pstNode == AVL_NULL_PTR)\n    {\n        return AVL_NULL_PTR;\n    }\n\n    iKeyOffset = GET_KEYOFFSET(pstTreeInfo);\n\n    for (;;)\n    {\n\n        iResult = pstTreeInfo->pfCompare(pKey, (void *)((unsigned char *)pstNode + iKeyOffset));\n        if (iResult > 0)\n        {\n\n            if (pstNode->pstRight == AVL_NULL_PTR)\n            {\n\n                pFoundNode = VOS_AVL3_Next(pstNode, pstTreeInfo);\n                break;\n            }\n\n            pstNode = pstNode->pstRight;\n        }\n        else if (iResult < 0)\n        {\n\n            if (pstNode->pstLeft == AVL_NULL_PTR)\n            {\n\n                pFoundNode = (void *)((unsigned char *)pstNode - pstTreeInfo->usNodeOffset);\n                break;\n            }\n\n            pstNode = pstNode->pstLeft;\n        }\n        else\n        {\n\n            if (bFlag != 0)\n            {\n\n                pFoundNode = VOS_AVL3_Next(pstNode, pstTreeInfo);\n            }\n            else\n            {\n                pFoundNode = (void *)((unsigned char *)pstNode - pstTreeInfo->usNodeOffset);\n            }\n            break;\n        }\n    }\n\n    return pFoundNode;\n}": "9", "void *VOS_AVL3_Insert_Or_Find(AVL3_TREE *pstTree, AVL3_NODE *pstNode, AVL3_TREE_INFO *pstTreeInfo)\n{\n    AVL3_NODE *pstParentNode;\n    int iResult;\n    int iKeyOffset;\n\n    if (TREE_OR_TREEINFO_IS_NULL(pstTree, pstTreeInfo) || (pstNode == AVL_NULL_PTR))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    pstNode->sRHeight = 0;\n    pstNode->sLHeight = 0;\n\n    if (pstTree->pstRoot == AVL_NULL_PTR)\n    {\n\n        pstTree->pstRoot = pstNode;\n        pstTree->pstFirst = pstNode;\n        pstTree->pstLast = pstNode;\n        return AVL_NULL_PTR;\n    }\n\n    pstParentNode = pstTree->pstRoot;\n\n    iKeyOffset = GET_KEYOFFSET(pstTreeInfo);\n    while (pstParentNode != AVL_NULL_PTR)\n    {\n\n        iResult = pstTreeInfo->pfCompare((void *)((unsigned char *)pstNode + iKeyOffset),\n                                         (void *)((unsigned char *)pstParentNode + iKeyOffset));\n        if (iResult > 0)\n        {\n\n            if (pstParentNode->pstRight != AVL_NULL_PTR)\n            {\n\n                pstParentNode = pstParentNode->pstRight;\n                continue;\n            }\n\n            VosAvlNodeRightInsert((AVLBASE_TREE_S *)pstTree, (AVLBASE_NODE_S *)pstParentNode,\n                                  (AVLBASE_NODE_S *)pstNode);\n        }\n        else if (iResult < 0)\n        {\n\n            if (pstParentNode->pstLeft != AVL_NULL_PTR)\n            {\n\n                pstParentNode = pstParentNode->pstLeft;\n                continue;\n            }\n\n            VosAvlNodeLeftInsert((AVLBASE_TREE_S *)pstTree, (AVLBASE_NODE_S *)pstParentNode, (AVLBASE_NODE_S *)pstNode);\n        }\n        else\n        {\n\n            pstNode->sRHeight = -1;\n            pstNode->sLHeight = -1;\n            return (void *)((unsigned char *)pstParentNode - pstTreeInfo->usNodeOffset);\n        }\n\n        break;\n    }\n\n    VosAvlBalanceTree((AVLBASE_TREE_S *)pstTree, (AVLBASE_NODE_S *)pstParentNode);\n\n    return AVL_NULL_PTR;\n}": "10", "void VOS_AVL3_Delete(AVL3_TREE *pstTree, AVL3_NODE *pstNode)\n{\n\n    AVLBASE_NODE_S *pstBaseNode;\n    AVLBASE_TREE_S *pstBaseTree;\n    if ((pstTree == AVL_NULL_PTR) || (pstNode == AVL_NULL_PTR))\n    {\n        return;\n    }\n\n    pstBaseNode = (AVLBASE_NODE_S *)pstNode;\n    pstBaseTree = (AVLBASE_TREE_S *)pstTree;\n    VosAvlDelete(pstBaseNode, pstBaseTree);\n}": "11", "void *VOS_AVL3_Find(AVL3_TREE *pstTree, const void *pstKey, AVL3_TREE_INFO *pstTreeInfo)\n{\n    AVL3_NODE *pstNode;\n    int iResult;\n    int iKeyOffset;\n\n    if (TREE_OR_TREEINFO_IS_NULL(pstTree, pstTreeInfo))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    pstNode = pstTree->pstRoot;\n    iKeyOffset = GET_KEYOFFSET(pstTreeInfo);\n\n    while (pstNode != AVL_NULL_PTR)\n    {\n        iResult = pstTreeInfo->pfCompare(pstKey, (void *)((unsigned char *)pstNode + iKeyOffset));\n        if (iResult > 0)\n        {\n\n            pstNode = pstNode->pstRight;\n        }\n        else if (iResult < 0)\n        {\n\n            pstNode = pstNode->pstLeft;\n        }\n        else\n        {\n\n            break;\n        }\n    }\n\n    return GET_NODE_START_ADDRESS(pstNode, pstTreeInfo->usNodeOffset);\n}": "12", "void *VOS_AVL3_First(AVL3_TREE *pstTree, AVL3_TREE_INFO *pstTreeInfo)\n{\n\n    AVL3_NODE *pstNode;\n\n    if (TREE_OR_TREEINFO_IS_NULL(pstTree, pstTreeInfo))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    pstNode = pstTree->pstFirst;\n\n    return GET_NODE_START_ADDRESS(pstNode, pstTreeInfo->usNodeOffset);\n}": "13", "void *VOS_AVL3_Last(AVL3_TREE *pstTree, AVL3_TREE_INFO *pstTreeInfo)\n{\n    AVL3_NODE *pstNode;\n\n    if (TREE_OR_TREEINFO_IS_NULL(pstTree, pstTreeInfo))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    pstNode = pstTree->pstLast;\n\n    return GET_NODE_START_ADDRESS(pstNode, pstTreeInfo->usNodeOffset);\n}": "14", "void *VOS_AVL3_Next(AVL3_NODE *pstNode, AVL3_TREE_INFO *pstTreeInfo)\n{\n    AVL3_NODE *pstNodeTmp = pstNode;\n    if ((pstNodeTmp == AVL_NULL_PTR) || (pstTreeInfo == AVL_NULL_PTR))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    if (pstNodeTmp->pstRight != AVL_NULL_PTR)\n    {\n\n        pstNodeTmp = pstNodeTmp->pstRight;\n        FIND_LEFTMOST_NODE(pstNodeTmp);\n    }\n    else\n    {\n\n        while (pstNodeTmp != AVL_NULL_PTR)\n        {\n            if ((pstNodeTmp->pstParent == AVL_NULL_PTR) || (pstNodeTmp->pstParent->pstLeft == pstNodeTmp))\n            {\n                pstNodeTmp = pstNodeTmp->pstParent;\n                break;\n            }\n\n            pstNodeTmp = pstNodeTmp->pstParent;\n        }\n    }\n\n    return GET_NODE_START_ADDRESS(pstNodeTmp, pstTreeInfo->usNodeOffset);\n}": "15", "void *VOS_AVL3_Prev(AVL3_NODE *pstNode, AVL3_TREE_INFO *pstTreeInfo)\n{\n    AVL3_NODE *pstNodeTmp = pstNode;\n    if ((pstNodeTmp == AVL_NULL_PTR) || (pstTreeInfo == AVL_NULL_PTR))\n    {\n        return AVL_NULL_PTR;\n    }\n\n    if (pstNodeTmp->pstLeft != AVL_NULL_PTR)\n    {\n\n        pstNodeTmp = pstNodeTmp->pstLeft;\n        FIND_RIGHTMOST_NODE(pstNodeTmp);\n    }\n    else\n    {\n\n        while (pstNodeTmp != AVL_NULL_PTR)\n        {\n            if ((pstNodeTmp->pstParent == AVL_NULL_PTR) || (pstNodeTmp->pstParent->pstRight == pstNodeTmp))\n            {\n\n                pstNodeTmp = pstNodeTmp->pstParent;\n                break;\n            }\n\n            pstNodeTmp = pstNodeTmp->pstParent;\n        }\n    }\n\n    return GET_NODE_START_ADDRESS(pstNodeTmp, pstTreeInfo->usNodeOffset);\n}": "16", "static inline void VosAvlNodeRightInsert(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstParentNode,\n                                             AVLBASE_NODE_S *pstNode)\n    {\n        pstNode->pstParent = pstParentNode;\n        pstParentNode->pstRight = pstNode;\n        pstParentNode->sRHeight = 1;\n        if (pstParentNode == pstTree->pstLast)\n        {\n\n            pstTree->pstLast = pstNode;\n        }\n    }": "17", "static inline void VosAvlNodeLeftInsert(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstParentNode,\n                                            AVLBASE_NODE_S *pstNode)\n    {\n        pstNode->pstParent = pstParentNode;\n        pstParentNode->pstLeft = pstNode;\n        pstParentNode->sLHeight = 1;\n        if (pstParentNode == pstTree->pstFirst)\n        {\n\n            pstTree->pstFirst = pstNode;\n        }\n    }": "18", "unsigned int VOS_V_AVLBaseInit(const char *pscKey)\n{\n    (void)pscKey;\n    return 0;\n}": "19", "unsigned int VOS_V_AVLBaseFini(void)\n{\n    return 0;\n}": "20", "void VosAvlRotateRight(AVLBASE_NODE_S **ppstSubTree)\n{\n    AVLBASE_NODE_S *pstLeftSon = (*ppstSubTree)->pstLeft;\n\n    (*ppstSubTree)->pstLeft = pstLeftSon->pstRight;\n    if ((*ppstSubTree)->pstLeft != AVL_NULL_PTR)\n    {\n        (*ppstSubTree)->pstLeft->pstParent = (*ppstSubTree);\n    }\n\n    (*ppstSubTree)->sLHeight = pstLeftSon->sRHeight;\n    pstLeftSon->pstParent = (*ppstSubTree)->pstParent;\n    pstLeftSon->pstRight = *ppstSubTree;\n    pstLeftSon->pstRight->pstParent = pstLeftSon;\n    pstLeftSon->sRHeight = (1 + VOS_V2_AVL_MAX((*ppstSubTree)->sRHeight, (*ppstSubTree)->sLHeight));\n\n    *ppstSubTree = pstLeftSon;\n\n    return;\n}": "21", "void VosAvlRotateLeft(AVLBASE_NODE_S **ppstSubTree)\n{\n    AVLBASE_NODE_S *pstRightSon = (*ppstSubTree)->pstRight;\n\n    (*ppstSubTree)->pstRight = pstRightSon->pstLeft;\n    if ((*ppstSubTree)->pstRight != AVL_NULL_PTR)\n    {\n        (*ppstSubTree)->pstRight->pstParent = (*ppstSubTree);\n    }\n\n    (*ppstSubTree)->sRHeight = pstRightSon->sLHeight;\n    pstRightSon->pstParent = (*ppstSubTree)->pstParent;\n    pstRightSon->pstLeft = *ppstSubTree;\n    pstRightSon->pstLeft->pstParent = pstRightSon;\n    pstRightSon->sLHeight = (1 + VOS_V2_AVL_MAX((*ppstSubTree)->sRHeight, (*ppstSubTree)->sLHeight));\n\n    *ppstSubTree = pstRightSon;\n\n    return;\n}": "22", "void VosAvlUpdateSwapNode(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstSwapNode, const AVLBASE_NODE_S *pstBaseNode)\n{\n\n    pstSwapNode->pstParent = pstBaseNode->pstParent;\n    pstSwapNode->pstRight = pstBaseNode->pstRight;\n    pstSwapNode->pstLeft = pstBaseNode->pstLeft;\n    pstSwapNode->sRHeight = pstBaseNode->sRHeight;\n    pstSwapNode->sLHeight = pstBaseNode->sLHeight;\n    pstSwapNode->pstRight->pstParent = pstSwapNode;\n    pstSwapNode->pstLeft->pstParent = pstSwapNode;\n\n    if (pstBaseNode->pstParent == AVL_NULL_PTR)\n    {\n\n        pstTree->pstRoot = pstSwapNode;\n    }\n    else if (pstBaseNode->pstParent->pstRight == pstBaseNode)\n    {\n\n        pstSwapNode->pstParent->pstRight = pstSwapNode;\n    }\n    else\n    {\n\n        pstSwapNode->pstParent->pstLeft = pstSwapNode;\n    }\n}": "23", "void VosAvlMoveNodeToNewPos(AVLBASE_NODE_S *pstNode, AVLBASE_NODE_S *pstNewParent, AVLBASE_NODE_S *pstNewLeftSon,\n                            AVLBASE_NODE_S *pstNewRightSon)\n{\n    pstNode->pstParent = pstNewParent;\n    pstNode->pstLeft = pstNewLeftSon;\n    pstNode->pstRight = pstNewRightSon;\n    pstNode->sLHeight = 0;\n    pstNode->sRHeight = 0;\n\n    if (pstNewLeftSon != AVL_NULL_PTR)\n    {\n        pstNode->pstLeft->pstParent = pstNode;\n        pstNode->sLHeight = 1;\n    }\n\n    if (pstNewRightSon != AVL_NULL_PTR)\n    {\n        pstNode->pstRight->pstParent = pstNode;\n        pstNode->sRHeight = 1;\n    }\n}": "24", "void VosAvlSwapRightMost(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstSubTree, AVLBASE_NODE_S *pstNode)\n{\n    AVLBASE_NODE_S *pstSwapNode = pstSubTree;\n    AVLBASE_NODE_S *pstSwapParent;\n    AVLBASE_NODE_S *pstSwapLeft;\n\n    FIND_RIGHTMOST_NODE(pstSwapNode);\n\n    if ((pstSwapNode->sRHeight != 0) || (pstSwapNode->sLHeight > 1))\n    {\n        return;\n    }\n\n    pstSwapParent = pstSwapNode->pstParent;\n    pstSwapLeft = pstSwapNode->pstLeft;\n\n    VosAvlUpdateSwapNode(pstTree, pstSwapNode, pstNode);\n    VosAvlMoveNodeToNewPos(pstNode, pstSwapParent, pstSwapLeft, AVL_NULL_PTR);\n\n    pstNode->pstParent->pstRight = pstNode;\n\n    return;\n}": "25", "void VosAvlSwapLeftMost(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstSubTree, AVLBASE_NODE_S *pstNode)\n{\n    AVLBASE_NODE_S *pstSwapNode = pstSubTree;\n    AVLBASE_NODE_S *pstSwapParent;\n    AVLBASE_NODE_S *pstSwapRight;\n\n    FIND_LEFTMOST_NODE(pstSwapNode);\n\n    if ((pstSwapNode->sLHeight != 0) || (pstSwapNode->sRHeight > 1))\n    {\n        return;\n    }\n\n    pstSwapParent = pstSwapNode->pstParent;\n    pstSwapRight = pstSwapNode->pstRight;\n\n    VosAvlUpdateSwapNode(pstTree, pstSwapNode, pstNode);\n    VosAvlMoveNodeToNewPos(pstNode, pstSwapParent, AVL_NULL_PTR, pstSwapRight);\n\n    pstNode->pstParent->pstLeft = pstNode;\n\n    return;\n}": "26", "void VosAvlRebalance(AVLBASE_NODE_S **ppstSubTree)\n{\n    int iMoment;\n\n    iMoment = (*ppstSubTree)->sRHeight - (*ppstSubTree)->sLHeight;\n\n    if (iMoment > 1)\n    {\n\n        if ((*ppstSubTree)->pstRight->sLHeight > (*ppstSubTree)->pstRight->sRHeight)\n        {\n\n            VosAvlRotateRight(&(*ppstSubTree)->pstRight);\n        }\n\n        VosAvlRotateLeft(ppstSubTree);\n    }\n    else if (iMoment < -1)\n    {\n\n        if ((*ppstSubTree)->pstLeft->sRHeight > (*ppstSubTree)->pstLeft->sLHeight)\n        {\n\n            VosAvlRotateLeft(&(*ppstSubTree)->pstLeft);\n        }\n\n        VosAvlRotateRight(ppstSubTree);\n    }\n\n    return;\n}": "27", "void VosAvlBalanceTree(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstNode)\n{\n\n    AVLBASE_NODE_S *pstNodeTmp = pstNode;\n    while (pstNodeTmp->pstParent != AVL_NULL_PTR)\n    {\n\n        if (pstNodeTmp->pstParent->pstRight == pstNodeTmp)\n        {\n\n            pstNodeTmp = pstNodeTmp->pstParent;\n            VosAvlRebalance(&pstNodeTmp->pstRight);\n\n            pstNodeTmp->sRHeight = (1 + VOS_V2_AVL_MAX(pstNodeTmp->pstRight->sRHeight, pstNodeTmp->pstRight->sLHeight));\n        }\n        else\n        {\n\n            pstNodeTmp = pstNodeTmp->pstParent;\n            VosAvlRebalance(&pstNodeTmp->pstLeft);\n\n            pstNodeTmp->sLHeight = (1 + VOS_V2_AVL_MAX(pstNodeTmp->pstLeft->sRHeight, pstNodeTmp->pstLeft->sLHeight));\n        }\n    }\n\n    if (pstNodeTmp->sLHeight != pstNodeTmp->sRHeight)\n    {\n\n        VosAvlRebalance(&pstTree->pstRoot);\n    }\n\n    return;\n}": "28", "AVLBASE_NODE_S *VosAVLSearchReplaceNodeInRTree(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstNode)\n{\n    AVLBASE_NODE_S *pstReplaceNode;\n\n    if (pstNode->pstRight->pstLeft == AVL_NULL_PTR)\n    {\n\n        pstReplaceNode = pstNode->pstRight;\n        pstReplaceNode->pstLeft = pstNode->pstLeft;\n        pstReplaceNode->pstLeft->pstParent = pstReplaceNode;\n        pstReplaceNode->sLHeight = pstNode->sLHeight;\n    }\n    else\n    {\n\n        VosAvlSwapLeftMost(pstTree, pstNode->pstRight, pstNode);\n        pstReplaceNode = pstNode->pstRight;\n    }\n\n    return pstReplaceNode;\n}": "29", "AVLBASE_NODE_S *VosAvlSearchReplaceNodeInLTree(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstNode)\n{\n    AVLBASE_NODE_S *pstReplaceNode;\n\n    if (pstNode->pstLeft->pstRight == AVL_NULL_PTR)\n    {\n\n        pstReplaceNode = pstNode->pstLeft;\n        pstReplaceNode->pstRight = pstNode->pstRight;\n        pstReplaceNode->pstRight->pstParent = pstReplaceNode;\n        pstReplaceNode->sRHeight = pstNode->sRHeight;\n    }\n    else\n    {\n\n        VosAvlSwapRightMost(pstTree, pstNode->pstLeft, pstNode);\n        pstReplaceNode = pstNode->pstLeft;\n    }\n\n    return pstReplaceNode;\n}": "30", "AVLBASE_NODE_S *VosAvlSearchReplaceNode(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstNode)\n{\n    AVLBASE_NODE_S *pstReplaceNode;\n\n    if (pstNode->sRHeight > pstNode->sLHeight)\n    {\n\n        pstReplaceNode = VosAVLSearchReplaceNodeInRTree(pstTree, pstNode);\n    }\n    else\n    {\n\n        pstReplaceNode = VosAvlSearchReplaceNodeInLTree(pstTree, pstNode);\n    }\n\n    return pstReplaceNode;\n}": "31", "AVLBASE_NODE_S *VosAvlDeleteCheck(AVLBASE_TREE_S *pstTree, AVLBASE_NODE_S *pstNode)\n{\n    AVLBASE_NODE_S *pstReplaceNode;\n\n    if ((pstNode->pstLeft == AVL_NULL_PTR) && (pstNode->pstRight == AVL_NULL_PTR))\n    {\n\n        pstReplaceNode = AVL_NULL_PTR;\n\n        if (pstTree->pstFirst == pstNode)\n        {\n\n            pstTree->pstFirst = pstNode->pstParent;\n        }\n\n        if (pstTree->pstLast == pstNode)\n        {\n\n            pstTree->pstLast = pstNode->pstParent;\n        }\n    }\n    else if (pstNode->pstLeft == AVL_NULL_PTR)\n    {\n\n        pstReplaceNode = pstNode->pstRight;\n\n        if (pstTree->pstFirst == pstNode)\n        {\n\n            pstTree->pstFirst = pstReplaceNode;\n        }\n    }\n    else if (pstNode->pstRight == AVL_NULL_PTR)\n    {\n\n        pstReplaceNode = pstNode->pstLeft;\n\n        if (pstTree->pstLast == pstNode)\n        {\n\n            pstTree->pstLast = pstReplaceNode;\n        }\n    }\n    else\n    {\n\n        pstReplaceNode = VosAvlSearchReplaceNode(pstTree, pstNode);\n    }\n    return pstReplaceNode;\n}": "32", "void VosAvlDelete(AVLBASE_NODE_S *pstBaseNode, AVLBASE_TREE_S *pstBaseTree)\n{\n    AVLBASE_NODE_S *pstReplaceNode;\n    AVLBASE_NODE_S *pstParentNode;\n    short int sNewHeight = 0;\n\n    pstReplaceNode = VosAvlDeleteCheck(pstBaseTree, pstBaseNode);\n\n    pstParentNode = pstBaseNode->pstParent;\n\n    pstBaseNode->pstParent = AVL_NULL_PTR;\n    pstBaseNode->pstRight = AVL_NULL_PTR;\n    pstBaseNode->pstLeft = AVL_NULL_PTR;\n    pstBaseNode->sRHeight = -1;\n    pstBaseNode->sLHeight = -1;\n\n    if (pstReplaceNode != AVL_NULL_PTR)\n    {\n\n        pstReplaceNode->pstParent = pstParentNode;\n        sNewHeight = (1 + VOS_V2_AVL_MAX(pstReplaceNode->sLHeight, pstReplaceNode->sRHeight));\n    }\n\n    if (pstParentNode != AVL_NULL_PTR)\n    {\n\n        if (pstParentNode->pstRight == pstBaseNode)\n        {\n\n            pstParentNode->pstRight = pstReplaceNode;\n            pstParentNode->sRHeight = sNewHeight;\n        }\n        else\n        {\n\n            pstParentNode->pstLeft = pstReplaceNode;\n            pstParentNode->sLHeight = sNewHeight;\n        }\n\n        VosAvlBalanceTree(pstBaseTree, pstParentNode);\n    }\n    else\n    {\n\n        pstBaseTree->pstRoot = pstReplaceNode;\n    }\n\n    return;\n}": "33", "BzpAlgorithmInfo *BzpAlgorithmInfoInit(int32_t blockSize)\n    {\n        BzpAlgorithmInfo *bzpInfo = (BzpAlgorithmInfo *)malloc(sizeof(BzpAlgorithmInfo));\n        if (bzpInfo == NULL)\n        {\n            return NULL;\n        }\n        bzpInfo->bwt = BzpBlockSortInit(blockSize);\n        bzpInfo->mtf = BzpMtfInit(blockSize);\n        bzpInfo->huffman = BzpHuffmanGroupsInit(blockSize);\n        bzpInfo->outData = BzpOutComDataInit(blockSize);\n        bzpInfo->compressFile = BzpFileInit();\n\n        if (bzpInfo->bwt == NULL || bzpInfo->outData == NULL || bzpInfo->compressFile == NULL || bzpInfo->mtf == NULL ||\n            bzpInfo->huffman == NULL)\n        {\n            BzpAlgorithmInfoFinish(bzpInfo);\n            return NULL;\n        }\n        return bzpInfo;\n    }": "34", "int32_t BzpOpenFile(BzpAlgorithmInfo *bzpInfo, char *inName, char *outName)\n    {\n        if (bzpInfo == NULL)\n        {\n            return BZP_ERROR_PARAM;\n        }\n        bzpInfo->compressFile->input->filePtr = fopen(inName, \"rb\");\n        bzpInfo->compressFile->output->filePtr = fopen(outName, \"wb\");\n        if ((bzpInfo->compressFile->input->filePtr == NULL || bzpInfo->compressFile->output->filePtr == NULL))\n        {\n            BzpAlgorithmInfoFinish(bzpInfo);\n            remove(outName);\n            return BZP_ERROR_IO;\n        }\n        return BZP_OK;\n    }": "35", "void BzpAlgorithmInfoFinish(BzpAlgorithmInfo *bzpInfo)\n    {\n        if (bzpInfo != NULL)\n        {\n            BzpBwtFinish(bzpInfo->bwt);\n            BzpMtfFinish(bzpInfo->mtf);\n            BzpBzpHuffmanGroupsFinish(bzpInfo->huffman);\n            BzpFileFinish(bzpInfo->compressFile);\n            BzpOutComDataFinish(bzpInfo->outData);\n            free(bzpInfo);\n        }\n    }": "36", "BzpFile *BzpFileInit()\n    {\n        BzpFile *compressFile = (BzpFile *)malloc(sizeof(BzpFile));\n        BzpStream *inStream = BzpStreamInit();\n        BzpStream *outStream = BzpStreamInit();\n        if (compressFile == NULL || inStream == NULL || outStream == NULL)\n        {\n            BzpStreamFinish(inStream);\n            BzpStreamFinish(outStream);\n            BzpFileFinish(compressFile);\n            return NULL;\n        }\n        compressFile->input = inStream;\n        compressFile->output = outStream;\n        compressFile->input->pos = 0;\n        compressFile->output->pos = 0;\n        compressFile->num = 0;\n        compressFile->lasChar = BZP_ASCII_SIZE;\n        compressFile->state = BZP_INPUT_COMPRESS;\n        return compressFile;\n    }": "37", "void BzpFileFinish(BzpFile *bzpF)\n    {\n        if (bzpF != NULL)\n        {\n            BzpStreamFinish(bzpF->input);\n            BzpStreamFinish(bzpF->output);\n            free(bzpF);\n            bzpF = NULL;\n        }\n    }": "38", "BzpOutComdata *BzpOutComDataInit(int32_t blockSize)\n    {\n        BzpOutComdata *outData = (BzpOutComdata *)malloc(sizeof(BzpOutComdata));\n        if (outData == NULL)\n        {\n            return NULL;\n        }\n        outData->out = NULL;\n\n        outData->out = (uint8_t *)malloc(blockSize * BZP_BASE_BLOCK_SIZE * sizeof(uint32_t));\n        if (outData->out == NULL)\n        {\n            free(outData);\n            return NULL;\n        }\n        outData->nBuf = 0;\n        outData->buf = 0;\n        outData->num = 0;\n        outData->blockSize = blockSize;\n        return outData;\n    }": "39", "void BzpOutComDataFinish(BzpOutComdata *data)\n    {\n        if (data != NULL)\n        {\n            if (data->out != NULL)\n            {\n                free(data->out);\n                data->out = NULL;\n            }\n            free(data);\n            data = NULL;\n        }\n    }": "40", "void BzpWriteToArray(int32_t val, int32_t n, BzpOutComdata *data)\n    {\n\n        while (data->nBuf >= BZP_BITS8)\n        {\n            data->out[data->num++] = (uint8_t)(data->buf >> BZP_BITS24);\n            data->nBuf -= BZP_BITS8;\n            data->buf <<= BZP_BITS8;\n        }\n        data->buf |= (val << (BZP_BITS32 - n - data->nBuf));\n        data->nBuf += n;\n    }": "41", "void BzpWriteInt32(int32_t val, BzpOutComdata *data)\n    {\n\n        BzpWriteToArray((val >> BZP_BITS24) & 0xffL, BZP_BITS8, data);\n        BzpWriteToArray((val >> BZP_BITS16) & 0xffL, BZP_BITS8, data);\n        BzpWriteToArray((val >> BZP_BITS8) & 0xffL, BZP_BITS8, data);\n        BzpWriteToArray(val & 0xffL, BZP_BITS8, data);\n    }": "42", "bool BzpFileEOF(FILE *f)\n    {\n        int32_t c = fgetc(f);\n        if (c == BZP_EOF)\n            return true;\n        (void)ungetc(c, f);\n        return false;\n    }": "43", "void BzpWriteFileHead(BzpOutComdata *outData, int32_t blockId)\n    {\n        if (blockId == 0)\n        {\n            BzpWriteToArray(BZP_HDR_B, BZP_BITS8, outData);\n            BzpWriteToArray(BZP_HDR_Z, BZP_BITS8, outData);\n            BzpWriteToArray(BZP_HDR_H, BZP_BITS8, outData);\n            BzpWriteToArray((BZP_HDR_0 + outData->blockSize), BZP_BITS8, outData);\n        }\n    }": "44", "void BzpCalculateCRC(BzpBwtInfo *bwt)\n    {\n        bwt->blockCRC = ~(bwt->blockCRC);\n        bwt->combinedCRC = (bwt->combinedCRC << 1) | (bwt->combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n        bwt->combinedCRC ^= bwt->blockCRC;\n    }": "45", "void BzpWriteBlockHead(BzpOutComdata *outData, BzpBwtInfo *bwt)\n    {\n        BzpWriteToArray(BZP_BLOCK_HEAD_0, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_1, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_2, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_3, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_4, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_5, BZP_BITS8, outData);\n        BzpWriteInt32(bwt->blockCRC, outData);\n        BzpWriteToArray(0, BZP_BIT, outData);\n        BzpWriteToArray(bwt->oriPtr, BZP_BITS24, outData);\n    }": "46", "void BzpWriteValidASCII(BzpOutComdata *outData, BzpBwtInfo *bwt)\n    {\n        int32_t validGid[BZP_ASCII_SIZE], cnt = 0;\n        bool use16[BZP_ASCII_SIZE];\n        (void)memset_s(use16, sizeof(use16), 0, sizeof(use16));\n\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            int32_t gid = i / BZP_CHARS_PER_GROUP_ASCII;\n            use16[gid] |= bwt->inUse[i];\n        }\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            BzpWriteToArray((int32_t)(use16[i]), BZP_BIT, outData);\n            if (use16[i])\n            {\n                validGid[cnt++] = i;\n            }\n        }\n        for (int32_t i = 0; i < cnt; i++)\n        {\n            for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++)\n            {\n                int32_t valid = validGid[i] * BZP_CHARS_PER_GROUP_ASCII + j;\n                BzpWriteToArray((int32_t)(bwt->inUse[valid]), BZP_BIT, outData);\n            }\n        }\n    }": "47", "void BzpWriteSelect(BzpOutComdata *outData, BzpHuffmanGroups *huffman)\n    {\n\n        BzpWriteToArray(huffman->nSelect, BZP_BITS15, outData);\n\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            for (int32_t j = 0; j < huffman->selectMTF[i]; j++)\n            {\n                BzpWriteToArray(1, BZP_BIT, outData);\n            }\n            BzpWriteToArray(0, BZP_BIT, outData);\n        }\n    }": "48", "void BzpWriteLen(BzpOutComdata *outData, BzpHuffmanGroups *huffman)\n    {\n        for (int32_t i = 0; i < huffman->nGroups; i++)\n        {\n            int32_t val = huffman->huffmanGroups[i].len[0];\n            BzpWriteToArray(val, BZP_BITS5, outData);\n\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                int32_t tar = huffman->huffmanGroups[i].len[j];\n                int32_t deta = 0, saveVal = 0;\n                if (val < tar)\n                {\n                    saveVal = BZP_HUFFMAN_LEN_INCREASE;\n                    deta = 1;\n                }\n                else if (val > tar)\n                {\n                    saveVal = BZP_HUFFMAN_LEN_REDUCED;\n                    deta = -1;\n                }\n                while (val != tar)\n                {\n                    BzpWriteToArray(saveVal, BZP_BITS2, outData);\n                    val += deta;\n                }\n                BzpWriteToArray(0, BZP_BIT, outData);\n            }\n        }\n    }": "49", "void BzpWriteInputEncode(BzpOutComdata *outData, BzpMtfInfo *mtf, BzpHuffmanGroups *huffman)\n    {\n        for (int32_t i = 0; i < mtf->nMtf; i++)\n        {\n            int32_t val = mtf->mtfV[i];\n            int32_t gid = huffman->select[i / BZP_ELEMS_NUM_IN_ONE_GROUP];\n            int32_t code = huffman->huffmanGroups[gid].table[val];\n            int32_t len = huffman->huffmanGroups[gid].len[val];\n            BzpWriteToArray(code, len, outData);\n        }\n    }": "50", "void BzpWriteFileEnd(BzpOutComdata *outData, int32_t combinedCRC)\n    {\n        BzpWriteToArray(BZP_FILE_END_0, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_FILE_END_1, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_FILE_END_2, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_FILE_END_3, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_FILE_END_4, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_FILE_END_5, BZP_BITS8, outData);\n        BzpWriteInt32(combinedCRC, outData);\n    }": "51", "void BzpFlushbuf(BzpOutComdata *outData)\n    {\n        while (outData->nBuf > 0)\n        {\n            outData->out[outData->num++] = (uint8_t)(outData->buf >> BZP_BITS24);\n            outData->nBuf -= BZP_BITS8;\n            outData->buf <<= BZP_BITS8;\n        }\n    }": "52", "int32_t BzpCompressOneBlock(BzpAlgorithmInfo *bzpInfo, BzpOutComdata *outData)\n    {\n        BzpBwtInfo *bwt = bzpInfo->bwt;\n        BzpMtfInfo *mtf = bzpInfo->mtf;\n        BzpHuffmanGroups *huffman = bzpInfo->huffman;\n        int ret = BZP_OK;\n        if (bwt->nBlock == 0)\n        {\n            return BZP_OK;\n        }\n\n        BzpWriteFileHead(outData, bwt->blockId);\n        if (bwt->nBlock > 0)\n        {\n\n            BzpCalculateCRC(bwt);\n\n            BzpBlockSortMain(bwt);\n\n            BzpMtfReSet(mtf);\n\n            mtf->block = bwt->block;\n            mtf->map = bwt->sortBlock;\n            mtf->inUse = bwt->inUse;\n            mtf->nBlock = bwt->nBlock;\n\n            BzpMtfMain(mtf);\n\n            ret = BzpHuffmanGroupsReset(huffman, mtf->nUse + BZP_EXTRA_CHARS_NUM);\n            if (ret != BZP_OK)\n            {\n                return ret;\n            }\n\n            huffman->block = mtf->mtfV;\n            huffman->mtfFreq = mtf->mtfFreq;\n            huffman->nBlock = mtf->nMtf;\n\n            BzpHuffmanMain(huffman);\n\n            BzpWriteBlockHead(outData, bwt);\n\n            BzpWriteValidASCII(outData, bwt);\n\n            BzpWriteToArray(huffman->nGroups, BZP_BITS3, outData);\n\n            BzpWriteSelect(outData, huffman);\n\n            BzpWriteLen(outData, huffman);\n\n            BzpWriteInputEncode(outData, mtf, huffman);\n        }\n        return BZP_OK;\n    }": "53", "int32_t BzpBuffToStream(BzpFile *bzpf, BzpOutComdata *outData)\n    {\n        bzpf->output->pos = 0;\n\n        int32_t pos = 0;\n\n        while (pos < outData->num)\n        {\n            bzpf->output->nBuf = 0;\n\n            while (pos < outData->num && bzpf->output->nBuf < BZP_BUF_SIZE)\n            {\n                bzpf->output->buf[bzpf->output->nBuf++] = outData->out[pos];\n                pos++;\n            }\n            int32_t n2 =\n                fwrite((void *)(bzpf->output->buf), sizeof(uint8_t), bzpf->output->nBuf, bzpf->output->filePtr);\n            if (n2 != bzpf->output->nBuf)\n            {\n                return BZP_ERROR_IO;\n            }\n        }\n        return BZP_OK;\n    }": "54", "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }": "55", "void BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata)\n    {\n\n        while (!BZP_BLOCK_FULL(bwt) && !BZP_BUFF_READ_EMPTY(bzpf))\n        {\n            int32_t pos = bzpf->input->pos;\n            uint8_t ch = (uint8_t)bzpf->input->buf[pos];\n            uint8_t lasch = (uint8_t)bzpf->lasChar;\n            if (ch != lasch || bzpf->num == BZP_RLC_NUM_UPPER_LIMIT)\n            {\n                BzpAddCharToBlock(lasch, bzpf->num, bwt);\n                bzpf->lasChar = ch;\n                bzpf->num = 1;\n            }\n            else\n            {\n                bzpf->num++;\n            }\n\n            bzpf->input->pos++;\n        }\n\n        if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n        {\n\n            BzpAddCharToBlock(bzpf->lasChar, bzpf->num, bwt);\n            bzpf->lasChar = BZP_ASCII_SIZE;\n            bzpf->num = 0;\n        }\n    }": "56", "void BzpResetCompress(BzpBwtInfo *bwt, BzpOutComdata *outData)\n    {\n\n        outData->num = 0;\n\n        bwt->nBlock = 0;\n        bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n        (void)memset_s(bwt->inUse, sizeof(bwt->inUse), 0, sizeof(bwt->inUse));\n        int32_t n = outData->blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t);\n        (void)memset_s(bwt->isStartPos, n, 0, n);\n        bwt->blockId++;\n    }": "57", "int32_t BzpProcessData(BzpAlgorithmInfo *bzpInfo, bool IsLastdata)\n    {\n        BzpFile *bzpf = bzpInfo->compressFile;\n        BzpOutComdata *outData = bzpInfo->outData;\n        BzpBwtInfo *bwt = bzpInfo->bwt;\n\n        bzpf->state = BZP_INPUT_COMPRESS;\n        int32_t ret = BZP_OK;\n        while (bzpf->state != BZP_RETUEN_COMPRESS)\n        {\n            if (bzpf->state == BZP_OUTPUT_COMPRESS)\n            {\n\n                ret = BzpBuffToStream(bzpf, outData);\n\n                BzpResetCompress(bwt, outData);\n                bzpf->state = BZP_INPUT_COMPRESS;\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (bzpf->state == BZP_INPUT_COMPRESS)\n            {\n\n                BzpBuffToBlockRLC(bzpf, bwt, IsLastdata);\n\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n\n                    BzpWriteFileEnd(outData, bwt->combinedCRC);\n                    BzpFlushbuf(outData);\n\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else if (BZP_BLOCK_FULL(bwt))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (ret != BZP_OK)\n            {\n                return ret;\n            }\n        }\n        return ret;\n    }": "58", "void BzpCompressEnd(BzpAlgorithmInfo *bzpInfo)\n    {\n\n        if (bzpInfo->compressFile->input->filePtr != NULL)\n        {\n            fclose(bzpInfo->compressFile->input->filePtr);\n        }\n        if (bzpInfo->compressFile->output->filePtr != NULL)\n        {\n            fclose(bzpInfo->compressFile->output->filePtr);\n        }\n        BzpAlgorithmInfoFinish(bzpInfo);\n    }": "59", "int32_t BzpCompressStream(char *inName, char *outName, int32_t blockSize)\n    {\n\n        int32_t ret = BZP_OK;\n        bool IsLastdata = false;\n\n        if (inName == NULL || outName == NULL || BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        BzpAlgorithmInfo *bzpInfo = BzpAlgorithmInfoInit(blockSize);\n        if (bzpInfo == NULL)\n        {\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        ret = BzpOpenFile(bzpInfo, inName, outName);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpStream *inStream = bzpInfo->compressFile->input;\n\n        while (!IsLastdata)\n        {\n            inStream->nBuf = fread(inStream->buf, sizeof(char), sizeof(inStream->buf), inStream->filePtr);\n            inStream->pos = 0;\n            IsLastdata = BzpFileEOF(inStream->filePtr);\n            ret = BzpProcessData(bzpInfo, IsLastdata);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n        }\n        BzpCompressEnd(bzpInfo);\n        if (ret != BZP_OK)\n        {\n            remove(outName);\n        }\n        return ret;\n    }": "60", "BzpStream *BzpStreamInit()\n{\n    BzpStream *stream = (BzpStream *)malloc(sizeof(BzpStream));\n    if (stream == NULL)\n    {\n        return NULL;\n    }\n    stream->filePtr = NULL;\n    stream->pos = 0;\n    stream->nBuf = 0;\n    return stream;\n}": "61", "void BzpStreamFinish(BzpStream *stream)\n{\n    if (stream != NULL)\n    {\n        free(stream);\n        stream = NULL;\n    }\n}": "62", "InDeComdata *BzpInDeComdataInit()\n    {\n        InDeComdata *inData = (InDeComdata *)malloc(sizeof(InDeComdata));\n        if (inData == NULL)\n        {\n            return NULL;\n        }\n        inData->input = NULL;\n        inData->output = NULL;\n        inData->num = 0;\n        inData->lasChar = BZP_ASCII_SIZE;\n        inData->nBuf = 0;\n        inData->buf = 0;\n        inData->num = 0;\n\n        inData->blockCRC = BZP_INIT_BLOCK_CRC;\n        return inData;\n    }": "63", "void BzpInDeComdataFinish(InDeComdata *inData)\n    {\n        if (inData != NULL)\n        {\n            free(inData);\n            inData = NULL;\n        }\n    }": "64", "uint32_t BzpReadBits(int32_t nBit, InDeComdata *inData)\n    {\n        uint32_t res = 0;\n\n        while (inData->nBuf < nBit)\n        {\n            if (inData->input->nBuf == inData->input->pos)\n            {\n                inData->input->nBuf =\n                    fread(inData->input->buf, sizeof(char), sizeof(inData->input->buf), inData->input->filePtr);\n                inData->input->pos = 0;\n            }\n            int32_t data = ((uint32_t)(inData->input->buf[inData->input->pos]));\n\n            inData->buf = (inData->buf << BZP_BITS8) | data;\n            inData->input->pos++;\n            inData->nBuf += BZP_BITS8;\n        }\n        res = inData->buf >> (inData->nBuf - nBit);\n        res = res & ((1 << nBit) - 1);\n        inData->nBuf -= nBit;\n        return res;\n    }": "65", "int32_t BzpWriteChar(uint8_t ch, InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        if (inData->output->nBuf >= BZP_BUF_SIZE)\n        {\n            int32_t n2 =\n                fwrite((void *)(inData->output->buf), sizeof(uint8_t), inData->output->nBuf, inData->output->filePtr);\n            if (n2 != inData->output->nBuf)\n            {\n                ret = BZP_ERROR_IO;\n            }\n            inData->output->nBuf = 0;\n        }\n        inData->output->buf[inData->output->nBuf++] = ch;\n        return ret;\n    }": "66", "int32_t BzpHuffmanDecodeStep(BzpHuffmanDecode *huffman, InDeComdata *inData)\n    {\n\n        if (huffman->deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP)\n        {\n            huffman->deCodeNum = 0;\n            huffman->selectCnt++;\n        }\n        int32_t gid = huffman->select[huffman->selectCnt];\n\n        int32_t chlen = huffman->minLens[gid];\n        int32_t val = BzpReadBits(chlen, inData);\n\n        while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT && val > huffman->limit[gid][chlen])\n        {\n            chlen++;\n            int32_t nxtbit = BzpReadBits(1, inData);\n            val = (val << 1) | nxtbit;\n        }\n        if (chlen > BZP_HUFFMAN_LEN_UPPER_LIMIT)\n        {\n            return -1;\n        }\n\n        val = val - huffman->base[gid][chlen];\n        val = huffman->perm[gid][val];\n        huffman->deCodeNum++;\n        return val;\n    }": "67", "int32_t BzpCheckFileHead(InDeComdata *inData)\n    {\n        uint8_t ch;\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_BLOCK_HEAD_1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_BLOCK_HEAD_2)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_BLOCK_HEAD_3)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_BLOCK_HEAD_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_BLOCK_HEAD_5)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }": "68", "uint32_t BzpReadUInt24(InDeComdata *inData)\n    {\n        uint8_t ch;\n        uint32_t val = 0;\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        return val;\n    }": "69", "uint32_t BzpReadUInt32(InDeComdata *inData)\n    {\n        uint8_t ch;\n        uint32_t val = 0;\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        ch = BzpReadBits(BZP_BITS8, inData);\n        val = (val << BZP_BITS8) | ((uint32_t)ch);\n        return val;\n    }": "70", "int32_t BzpDeHuffmanSelect(InDeComdata *inData, BzpHuffmanDecode *huffman)\n    {\n        uint8_t ch;\n\n        int32_t selectmtf[BZP_HUFFMAN_MAX_SIZE_SELECT];\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t j = -1;\n            do\n            {\n                ch = BzpReadBits(BZP_BIT, inData);\n                j++;\n            } while (ch != 0);\n            if (j >= huffman->nGroups)\n            {\n                return BZP_ERROR_DATA;\n            }\n            selectmtf[i] = j;\n        }\n\n        int32_t listSelect[BZP_MAX_GROUPS_NUM];\n        for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++)\n        {\n            listSelect[i] = i;\n        }\n\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = selectmtf[i];\n            int32_t tmpv = listSelect[pos];\n            for (int32_t j = pos; j > 0; j--)\n            {\n                listSelect[j] = listSelect[j - 1];\n            }\n            listSelect[0] = tmpv;\n            huffman->select[i] = tmpv;\n        }\n        return BZP_OK;\n    }": "71", "int32_t BzpDeHuffmanLen(InDeComdata *inData, BzpHuffmanDecode *huffman)\n    {\n        uint8_t ch;\n        for (int32_t i = 0; i < huffman->nGroups; i++)\n        {\n            int32_t val = BzpReadBits(BZP_BITS5, inData);\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n\n                ch = BzpReadBits(BZP_BIT, inData);\n                while (ch != 0)\n                {\n                    ch = BzpReadBits(BZP_BIT, inData);\n                    val += (ch == 0 ? 1 : -1);\n                    ch = BzpReadBits(BZP_BIT, inData);\n                }\n                if (val < 1 || val > BZP_HUFFMAN_LEN_UPPER_LIMIT)\n                {\n                    return BZP_ERROR_DATA;\n                }\n                huffman->len[i][j] = val;\n            }\n        }\n        return BZP_OK;\n    }": "72", "int32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n        debwt->nBlock = 0;\n        uint8_t ch;\n        int32_t ninUse = huffman->alphaSize - BZP_EXTRA_CHARS_NUM;\n        int32_t eob = ninUse + 1;\n        int32_t val = BzpHuffmanDecodeStep(huffman, inData);\n        while (val != eob && val != -1)\n        {\n            if (val == 0 || val == 1)\n            {\n                int32_t res = 0, basenum = 1;\n                while (val == 0 || val == 1)\n                {\n                    res = res + (val + 1) * basenum;\n                    basenum <<= 1;\n                    val = BzpHuffmanDecodeStep(huffman, inData);\n                }\n                for (int32_t j = 0; j < res; j++)\n                {\n                    debwt->block[debwt->nBlock++] = inData->list[0];\n                }\n            }\n            else\n            {\n                int32_t pos = val - 1;\n                ch = inData->list[pos];\n                debwt->block[debwt->nBlock++] = ch;\n\n                for (int32_t j = pos; j > 0; j--)\n                {\n                    inData->list[j] = inData->list[j - 1];\n                }\n                inData->list[0] = ch;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n        }\n        if (val == -1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }": "73", "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }": "74", "int32_t BzpGetDictionaryList(InDeComdata *inData)\n    {\n        int32_t ninUse = 0;\n\n        bool use16[16] = {0};\n        bool inUse[BZP_ASCII_SIZE] = {0};\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            use16[i] = BzpReadBits(BZP_BIT, inData);\n        }\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            if (use16[i])\n            {\n                for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++)\n                {\n                    inUse[i * BZP_GROUPS_ASCII + j] = BzpReadBits(BZP_BIT, inData);\n                }\n            }\n        }\n\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            if (inUse[i])\n            {\n                inData->list[ninUse++] = i;\n            }\n        }\n        return ninUse;\n    }": "75", "int32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n\n        int32_t ret = BZP_OK;\n        BzpCheckFileHead(inData);\n        uint32_t blockCRC = BzpReadUInt32(inData);\n\n        (void)BzpReadBits(BZP_BIT, inData);\n\n        int32_t oriPtr = BzpReadUInt24(inData);\n        if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        int32_t ninUse = BzpGetDictionaryList(inData);\n        huffman->alphaSize = ninUse + BZP_EXTRA_CHARS_NUM;\n        huffman->nGroups = BzpReadBits(BZP_BITS3, inData);\n        if (huffman->nGroups < BZP_NGROUPS_NUM_0 || huffman->nGroups > BZP_NGROUPS_NUM_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        huffman->nSelect = BzpReadBits(BZP_BITS15, inData);\n\n        int32_t nSelectUpperLimit = (inData->blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP + 1);\n        if (huffman->nSelect < 1 || huffman->nSelect > nSelectUpperLimit)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        ret |= BzpDeHuffmanSelect(inData, huffman);\n\n        ret |= BzpDeHuffmanLen(inData, huffman);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n\n        BzpGenerateDecodeTable(huffman);\n\n        debwt->oriPtr = oriPtr;\n        ret = BzpMTFDeCode(inData, huffman, debwt);\n        if (ret != BZP_OK || debwt->nBlock >= BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        BzpBwtDecode(debwt);\n\n        ret = BzpDeCodeToStream(inData, debwt);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        inData->blockCRC = ~(inData->blockCRC);\n\n        if (blockCRC != inData->blockCRC)\n        {\n            ret = BZP_ERROR_DATA;\n        }\n\n        return ret;\n    }": "76", "int32_t BZPReadFileEnd(InDeComdata *inData, uint32_t caltotalCRC)\n    {\n        uint8_t ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_FILE_END_1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_FILE_END_2)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_FILE_END_3)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_FILE_END_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_FILE_END_5)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        uint32_t storedcombinedcrc = BzpReadUInt32(inData);\n\n        if (caltotalCRC != storedcombinedcrc)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }": "77", "int32_t BzpReadFileHead(InDeComdata *inData)\n    {\n\n        uint8_t ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_HDR_B)\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_HDR_Z)\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_HDR_H)\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        int32_t blockSize = ch - BZP_HDR_0;\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n\n        inData->blockSize = blockSize;\n        return BZP_OK;\n    }": "78", "int32_t BZPDeCompressData(InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        uint32_t caltotalCRC = 0;\n        uint8_t ch;\n        ret = BzpReadFileHead(inData);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpHuffmanDecode *huffman = BzpHuffmanDecodeInit(inData->blockSize);\n        BzpBwtDecodeInfo *debwt = BzpBwtDecodeInit(inData->blockSize);\n\n        while ((ch = BzpReadBits(BZP_BITS8, inData)) != BZP_FILE_END_0)\n        {\n            if (ch != BZP_BLOCK_HEAD_0)\n            {\n                ret = BZP_ERROR_DATA;\n                break;\n            }\n            BzpHuffmanDecodeReset(huffman);\n            inData->blockCRC = BZP_INIT_BLOCK_CRC;\n\n            ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n\n            caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n            caltotalCRC ^= inData->blockCRC;\n        }\n        if (ret == BZP_OK)\n        {\n            ret = BZPReadFileEnd(inData, caltotalCRC);\n        }\n        BzpHuffmanDecodeFinish(huffman);\n        BzpBwtDecodeFinish(debwt);\n        return ret;\n    }": "79", "void BzpDeComStreamFinish(InDeComdata *inData, BzpStream *inStream, BzpStream *outStream)\n    {\n\n        if (inStream->filePtr != NULL)\n        {\n            fclose(inStream->filePtr);\n            inStream->filePtr = NULL;\n        }\n        if (outStream->filePtr != NULL)\n        {\n            fclose(outStream->filePtr);\n            outStream->filePtr = NULL;\n        }\n        BzpStreamFinish(inStream);\n        BzpStreamFinish(outStream);\n        BzpInDeComdataFinish(inData);\n    }": "80", "int32_t BzpDeCompressStream(char *inName, char *outName)\n    {\n        int32_t ret = BZP_OK;\n        if (inName == NULL || outName == NULL)\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        BzpStream *inStream = BzpStreamInit();\n        BzpStream *outStream = BzpStreamInit();\n        if (inStream == NULL || outStream == NULL)\n        {\n            BzpStreamFinish(inStream);\n            BzpStreamFinish(outStream);\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        inStream->filePtr = fopen(inName, \"rb\");\n        outStream->filePtr = fopen(outName, \"wb\");\n        if ((inStream->filePtr == NULL || outStream->filePtr == NULL))\n        {\n            free(inStream);\n            inStream = NULL;\n            free(outStream);\n            outStream = NULL;\n            remove(outName);\n            return BZP_ERROR_IO;\n        }\n        InDeComdata *inData = BzpInDeComdataInit();\n        if (inData == NULL)\n        {\n            BzpDeComStreamFinish(inData, inStream, outStream);\n            remove(outName);\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        inData->input = inStream;\n        inData->output = outStream;\n\n        ret = BZPDeCompressData(inData);\n\n        if (inData->output->nBuf > 0)\n        {\n            int32_t n2 =\n                fwrite((void *)(inData->output->buf), sizeof(uint8_t), inData->output->nBuf, inData->output->filePtr);\n            if (n2 != inData->output->nBuf)\n            {\n                ret = BZP_ERROR_IO;\n            }\n            inData->output->nBuf = 0;\n        }\n\n        BzpDeComStreamFinish(inData, inStream, outStream);\n        if (ret != BZP_OK)\n        {\n            remove(outName);\n        }\n        return ret;\n    }": "81", "BzpBwtDecodeInfo *BzpBwtDecodeInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpBwtDecodeInfo *bwt = (BzpBwtDecodeInfo *)malloc(sizeof(BzpBwtDecodeInfo));\n        if (bwt == NULL)\n        {\n            return NULL;\n        }\n        int32_t spaceSize = BZP_BASE_BLOCK_SIZE * blockSize;\n        bwt->block = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n        bwt->deCode = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n        bwt->sorted = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (bwt->block == NULL || bwt->sorted == NULL || bwt->deCode == NULL)\n        {\n            BzpBwtDecodeFinish(bwt);\n            return NULL;\n        }\n        bwt->nBlock = 0;\n        bwt->oriPtr = 0;\n        return bwt;\n    }": "82", "void BzpBwtDecode(BzpBwtDecodeInfo *bwt)\n    {\n\n        int32_t ftab[257];\n        (void)memset_s(ftab, sizeof(ftab), 0, sizeof(ftab));\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            ftab[bwt->block[i] + 1]++;\n        }\n        for (int32_t i = 1; i <= BZP_ASCII_SIZE; i++)\n        {\n            ftab[i] += ftab[i - 1];\n        }\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            uint8_t ch = bwt->block[i];\n            bwt->sorted[ftab[ch]] = i;\n            ftab[ch]++;\n        }\n        int32_t cnt = 0;\n        int32_t pos = bwt->oriPtr;\n        while (cnt < bwt->nBlock)\n        {\n            pos = bwt->sorted[pos];\n            uint8_t ch = bwt->block[pos];\n            bwt->deCode[cnt] = ch;\n            cnt++;\n        }\n    }": "83", "void BzpBwtDecodeFinish(BzpBwtDecodeInfo *bwt)\n    {\n        if (bwt != NULL)\n        {\n            if (bwt->block != NULL)\n            {\n                free(bwt->block);\n                bwt->block = NULL;\n            }\n            if (bwt->deCode != NULL)\n            {\n                free(bwt->deCode);\n                bwt->deCode = NULL;\n            }\n            if (bwt->sorted != NULL)\n            {\n                free(bwt->sorted);\n                bwt->sorted = NULL;\n            }\n            free(bwt);\n            bwt = NULL;\n        }\n    }": "84", "BzpHuffmanDecode *BzpHuffmanDecodeInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpHuffmanDecode *huffman = (BzpHuffmanDecode *)malloc(sizeof(BzpHuffmanDecode));\n        if (huffman == NULL)\n        {\n            return NULL;\n        }\n        int32_t spaceSize = BZP_BASE_BLOCK_SIZE * blockSize / BZP_ELEMS_NUM_IN_ONE_GROUP;\n        huffman->select = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (huffman->select == NULL)\n        {\n            BzpHuffmanDecodeFinish(huffman);\n        }\n\n        (void)memset_s(huffman->base, sizeof(huffman->base), 0, sizeof(huffman->base));\n        (void)memset_s(huffman->perm, sizeof(huffman->perm), 0, sizeof(huffman->perm));\n        (void)memset_s(huffman->limit, sizeof(huffman->limit), 0, sizeof(huffman->limit));\n\n        huffman->selectCnt = 0;\n        huffman->deCodeNum = 0;\n        return huffman;\n    }": "85", "void BzpHuffmanDecodeReset(BzpHuffmanDecode *huffman)\n    {\n        (void)memset_s(huffman->base, sizeof(huffman->base), 0, sizeof(huffman->base));\n        (void)memset_s(huffman->perm, sizeof(huffman->perm), 0, sizeof(huffman->perm));\n        (void)memset_s(huffman->limit, sizeof(huffman->limit), 0, sizeof(huffman->limit));\n\n        huffman->selectCnt = 0;\n        huffman->deCodeNum = 0;\n    }": "86", "void BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t)\n    {\n        int32_t vec = 0, cnt = 0;\n        int32_t mi = huffman->len[t][0], mx = huffman->len[t][0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[t][i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[t][i]);\n        }\n        huffman->minLens[t] = mi;\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[t][j] == i)\n                {\n                    huffman->perm[t][cnt++] = j;\n                }\n            }\n        }\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->base[t][huffman->len[t][i] + 1]++;\n        }\n\n        for (int32_t i = 1; i <= mx + 1; i++)\n        {\n            huffman->base[t][i] += huffman->base[t][i - 1];\n        }\n\n        for (int32_t i = mi; i <= mx; i++)\n        {\n\n            vec += (huffman->base[t][i + 1] - huffman->base[t][i]);\n\n            huffman->limit[t][i] = vec - 1;\n            vec <<= 1;\n        }\n        for (int32_t i = mi + 1; i <= mx; i++)\n        {\n            huffman->base[t][i] = ((huffman->limit[t][i - 1] + 1) << 1) - huffman->base[t][i];\n        }\n    }": "87", "void BzpGenerateDecodeTable(BzpHuffmanDecode *huffman)\n    {\n        for (int32_t t = 0; t < huffman->nGroups; t++)\n        {\n            BzpGetOneTable(huffman, t);\n        }\n    }": "88", "void BzpHuffmanDecodeFinish(BzpHuffmanDecode *huffman)\n    {\n        if (huffman != NULL)\n        {\n            if (huffman->select != NULL)\n            {\n                free(huffman->select);\n                huffman->select = NULL;\n            }\n\n            free(huffman);\n            huffman = NULL;\n        }\n    }": "89", "BzpMtfInfo *BzpMtfInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpMtfInfo *mtf = (BzpMtfInfo *)malloc(sizeof(BzpMtfInfo));\n        if (mtf == NULL)\n        {\n            return NULL;\n        }\n        mtf->mtfV = NULL;\n        mtf->mtfV = (int32_t *)malloc(blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t));\n        if (mtf->mtfV == NULL)\n        {\n            free(mtf);\n            mtf = NULL;\n            return NULL;\n        }\n\n        mtf->nUse = 0;\n        mtf->nMtf = 0;\n        mtf->block = NULL;\n        mtf->map = NULL;\n        mtf->inUse = NULL;\n        return mtf;\n    }": "90", "void BzpMtfReSet(BzpMtfInfo *mtf)\n    {\n\n        mtf->nUse = 0;\n        mtf->nMtf = 0;\n        mtf->block = NULL;\n        mtf->map = NULL;\n        mtf->inUse = NULL;\n    }": "91", "void BzpMapInputChar(BzpMtfInfo *mtf, uint8_t *list, int32_t lenList)\n    {\n        if (BZP_ASCII_SIZE > lenList)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            if (mtf->inUse[i])\n            {\n                list[mtf->nUse] = (uint8_t)i;\n                mtf->nUse++;\n            }\n        }\n    }": "92", "void BzpNumEncode(BzpMtfInfo *mtf, int32_t num)\n    {\n        num <<= 1;\n\n        do\n        {\n            num >>= 1;\n            num--;\n            if (num & 1)\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE1;\n                mtf->mtfFreq[BZP_MTF_ENCODE1]++;\n            }\n            else\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE0;\n                mtf->mtfFreq[BZP_MTF_ENCODE0]++;\n            }\n        } while (num >= BZP_MTF_ENCODE_BASE);\n    }": "93", "void BzpMtfMain(BzpMtfInfo *mtf)\n    {\n        uint8_t list[BZP_MAX_ALPHA_SIZE];\n        int32_t EOB;\n        int32_t num = 0;\n        BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE);\n        EOB = mtf->nUse + 1;\n        for (int32_t i = 0; i <= EOB; i++)\n        {\n            mtf->mtfFreq[i] = 0;\n        }\n        for (int32_t i = 0; i < mtf->nBlock; i++)\n        {\n            int32_t pos = mtf->map[i] - 1;\n            if (pos < 0)\n            {\n                pos += mtf->nBlock;\n            }\n            uint8_t ch = mtf->block[pos];\n            if (ch == list[0])\n            {\n                num++;\n            }\n            else\n            {\n                if (num > 0)\n                {\n                    BzpNumEncode(mtf, num);\n                    num = 0;\n                }\n                int32_t pos_ = 1;\n                while (ch != list[pos_] && pos_ < mtf->nUse)\n                {\n                    pos_++;\n                }\n\n                for (int32_t j = pos_; j > 0; j--)\n                {\n                    list[j] = list[j - 1];\n                }\n                list[0] = ch;\n\n                mtf->mtfV[mtf->nMtf] = pos_ + 1;\n                mtf->mtfFreq[pos_ + 1]++;\n                mtf->nMtf++;\n            }\n        }\n        if (num > 0)\n        {\n            BzpNumEncode(mtf, num);\n        }\n\n        mtf->mtfV[mtf->nMtf] = EOB;\n        mtf->mtfFreq[EOB]++;\n        mtf->nMtf++;\n    }": "94", "void BzpMtfFinish(BzpMtfInfo *mtf)\n    {\n        if (mtf != NULL)\n        {\n            if (mtf->mtfV != NULL)\n            {\n                free(mtf->mtfV);\n                mtf->mtfV = NULL;\n            }\n            free(mtf);\n            mtf = NULL;\n        }\n    }": "95", "BzpBwtInfo *BzpBlockSortInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpBwtInfo *bwt = (BzpBwtInfo *)malloc(sizeof(BzpBwtInfo));\n        if (bwt == NULL)\n        {\n            return NULL;\n        }\n\n        (void)memset_s(bwt, sizeof(BzpBwtInfo), 0, sizeof(BzpBwtInfo));\n\n        int32_t spaceSize = blockSize * BZP_BASE_BLOCK_SIZE;\n        bwt->nBlockMax = spaceSize - BZP_BLOCK_RESERVED_SPACE_SIZE;\n        bwt->block = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n        bwt->sortBlock = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        bwt->idx = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        bwt->isStartPos = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (bwt->block == NULL || bwt->sortBlock == NULL || bwt->idx == NULL || bwt->isStartPos == NULL)\n        {\n            BzpBwtFinish(bwt);\n            return NULL;\n        }\n\n        (void)memset_s(bwt->isStartPos, spaceSize * sizeof(int32_t), 0, spaceSize * sizeof(int32_t));\n        bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n        return bwt;\n    }": "96", "void BzpShellSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r)\n    {\n\n        int32_t increments[] = {BZP_SHELL_SORT_INCREMENT1, BZP_SHELL_SORT_INCREMENT0};\n        int32_t i, j;\n        if (l >= r)\n        {\n            return;\n        }\n\n        for (int32_t id = 0; id < BZP_SHELL_SORT_INCREMENT_NUMS; id++)\n        {\n            int32_t H = increments[id];\n            if (r - l + 1 <= H)\n            {\n                continue;\n            }\n            for (i = l + H; i <= r; i++)\n            {\n                int32_t tmpIdx = sortBlock[i];\n                int32_t tmpVal = idx[tmpIdx];\n                for (j = i - H; j >= l && idx[sortBlock[j]] > tmpVal; j -= H)\n                {\n                    sortBlock[j + H] = sortBlock[j];\n                }\n                sortBlock[j + H] = tmpIdx;\n            }\n        }\n    }": "97", "void BzpSwap2Elem(int32_t *sortBlock, int32_t lPos, int32_t rPos)\n    {\n        int32_t value = sortBlock[lPos];\n        sortBlock[lPos] = sortBlock[rPos];\n        sortBlock[rPos] = value;\n    }": "98", "void BzpSwap3Elem(int32_t *sortBlock, int32_t lPos, int32_t ePos, int32_t rPos)\n    {\n\n        int32_t value = sortBlock[lPos];\n        sortBlock[lPos] = sortBlock[rPos];\n        sortBlock[rPos] = sortBlock[ePos];\n        sortBlock[ePos] = value;\n    }": "99", "int32_t BzpSelectMidVal(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r)\n    {\n        int32_t mid = (l + r) >> 1;\n        int32_t vl = idx[sortBlock[l]];\n        int32_t vmid = idx[sortBlock[mid]];\n        int32_t vr = idx[sortBlock[r]];\n        if (vl > vr)\n        {\n            int32_t tmp = l;\n            l = r;\n            r = tmp;\n            vl = idx[sortBlock[l]];\n            vr = idx[sortBlock[r]];\n        }\n        if (vmid <= vl)\n        {\n            return vl;\n        }\n        else if (vmid <= vr)\n        {\n            return vmid;\n        }\n        else\n        {\n            return vr;\n        }\n    }": "100", "void BzpQSortSingle(int32_t *sortBlock, int32_t *idx, BzpQSortInfo *stack)\n    {\n        int32_t tl = stack->tl, tr = stack->tr;\n        int32_t value = BzpSelectMidVal(sortBlock, idx, tl, tr);\n        int32_t lPos = tl, rPos = tr, ePos = tl;\n\n        while (ePos <= rPos)\n        {\n            if (idx[sortBlock[ePos]] < value)\n            {\n                BzpSwap2Elem(sortBlock, ePos, lPos);\n                ePos++;\n                lPos++;\n            }\n            else if (idx[sortBlock[ePos]] == value)\n            {\n                ePos++;\n            }\n            else\n            {\n                while (rPos >= ePos && idx[sortBlock[rPos]] > value)\n                {\n                    rPos--;\n                }\n                if (rPos < ePos)\n                {\n                    break;\n                }\n                if (idx[sortBlock[rPos]] == value)\n                {\n                    BzpSwap2Elem(sortBlock, ePos, rPos);\n                }\n                else if (lPos == ePos)\n                {\n\n                    BzpSwap2Elem(sortBlock, ePos, rPos);\n                    lPos++;\n                }\n                else\n                {\n                    BzpSwap3Elem(sortBlock, lPos, ePos, rPos);\n                    lPos++;\n                }\n                ePos++;\n                rPos--;\n            }\n        }\n\n        if (lPos - tl > tr - rPos)\n        {\n            stack->stackL[stack->cnt] = tl;\n            stack->stackR[stack->cnt] = lPos - 1;\n            stack->cnt++;\n            stack->stackL[stack->cnt] = rPos + 1;\n            stack->stackR[stack->cnt] = tr;\n            stack->cnt++;\n        }\n        else\n        {\n            stack->stackL[stack->cnt] = rPos + 1;\n            stack->stackR[stack->cnt] = tr;\n            stack->cnt++;\n            stack->stackL[stack->cnt] = tl;\n            stack->stackR[stack->cnt] = lPos - 1;\n            stack->cnt++;\n        }\n    }": "101", "void BzpQuickSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r)\n    {\n        BzpQSortInfo stack;\n        stack.cnt = 0;\n        stack.stackL[stack.cnt] = l;\n        stack.stackR[stack.cnt] = r;\n        stack.cnt++;\n        while (stack.cnt > 0)\n        {\n            stack.cnt--;\n            int32_t tl = stack.stackL[stack.cnt];\n            int32_t tr = stack.stackR[stack.cnt];\n\n            if (tl >= tr)\n            {\n                continue;\n            }\n            if (tr - tl < BZP_THRESHOLD_SHELL_SORT)\n            {\n                BzpShellSort(sortBlock, idx, tl, tr);\n                continue;\n            }\n            stack.tl = tl;\n            stack.tr = tr;\n            BzpQSortSingle(sortBlock, idx, &stack);\n        }\n    }": "102", "void BzpUpdateflag(BzpBwtInfo *bwt, int32_t l, int32_t r)\n    {\n        int32_t tmpst = -1;\n        for (int32_t i = l; i <= r; i++)\n        {\n            int32_t tmpnow = bwt->idx[bwt->sortBlock[i]];\n            if (tmpst != tmpnow)\n            {\n                bwt->isStartPos[i] = 1;\n                tmpst = tmpnow;\n            }\n        }\n    }": "103", "void BzpBinaryLiftingSort(BzpBwtInfo *bwt)\n    {\n        int32_t ftab[BZP_ASCII_SIZE];\n        (void)memset_s(ftab, sizeof(ftab), 0, sizeof(ftab));\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            ftab[bwt->block[i]]++;\n        }\n        for (int32_t i = 1; i < BZP_ASCII_SIZE; i++)\n        {\n            ftab[i] += ftab[i - 1];\n        }\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            int32_t ch = bwt->block[i];\n            ftab[ch]--;\n            bwt->sortBlock[ftab[ch]] = i;\n        }\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            bwt->isStartPos[ftab[i]] = 1;\n        }\n        int32_t M = 1, sortflag = true;\n\n        while (M < bwt->nBlock && sortflag == true)\n        {\n            int32_t st = 0;\n            sortflag = false;\n\n            for (int32_t i = 0; i < bwt->nBlock; i++)\n            {\n                if (bwt->isStartPos[i])\n                {\n                    st = i;\n                }\n                int32_t pos = bwt->sortBlock[i] - M;\n                if (pos < 0)\n                {\n                    pos += bwt->nBlock;\n                }\n                bwt->idx[pos] = st;\n            }\n            int32_t l = 0, r = 1;\n            while (l < bwt->nBlock)\n            {\n                while (r < bwt->nBlock && bwt->isStartPos[r] != 1)\n                {\n                    r++;\n                }\n                r--;\n                if (l < r)\n                {\n                    sortflag = true;\n                    BzpQuickSort(bwt->sortBlock, bwt->idx, l, r);\n                    BzpUpdateflag(bwt, l, r);\n                }\n                l = r + 1;\n                r = l + 1;\n            }\n            M <<= 1;\n        }\n    }": "104", "void BzpBlockSortMain(BzpBwtInfo *bwt)\n    {\n        BzpBinaryLiftingSort(bwt);\n\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            if (bwt->sortBlock[i] == 0)\n            {\n                bwt->oriPtr = i;\n                break;\n            }\n        }\n    }": "105", "void BzpBwtFinish(BzpBwtInfo *bwt)\n    {\n        if (bwt != NULL)\n        {\n            if (bwt->block != NULL)\n            {\n                free(bwt->block);\n                bwt->block = NULL;\n            }\n            if (bwt->sortBlock != NULL)\n            {\n                free(bwt->sortBlock);\n                bwt->sortBlock = NULL;\n            }\n            if (bwt->idx != NULL)\n            {\n                free(bwt->idx);\n                bwt->idx = NULL;\n            }\n            if (bwt->isStartPos != NULL)\n            {\n                free(bwt->isStartPos);\n                bwt->isStartPos = NULL;\n            }\n\n            free(bwt);\n            bwt = NULL;\n        }\n    }": "106", "void BzpHuffmanInit(int32_t alphaSize, BzpHuffmanInfo *huffman)\n    {\n        (void)memset_s(huffman->len, sizeof(huffman->len), 0, sizeof(huffman->len));\n        huffman->nHeap = 0;\n        huffman->nWeight = 0;\n        huffman->alphaSize = alphaSize;\n    }": "107", "void BzpHuffmanInitArray(BzpHuffmanInfo *huffman)\n    {\n        int32_t i;\n        huffman->nHeap = 0;\n        huffman->nWeight = huffman->alphaSize;\n\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->parent[i] = -1;\n        }\n    }": "108", "void BzpHeapAdjustUp(int32_t *heap, int32_t *weight, int32_t pos)\n    {\n        int32_t tmpw = weight[heap[pos]];\n        int32_t tmpv = heap[pos];\n        while (pos > 1)\n        {\n            if (tmpw < weight[heap[pos >> 1]])\n            {\n                heap[pos] = heap[pos >> 1];\n                pos >>= 1;\n            }\n            else\n            {\n                break;\n            }\n        }\n        heap[pos] = tmpv;\n    }": "109", "void BzpHeapAdjustDown(int32_t *heap, int32_t *weight, int32_t nHeap)\n    {\n        int32_t pos = 1;\n        int32_t chpos = pos << 1;\n        int32_t tmpid = heap[pos];\n        int32_t tmpv = weight[tmpid];\n        while (chpos <= nHeap)\n        {\n            if ((chpos | 1) <= nHeap && weight[heap[chpos]] > weight[heap[chpos | 1]])\n            {\n                chpos |= 1;\n            }\n            if (tmpv < weight[heap[chpos]])\n            {\n                break;\n            }\n            heap[pos] = heap[chpos];\n            pos = chpos;\n            chpos = pos << 1;\n        }\n        heap[pos] = tmpid;\n    }": "110", "void BzpHeapInit(BzpHuffmanInfo *huffman)\n    {\n        int32_t i = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = i;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }": "111", "int32_t BzpHuffmanWeightAdd(int32_t w1, int32_t w2)\n    {\n        return ((w1 & 0xffffff00) + (w2 & 0xffffff00)) | (BZP_MAX_FUN((w1 & 0x000000ff), (w2 & 0x000000ff)) + 1);\n    }": "112", "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }": "113", "int32_t BzpGetCodeLen(BzpHuffmanInfo *huffman)\n    {\n        int32_t maxlen = 0;\n\n        BzpBuildHuffmanTree(huffman);\n        int32_t i;\n        maxlen = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            int32_t x = i;\n            int32_t tlen = 0;\n            while (huffman->parent[x] >= 0)\n            {\n                x = huffman->parent[x];\n                tlen++;\n            }\n            huffman->len[i] = tlen;\n            maxlen = BZP_MAX_FUN(maxlen, tlen);\n        }\n\n        return maxlen;\n    }": "114", "void BzpBuildTreeBalanceHeight(BzpHuffmanInfo *huffman)\n    {\n        int32_t maxlen = 0;\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            if (huffman->weight[i] == 0)\n            {\n                huffman->weight[i] = 1 << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n            }\n            else\n            {\n                huffman->weight[i] <<= BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n            }\n        }\n\n        do\n        {\n            maxlen = BzpGetCodeLen(huffman);\n\n            if (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE)\n            {\n                for (int32_t i = 0; i < huffman->alphaSize; i++)\n                {\n                    int32_t w = (huffman->weight[i] >> BZP_HUFFMAN_HEIGHT_WEIGHT_BITS);\n                    w = ((w >> 1) + 1);\n                    huffman->weight[i] = w << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n                }\n            }\n        } while (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE);\n    }": "115", "void BzpGetHuffmanTable(BzpHuffmanInfo *huffman)\n    {\n        int32_t vec = 0;\n        int32_t mi = huffman->len[0], mx = huffman->len[0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[i]);\n        }\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[j] == i)\n                {\n                    huffman->table[j] = vec;\n                    vec++;\n                }\n            }\n            vec <<= 1;\n        }\n    }": "116", "int32_t BzpHuffmanGroupsReset(BzpHuffmanGroups *huffman, int32_t alphaSize)\n    {\n        if (BZP_INVALID_ALPHA_SIZE(alphaSize))\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        huffman->alphaSize = alphaSize;\n        huffman->block = NULL;\n        huffman->mtfFreq = NULL;\n        huffman->nSelect = 0;\n        huffman->nGroups = 0;\n\n        for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++)\n        {\n            BzpHuffmanInit(alphaSize, &huffman->huffmanGroups[i]);\n        }\n        return BZP_OK;\n    }": "117", "BzpHuffmanGroups *BzpHuffmanGroupsInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpHuffmanGroups *huffmanGroups = (BzpHuffmanGroups *)malloc(sizeof(BzpHuffmanGroups));\n        if (huffmanGroups == NULL)\n        {\n            return NULL;\n        }\n        huffmanGroups->select = NULL;\n        huffmanGroups->selectMTF = NULL;\n        int32_t spaceSize = blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP;\n        huffmanGroups->select = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        huffmanGroups->selectMTF = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (huffmanGroups->select == NULL || huffmanGroups->selectMTF == NULL)\n        {\n            BzpBzpHuffmanGroupsFinish(huffmanGroups);\n            return NULL;\n        }\n        huffmanGroups->alphaSize = 0;\n        huffmanGroups->block = NULL;\n        huffmanGroups->mtfFreq = NULL;\n        huffmanGroups->nSelect = 0;\n        huffmanGroups->nGroups = 0;\n\n        for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++)\n        {\n            BzpHuffmanInit(0, &huffmanGroups->huffmanGroups[i]);\n        }\n\n        return huffmanGroups;\n    }": "118", "void BzpBzpHuffmanGroupsFinish(BzpHuffmanGroups *huffman)\n    {\n        if (huffman != NULL)\n        {\n            if (huffman->select != NULL)\n            {\n                free(huffman->select);\n                huffman->select = NULL;\n            }\n            if (huffman->selectMTF != NULL)\n            {\n                free(huffman->selectMTF);\n                huffman->selectMTF = NULL;\n            }\n            free(huffman);\n            huffman = NULL;\n        }\n    }": "119", "int32_t BzpGetHuffmanGroups(int32_t nBlock)\n    {\n        int32_t nGroups = 1;\n        if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT0)\n        {\n            nGroups = BZP_NGROUPS_NUM_0;\n        }\n        else if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT1)\n        {\n            nGroups = BZP_NGROUPS_NUM_1;\n        }\n        else if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT2)\n        {\n            nGroups = BZP_NGROUPS_NUM_2;\n        }\n        else if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT3)\n        {\n            nGroups = BZP_NGROUPS_NUM_3;\n        }\n        else\n        {\n            nGroups = BZP_NGROUPS_NUM_4;\n        }\n        return nGroups;\n    }": "120", "void BzpGenerateSelectMTF(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t list[nGroups];\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            list[i] = i;\n        }\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = 0;\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                if (huffman->select[i] == list[j])\n                {\n                    pos = j;\n                    break;\n                }\n            }\n            for (int32_t j = pos; j > 0; j--)\n            {\n                list[j] = list[j - 1];\n            }\n            list[0] = huffman->select[i];\n            huffman->selectMTF[i] = pos;\n        }\n    }": "121", "void BzpInitLenArray(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t npart = nGroups;\n        int32_t AllFreqNum = huffman->nBlock;\n        int32_t st = 0, ed;\n\n        while (npart > 0)\n        {\n            int32_t NowFreqNum = 0;\n            int32_t FreqNumLimit = AllFreqNum / npart;\n\n            ed = st - 1;\n            while (ed < huffman->alphaSize - 1 && NowFreqNum < FreqNumLimit)\n            {\n                ed++;\n                NowFreqNum += huffman->mtfFreq[ed];\n            }\n\n            if (ed > st && npart != nGroups && npart != 1 && ((nGroups - npart) & 1))\n            {\n                NowFreqNum -= huffman->mtfFreq[ed];\n                ed--;\n            }\n\n            for (int32_t i = 0; i < huffman->alphaSize; i++)\n            {\n                if (i >= st && i <= ed)\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = 0;\n                }\n                else\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST;\n                }\n            }\n            npart--;\n            st = ed + 1;\n            AllFreqNum -= NowFreqNum;\n        }\n    }": "122", "void BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed)\n    {\n        (void)memset_s(huffman->cost, sizeof(huffman->cost), 0, sizeof(huffman->cost));\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = st; k <= ed; k++)\n        {\n            for (int32_t t = 0; t < nGroups; t++)\n            {\n                huffman->cost[t] += huffman->huffmanGroups[t].len[huffman->block[k]];\n            }\n        }\n    }": "123", "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }": "124", "void BzpHuffmanMain(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n        huffman->nGroups = nGroups;\n\n        BzpInitLenArray(huffman);\n        int32_t st = 0, ed;\n\n        for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++)\n        {\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                (void)memset_s(huffman->huffmanGroups[j].weight, sizeof(huffman->huffmanGroups[j].weight), 0,\n                               sizeof(huffman->huffmanGroups[j].weight));\n            }\n\n            st = 0;\n            huffman->nSelect = 0;\n            while (st < huffman->nBlock)\n            {\n                ed = BZP_MIN_FUN(huffman->nBlock, st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) - 1;\n\n                BzpCalculateCost(huffman, st, ed);\n\n                int32_t id = BzpSelectTree(huffman);\n\n                for (int32_t k = st; k <= ed; k++)\n                {\n                    huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n                }\n                st = ed + 1;\n            }\n\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n            }\n        }\n\n        BzpGenerateSelectMTF(huffman);\n\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n        }\n    }": "125", "static unsigned int sortedarray_first_index(SortedArray *sortedarray, SortedArrayValue data, unsigned int left,\n                                            unsigned int right)\n{\n    unsigned int index = left;\n\n    while (left < right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order > 0)\n        {\n            left = index + 1;\n        }\n        else\n        {\n            right = index;\n        }\n    }\n\n    return index;\n}": "126", "static unsigned int sortedarray_last_index(SortedArray *sortedarray, SortedArrayValue data, unsigned int left,\n                                           unsigned int right)\n{\n    unsigned int index = right;\n\n    while (left < right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order <= 0)\n        {\n            left = index + 1;\n        }\n        else\n        {\n            right = index;\n        }\n    }\n\n    return index;\n}": "127", "SortedArrayValue *sortedarray_get(SortedArray *array, unsigned int i)\n{\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    return array->data[i];\n}": "128", "unsigned int sortedarray_length(SortedArray *array)\n{\n    return array->length;\n}": "129", "SortedArray *sortedarray_new(unsigned int length, SortedArrayEqualFunc equ_func, SortedArrayCompareFunc cmp_func)\n{\n\n    if (equ_func == NULL || cmp_func == NULL)\n    {\n        return NULL;\n    }\n\n    if (length == 0)\n    {\n        length = 16;\n    }\n\n    SortedArrayValue *array = malloc(sizeof(SortedArrayValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    SortedArray *sortedarray = malloc(sizeof(SortedArray));\n\n    if (sortedarray == NULL)\n    {\n        free(array);\n        return NULL;\n    }\n\n    sortedarray->data = array;\n    sortedarray->length = 0;\n    sortedarray->_alloced = length;\n    sortedarray->equ_func = equ_func;\n    sortedarray->cmp_func = cmp_func;\n    return sortedarray;\n}": "130", "void sortedarray_free(SortedArray *sortedarray)\n{\n    if (sortedarray != NULL)\n    {\n        free(sortedarray->data);\n        free(sortedarray);\n    }\n}": "131", "void sortedarray_remove(SortedArray *sortedarray, unsigned int index)\n{\n\n    sortedarray_remove_range(sortedarray, index, 1);\n}": "132", "void sortedarray_remove_range(SortedArray *sortedarray, unsigned int index, unsigned int length)\n{\n\n    if (index > sortedarray->length || index + length > sortedarray->length)\n    {\n        return;\n    }\n\n    memmove(&sortedarray->data[index], &sortedarray->data[index + length],\n            (sortedarray->length - (index + length)) * sizeof(SortedArrayValue));\n\n    sortedarray->length -= length;\n}": "133", "int sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data)\n{\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            break;\n        }\n    }\n\n    if (sortedarray->length > 0 && sortedarray->cmp_func(data, sortedarray->data[index]) > 0)\n    {\n        index++;\n    }\n\n    if (sortedarray->length + 1 > sortedarray->_alloced)\n    {\n\n        unsigned int newsize;\n        SortedArrayValue *data;\n\n        newsize = sortedarray->_alloced * 2;\n        data = realloc(sortedarray->data, sizeof(SortedArrayValue) * newsize);\n\n        if (data == NULL)\n        {\n            return 0;\n        }\n        else\n        {\n            sortedarray->data = data;\n            sortedarray->_alloced = newsize;\n        }\n    }\n\n    memmove(&sortedarray->data[index + 1], &sortedarray->data[index],\n            (sortedarray->length - index) * sizeof(SortedArrayValue));\n\n    sortedarray->data[index] = data;\n    ++(sortedarray->length);\n\n    return 1;\n}": "134", "int sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data)\n{\n    if (sortedarray == NULL)\n    {\n        return -1;\n    }\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            left = sortedarray_first_index(sortedarray, data, left, index);\n            right = sortedarray_last_index(sortedarray, data, index, right);\n\n            for (index = left; index <= right; index++)\n            {\n                if (sortedarray->equ_func(data, sortedarray->data[index]))\n                {\n                    return (int)index;\n                }\n            }\n\n            return -1;\n        }\n    }\n\n    return -1;\n}": "135", "void sortedarray_clear(SortedArray *sortedarray)\n{\n\n    sortedarray->length = 0;\n}": "136", "static int binomial_heap_cmp(BinomialHeap *heap, BinomialHeapValue data1, BinomialHeapValue data2)\n{\n    if (heap->heap_type == BINOMIAL_HEAP_TYPE_MIN)\n    {\n        return heap->compare_func(data1, data2);\n    }\n    else\n    {\n        return -(heap->compare_func(data1, data2));\n    }\n}": "137", "static void binomial_tree_ref(BinomialTree *tree)\n{\n    if (tree != NULL)\n    {\n        ++tree->refcount;\n    }\n}": "138", "static void binomial_tree_unref(BinomialTree *tree)\n{\n    int i;\n\n    if (tree == NULL)\n    {\n        return;\n    }\n\n    --tree->refcount;\n\n    if (tree->refcount == 0)\n    {\n\n        for (i = 0; i < tree->order; ++i)\n        {\n            binomial_tree_unref(tree->subtrees[i]);\n        }\n\n        free(tree->subtrees);\n        free(tree);\n    }\n}": "139", "static BinomialTree *binomial_tree_merge(BinomialHeap *heap, BinomialTree *tree1, BinomialTree *tree2)\n{\n    BinomialTree *new_tree;\n    BinomialTree *tmp;\n    int i;\n\n    if (binomial_heap_cmp(heap, tree1->value, tree2->value) > 0)\n    {\n\n        tmp = tree1;\n        tree1 = tree2;\n        tree2 = tmp;\n    }\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->refcount = 0;\n    new_tree->order = (unsigned short)(tree1->order + 1);\n\n    new_tree->value = tree1->value;\n\n    new_tree->subtrees = malloc(sizeof(BinomialTree *) * new_tree->order);\n\n    if (new_tree->subtrees == NULL)\n    {\n        free(new_tree);\n        return NULL;\n    }\n\n    memcpy(new_tree->subtrees, tree1->subtrees, sizeof(BinomialTree *) * tree1->order);\n    new_tree->subtrees[new_tree->order - 1] = tree2;\n\n    for (i = 0; i < new_tree->order; ++i)\n    {\n        binomial_tree_ref(new_tree->subtrees[i]);\n    }\n\n    return new_tree;\n}": "140", "static void binomial_heap_merge_undo(BinomialTree **new_roots, unsigned int count)\n{\n    unsigned int i;\n\n    for (i = 0; i <= count; ++i)\n    {\n        binomial_tree_unref(new_roots[i]);\n    }\n\n    free(new_roots);\n}": "141", "static int binomial_heap_merge(BinomialHeap *heap, BinomialHeap *other)\n{\n    BinomialTree **new_roots;\n    unsigned int new_roots_length;\n    BinomialTree *vals[3];\n    int num_vals;\n    BinomialTree *carry;\n    BinomialTree *new_carry;\n    unsigned int max;\n    unsigned int i;\n\n    if (heap->roots_length > other->roots_length)\n    {\n        max = heap->roots_length + 1;\n    }\n    else\n    {\n        max = other->roots_length + 1;\n    }\n\n    new_roots = malloc(sizeof(BinomialTree *) * max);\n\n    if (new_roots == NULL)\n    {\n        return 0;\n    }\n\n    new_roots_length = 0;\n    carry = NULL;\n\n    for (i = 0; i < max; ++i)\n    {\n\n        num_vals = 0;\n\n        if (i < heap->roots_length && heap->roots[i] != NULL)\n        {\n            vals[num_vals] = heap->roots[i];\n            ++num_vals;\n        }\n\n        if (i < other->roots_length && other->roots[i] != NULL)\n        {\n            vals[num_vals] = other->roots[i];\n            ++num_vals;\n        }\n\n        if (carry != NULL)\n        {\n            vals[num_vals] = carry;\n            ++num_vals;\n        }\n\n        if ((num_vals & 1) != 0)\n        {\n\n            new_roots[i] = vals[num_vals - 1];\n            binomial_tree_ref(new_roots[i]);\n            new_roots_length = i + 1;\n        }\n        else\n        {\n\n            new_roots[i] = NULL;\n        }\n\n        if ((num_vals & 2) != 0)\n        {\n\n            new_carry = binomial_tree_merge(heap, vals[0], vals[1]);\n\n            if (new_carry == NULL)\n            {\n\n                binomial_heap_merge_undo(new_roots, i);\n\n                binomial_tree_unref(carry);\n\n                return 0;\n            }\n        }\n        else\n        {\n\n            new_carry = NULL;\n        }\n\n        binomial_tree_unref(carry);\n\n        carry = new_carry;\n\n        binomial_tree_ref(carry);\n    }\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n        if (heap->roots[i] != NULL)\n        {\n            binomial_tree_unref(heap->roots[i]);\n        }\n    }\n\n    free(heap->roots);\n    heap->roots = new_roots;\n    heap->roots_length = new_roots_length;\n\n    return 1;\n}": "142", "BinomialHeap *binomial_heap_new(BinomialHeapType heap_type, BinomialHeapCompareFunc compare_func)\n{\n    BinomialHeap *new_heap;\n\n    new_heap = calloc(1, sizeof(BinomialHeap));\n\n    if (new_heap == NULL)\n    {\n        return NULL;\n    }\n\n    new_heap->heap_type = heap_type;\n    new_heap->compare_func = compare_func;\n\n    return new_heap;\n}": "143", "void binomial_heap_free(BinomialHeap *heap)\n{\n    unsigned int i;\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n        binomial_tree_unref(heap->roots[i]);\n    }\n\n    free(heap->roots);\n    free(heap);\n}": "144", "int binomial_heap_insert(BinomialHeap *heap, BinomialHeapValue value)\n{\n    BinomialHeap fake_heap;\n    BinomialTree *new_tree;\n    int result;\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return 0;\n    }\n\n    new_tree->value = value;\n    new_tree->order = 0;\n    new_tree->refcount = 1;\n    new_tree->subtrees = NULL;\n\n    fake_heap.heap_type = heap->heap_type;\n    fake_heap.compare_func = heap->compare_func;\n    fake_heap.num_values = 1;\n    fake_heap.roots = &new_tree;\n    fake_heap.roots_length = 1;\n\n    result = binomial_heap_merge(heap, &fake_heap);\n\n    if (result != 0)\n    {\n        ++heap->num_values;\n    }\n\n    binomial_tree_unref(new_tree);\n\n    return result;\n}": "145", "BinomialHeapValue binomial_heap_pop(BinomialHeap *heap)\n{\n    BinomialTree *least_tree;\n    BinomialHeap fake_heap;\n    BinomialHeapValue result;\n    unsigned int i;\n    unsigned int least_index;\n\n    if (heap->num_values == 0)\n    {\n        return BINOMIAL_HEAP_NULL;\n    }\n\n    least_index = UINT_MAX;\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n\n        if (heap->roots[i] == NULL)\n        {\n            continue;\n        }\n\n        if (least_index == UINT_MAX ||\n            binomial_heap_cmp(heap, heap->roots[i]->value, heap->roots[least_index]->value) < 0)\n        {\n            least_index = i;\n        }\n    }\n\n    least_tree = heap->roots[least_index];\n    heap->roots[least_index] = NULL;\n\n    fake_heap.heap_type = heap->heap_type;\n    fake_heap.compare_func = heap->compare_func;\n    fake_heap.roots = least_tree->subtrees;\n    fake_heap.roots_length = least_tree->order;\n\n    if (binomial_heap_merge(heap, &fake_heap))\n    {\n\n        result = least_tree->value;\n        binomial_tree_unref(least_tree);\n\n        --heap->num_values;\n\n        return result;\n    }\n    else\n    {\n\n        heap->roots[least_index] = least_tree;\n\n        return BINOMIAL_HEAP_NULL;\n    }\n}": "146", "unsigned int binomial_heap_num_entries(BinomialHeap *heap)\n{\n    return heap->num_values;\n}": "147", "int pointer_equal(void *location1, void *location2)\n{\n    return location1 == location2;\n}": "148", "int pointer_compare(void *location1, void *location2)\n{\n    if (location1 < location2)\n    {\n        return -1;\n    }\n    else if (location1 > location2)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}": "149", "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}": "150", "void bloom_filter_free(BloomFilter *bloomfilter)\n{\n    free(bloomfilter->table);\n    free(bloomfilter);\n}": "151", "void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = (unsigned char)(1 << (index % 8));\n        bloomfilter->table[index / 8] |= b;\n    }\n}": "152", "int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n    int bit;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = bloomfilter->table[index / 8];\n        bit = 1 << (index % 8);\n\n        if ((b & bit) == 0)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}": "153", "void bloom_filter_read(BloomFilter *bloomfilter, unsigned char *array)\n{\n    unsigned int array_size;\n\n    array_size = (bloomfilter->table_size + 7) / 8;\n\n    memcpy(array, bloomfilter->table, array_size);\n}": "154", "void bloom_filter_load(BloomFilter *bloomfilter, unsigned char *array)\n{\n    unsigned int array_size;\n\n    array_size = (bloomfilter->table_size + 7) / 8;\n\n    memcpy(bloomfilter->table, array, array_size);\n}": "155", "BloomFilter *bloom_filter_union(BloomFilter *filter1, BloomFilter *filter2)\n{\n    BloomFilter *result;\n    unsigned int i;\n    unsigned int array_size;\n\n    if (filter1->table_size != filter2->table_size || filter1->num_functions != filter2->num_functions ||\n        filter1->hash_func != filter2->hash_func)\n    {\n        return NULL;\n    }\n\n    result = bloom_filter_new(filter1->table_size, filter1->hash_func, filter1->num_functions);\n\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    array_size = (filter1->table_size + 7) / 8;\n\n    for (i = 0; i < array_size; ++i)\n    {\n        result->table[i] = filter1->table[i] | filter2->table[i];\n    }\n\n    return result;\n}": "156", "BloomFilter *bloom_filter_intersection(BloomFilter *filter1, BloomFilter *filter2)\n{\n    BloomFilter *result;\n    unsigned int i;\n    unsigned int array_size;\n\n    if (filter1->table_size != filter2->table_size || filter1->num_functions != filter2->num_functions ||\n        filter1->hash_func != filter2->hash_func)\n    {\n        return NULL;\n    }\n\n    result = bloom_filter_new(filter1->table_size, filter1->hash_func, filter1->num_functions);\n\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    array_size = (filter1->table_size + 7) / 8;\n\n    for (i = 0; i < array_size; ++i)\n    {\n        result->table[i] = filter1->table[i] & filter2->table[i];\n    }\n\n    return result;\n}": "157", "ArrayList *arraylist_new(unsigned int length)\n{\n    ArrayList *new_arraylist;\n\n    if (length <= 0)\n    {\n        length = 16;\n    }\n\n    new_arraylist = (ArrayList *)malloc(sizeof(ArrayList));\n\n    if (new_arraylist == NULL)\n    {\n        return NULL;\n    }\n\n    new_arraylist->_alloced = length;\n    new_arraylist->length = 0;\n\n    new_arraylist->data = malloc(length * sizeof(ArrayListValue));\n\n    if (new_arraylist->data == NULL)\n    {\n        free(new_arraylist);\n        return NULL;\n    }\n\n    return new_arraylist;\n}": "158", "void arraylist_free(ArrayList *arraylist)\n{\n\n    if (arraylist != NULL)\n    {\n        free(arraylist->data);\n        free(arraylist);\n    }\n}": "159", "static int arraylist_enlarge(ArrayList *arraylist)\n{\n    ArrayListValue *data;\n    unsigned int newsize;\n\n    newsize = arraylist->_alloced * 2;\n\n    data = realloc(arraylist->data, sizeof(ArrayListValue) * newsize);\n\n    if (data == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        arraylist->data = data;\n        arraylist->_alloced = newsize;\n\n        return 1;\n    }\n}": "160", "int arraylist_insert(ArrayList *arraylist, unsigned int index, ArrayListValue data)\n{\n\n    if (index > arraylist->length)\n    {\n        return 0;\n    }\n\n    if (arraylist->length + 1 > arraylist->_alloced)\n    {\n        if (!arraylist_enlarge(arraylist))\n        {\n            return 0;\n        }\n    }\n\n    memmove(&arraylist->data[index + 1], &arraylist->data[index], (arraylist->length - index) * sizeof(ArrayListValue));\n\n    arraylist->data[index] = data;\n    ++arraylist->length;\n\n    return 1;\n}": "161", "int arraylist_append(ArrayList *arraylist, ArrayListValue data)\n{\n    return arraylist_insert(arraylist, arraylist->length, data);\n}": "162", "int arraylist_prepend(ArrayList *arraylist, ArrayListValue data)\n{\n    return arraylist_insert(arraylist, 0, data);\n}": "163", "void arraylist_remove_range(ArrayList *arraylist, unsigned int index, unsigned int length)\n{\n\n    if (index > arraylist->length || index + length > arraylist->length)\n    {\n        return;\n    }\n\n    memmove(&arraylist->data[index], &arraylist->data[index + length],\n            (arraylist->length - (index + length)) * sizeof(ArrayListValue));\n\n    arraylist->length -= length;\n}": "164", "void arraylist_remove(ArrayList *arraylist, unsigned int index)\n{\n    arraylist_remove_range(arraylist, index, 1);\n}": "165", "int arraylist_index_of(ArrayList *arraylist, ArrayListEqualFunc callback, ArrayListValue data)\n{\n    unsigned int i;\n\n    for (i = 0; i < arraylist->length; ++i)\n    {\n        if (callback(arraylist->data[i], data) != 0)\n            return (int)i;\n    }\n\n    return -1;\n}": "166", "void arraylist_clear(ArrayList *arraylist)\n{\n\n    arraylist->length = 0;\n}": "167", "static void arraylist_sort_internal(ArrayListValue *list_data, unsigned int list_length,\n                                    ArrayListCompareFunc compare_func)\n{\n    ArrayListValue pivot;\n    ArrayListValue tmp;\n    unsigned int i;\n    unsigned int list1_length;\n    unsigned int list2_length;\n\n    if (list_length <= 1)\n    {\n        return;\n    }\n\n    pivot = list_data[list_length - 1];\n# 221 \".tmp/src/arraylist.c\"\n    list1_length = 0;\n\n    for (i = 0; i < list_length - 1; ++i)\n    {\n\n        if (compare_func(list_data[i], pivot) < 0)\n        {\n\n            tmp = list_data[i];\n            list_data[i] = list_data[list1_length];\n            list_data[list1_length] = tmp;\n\n            ++list1_length;\n        }\n        else\n        {\n        }\n    }\n\n    list2_length = list_length - list1_length - 1;\n# 255 \".tmp/src/arraylist.c\"\n    list_data[list_length - 1] = list_data[list1_length];\n    list_data[list1_length] = pivot;\n\n    arraylist_sort_internal(list_data, list1_length, compare_func);\n\n    arraylist_sort_internal(&list_data[list1_length + 1], list2_length, compare_func);\n}": "168", "void arraylist_sort(ArrayList *arraylist, ArrayListCompareFunc compare_func)\n{\n\n    arraylist_sort_internal(arraylist->data, arraylist->length, compare_func);\n}": "169", "static int binary_heap_cmp(BinaryHeap *heap, BinaryHeapValue data1, BinaryHeapValue data2)\n{\n    if (heap->heap_type == BINARY_HEAP_TYPE_MIN)\n    {\n        return heap->compare_func(data1, data2);\n    }\n    else\n    {\n        return -heap->compare_func(data1, data2);\n    }\n}": "170", "BinaryHeap *binary_heap_new(BinaryHeapType heap_type, BinaryHeapCompareFunc compare_func)\n{\n    BinaryHeap *heap;\n\n    heap = malloc(sizeof(BinaryHeap));\n\n    if (heap == NULL)\n    {\n        return NULL;\n    }\n\n    heap->heap_type = heap_type;\n    heap->num_values = 0;\n    heap->compare_func = compare_func;\n\n    heap->alloced_size = 16;\n    heap->values = malloc(sizeof(BinaryHeapValue) * heap->alloced_size);\n\n    if (heap->values == NULL)\n    {\n        free(heap);\n        return NULL;\n    }\n\n    return heap;\n}": "171", "void binary_heap_free(BinaryHeap *heap)\n{\n    free(heap->values);\n    free(heap);\n}": "172", "int binary_heap_insert(BinaryHeap *heap, BinaryHeapValue value)\n{\n    BinaryHeapValue *new_values;\n    unsigned int index;\n    unsigned int new_size;\n    unsigned int parent;\n\n    if (heap->num_values >= heap->alloced_size)\n    {\n\n        new_size = heap->alloced_size * 2;\n        new_values = realloc(heap->values, sizeof(BinaryHeapValue) * new_size);\n\n        if (new_values == NULL)\n        {\n            return 0;\n        }\n\n        heap->alloced_size = new_size;\n        heap->values = new_values;\n    }\n\n    index = heap->num_values;\n    ++heap->num_values;\n\n    while (index > 0)\n    {\n\n        parent = (index - 1) / 2;\n\n        if (binary_heap_cmp(heap, heap->values[parent], value) < 0)\n        {\n\n            break;\n        }\n        else\n        {\n\n            heap->values[index] = heap->values[parent];\n\n            index = parent;\n        }\n    }\n\n    heap->values[index] = value;\n\n    return 1;\n}": "173", "BinaryHeapValue binary_heap_pop(BinaryHeap *heap)\n{\n    BinaryHeapValue result;\n    BinaryHeapValue new_value;\n    unsigned int index;\n    unsigned int next_index;\n    unsigned int child1, child2;\n\n    if (heap->num_values == 0)\n    {\n        return BINARY_HEAP_NULL;\n    }\n\n    result = heap->values[0];\n\n    new_value = heap->values[heap->num_values - 1];\n    --heap->num_values;\n\n    index = 0;\n\n    for (;;)\n    {\n\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child1]) > 0)\n        {\n\n            if (child2 < heap->num_values && binary_heap_cmp(heap, heap->values[child1], heap->values[child2]) > 0)\n            {\n                next_index = child2;\n            }\n            else\n            {\n                next_index = child1;\n            }\n        }\n        else if (child2 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child2]) > 0)\n        {\n\n            next_index = child2;\n        }\n        else\n        {\n\n            heap->values[index] = new_value;\n            break;\n        }\n\n        heap->values[index] = heap->values[next_index];\n\n        index = next_index;\n    }\n\n    return result;\n}": "174", "unsigned int binary_heap_num_entries(BinaryHeap *heap)\n{\n    return heap->num_values;\n}": "175", "unsigned int string_hash(void *string)\n{\n\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + *p;\n        ++p;\n    }\n\n    return result;\n}": "176", "unsigned int string_nocase_hash(void *string)\n{\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + (unsigned int)tolower(*p);\n        ++p;\n    }\n\n    return result;\n}": "177", "void list_free(ListEntry *list)\n{\n    ListEntry *entry;\n\n    entry = list;\n\n    while (entry != NULL)\n    {\n        ListEntry *next;\n\n        next = entry->next;\n\n        free(entry);\n\n        entry = next;\n    }\n}": "178", "ListEntry *list_prepend(ListEntry **list, ListValue data)\n{\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    if (*list != NULL)\n    {\n        (*list)->prev = newentry;\n    }\n    newentry->prev = NULL;\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}": "179", "ListEntry *list_append(ListEntry **list, ListValue data)\n{\n    ListEntry *rover;\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n        newentry->prev = NULL;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        newentry->prev = rover;\n        rover->next = newentry;\n    }\n\n    return newentry;\n}": "180", "ListValue list_data(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return LIST_NULL;\n    }\n\n    return listentry->data;\n}": "181", "void list_set_data(ListEntry *listentry, ListValue value)\n{\n    if (listentry != NULL)\n    {\n        listentry->data = value;\n    }\n}": "182", "ListEntry *list_prev(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return NULL;\n    }\n\n    return listentry->prev;\n}": "183", "ListEntry *list_next(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return NULL;\n    }\n\n    return listentry->next;\n}": "184", "ListEntry *list_nth_entry(ListEntry *list, unsigned int n)\n{\n    ListEntry *entry;\n    unsigned int i;\n\n    entry = list;\n\n    for (i = 0; i < n; ++i)\n    {\n\n        if (entry == NULL)\n        {\n            return NULL;\n        }\n        entry = entry->next;\n    }\n\n    return entry;\n}": "185", "ListValue list_nth_data(ListEntry *list, unsigned int n)\n{\n    ListEntry *entry;\n\n    entry = list_nth_entry(list, n);\n\n    if (entry == NULL)\n    {\n        return LIST_NULL;\n    }\n    else\n    {\n        return entry->data;\n    }\n}": "186", "unsigned int list_length(ListEntry *list)\n{\n    ListEntry *entry;\n    unsigned int length;\n\n    length = 0;\n    entry = list;\n\n    while (entry != NULL)\n    {\n\n        ++length;\n\n        entry = entry->next;\n    }\n\n    return length;\n}": "187", "ListValue *list_to_array(ListEntry *list)\n{\n    ListEntry *rover;\n    ListValue *array;\n    unsigned int length;\n    unsigned int i;\n\n    length = list_length(list);\n\n    array = malloc(sizeof(ListValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    rover = list;\n\n    for (i = 0; i < length; ++i)\n    {\n\n        array[i] = rover->data;\n\n        rover = rover->next;\n    }\n\n    return array;\n}": "188", "int list_remove_entry(ListEntry **list, ListEntry *entry)\n{\n\n    if (list == NULL || *list == NULL || entry == NULL)\n    {\n        return 0;\n    }\n\n    if (entry->prev == NULL)\n    {\n\n        *list = entry->next;\n\n        if (entry->next != NULL)\n        {\n            entry->next->prev = NULL;\n        }\n    }\n    else\n    {\n\n        entry->prev->next = entry->next;\n\n        if (entry->next != NULL)\n        {\n            entry->next->prev = entry->prev;\n        }\n    }\n\n    free(entry);\n\n    return 1;\n}": "189", "unsigned int list_remove_data(ListEntry **list, ListEqualFunc callback, ListValue data)\n{\n    unsigned int entries_removed;\n    ListEntry *rover;\n    ListEntry *next;\n\n    if (list == NULL || callback == NULL)\n    {\n        return 0;\n    }\n\n    entries_removed = 0;\n\n    rover = *list;\n\n    while (rover != NULL)\n    {\n\n        next = rover->next;\n\n        if (callback(rover->data, data))\n        {\n\n            if (rover->prev == NULL)\n            {\n\n                *list = rover->next;\n            }\n            else\n            {\n\n                rover->prev->next = rover->next;\n            }\n\n            if (rover->next != NULL)\n            {\n                rover->next->prev = rover->prev;\n            }\n\n            free(rover);\n\n            ++entries_removed;\n        }\n\n        rover = next;\n    }\n\n    return entries_removed;\n}": "190", "static ListEntry *list_sort_internal(ListEntry **list, ListCompareFunc compare_func)\n{\n    ListEntry *pivot;\n    ListEntry *rover;\n    ListEntry *less_list, *more_list;\n    ListEntry *less_list_end, *more_list_end;\n\n    if (list == NULL || compare_func == NULL)\n    {\n        return NULL;\n    }\n\n    if (*list == NULL || (*list)->next == NULL)\n    {\n        return *list;\n    }\n\n    pivot = *list;\n\n    less_list = NULL;\n    more_list = NULL;\n    rover = (*list)->next;\n\n    while (rover != NULL)\n    {\n        ListEntry *next = rover->next;\n\n        if (compare_func(rover->data, pivot->data) < 0)\n        {\n\n            rover->prev = NULL;\n            rover->next = less_list;\n            if (less_list != NULL)\n            {\n                less_list->prev = rover;\n            }\n            less_list = rover;\n        }\n        else\n        {\n\n            rover->prev = NULL;\n            rover->next = more_list;\n            if (more_list != NULL)\n            {\n                more_list->prev = rover;\n            }\n            more_list = rover;\n        }\n\n        rover = next;\n    }\n\n    less_list_end = list_sort_internal(&less_list, compare_func);\n    more_list_end = list_sort_internal(&more_list, compare_func);\n\n    *list = less_list;\n\n    if (less_list == NULL)\n    {\n        pivot->prev = NULL;\n        *list = pivot;\n    }\n    else\n    {\n        pivot->prev = less_list_end;\n        less_list_end->next = pivot;\n    }\n\n    pivot->next = more_list;\n    if (more_list != NULL)\n    {\n        more_list->prev = pivot;\n    }\n\n    if (more_list == NULL)\n    {\n        return pivot;\n    }\n    else\n    {\n        return more_list_end;\n    }\n}": "191", "void list_sort(ListEntry **list, ListCompareFunc compare_func)\n{\n    list_sort_internal(list, compare_func);\n}": "192", "ListEntry *list_find_data(ListEntry *list, ListEqualFunc callback, ListValue data)\n{\n    ListEntry *rover;\n\n    for (rover = list; rover != NULL; rover = rover->next)\n    {\n        if (callback(rover->data, data) != 0)\n        {\n            return rover;\n        }\n    }\n\n    return NULL;\n}": "193", "void list_iterate(ListEntry **list, ListIterator *iter)\n{\n\n    iter->prev_next = list;\n\n    iter->current = NULL;\n}": "194", "int list_iter_has_more(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        return *iter->prev_next != NULL;\n    }\n    else\n    {\n\n        return iter->current->next != NULL;\n    }\n}": "195", "ListValue list_iter_next(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        iter->current = *iter->prev_next;\n    }\n    else\n    {\n\n        iter->prev_next = &iter->current->next;\n        iter->current = iter->current->next;\n    }\n\n    if (iter->current == NULL)\n    {\n        return LIST_NULL;\n    }\n    else\n    {\n        return iter->current->data;\n    }\n}": "196", "void list_iter_remove(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n    }\n    else\n    {\n\n        *iter->prev_next = iter->current->next;\n\n        if (iter->current->next != NULL)\n        {\n            iter->current->next->prev = iter->current->prev;\n        }\n\n        free(iter->current);\n        iter->current = NULL;\n    }\n}": "197", "void slist_free(SListEntry *list)\n{\n    SListEntry *entry;\n\n    entry = list;\n\n    while (entry != NULL)\n    {\n        SListEntry *next;\n\n        next = entry->next;\n\n        free(entry);\n\n        entry = next;\n    }\n}": "198", "SListEntry *slist_prepend(SListEntry **list, SListValue data)\n{\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}": "199", "SListEntry *slist_append(SListEntry **list, SListValue data)\n{\n    SListEntry *rover;\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        rover->next = newentry;\n    }\n\n    return newentry;\n}": "200", "SListValue slist_data(SListEntry *listentry)\n{\n    return listentry->data;\n}": "201", "void slist_set_data(SListEntry *listentry, SListValue data)\n{\n    if (listentry != NULL)\n    {\n        listentry->data = data;\n    }\n}": "202", "SListEntry *slist_next(SListEntry *listentry)\n{\n    return listentry->next;\n}": "203", "SListEntry *slist_nth_entry(SListEntry *list, unsigned int n)\n{\n    SListEntry *entry;\n    unsigned int i;\n\n    entry = list;\n\n    for (i = 0; i < n; ++i)\n    {\n\n        if (entry == NULL)\n        {\n            return NULL;\n        }\n        entry = entry->next;\n    }\n\n    return entry;\n}": "204", "SListValue slist_nth_data(SListEntry *list, unsigned int n)\n{\n    SListEntry *entry;\n\n    entry = slist_nth_entry(list, n);\n\n    if (entry == NULL)\n    {\n        return SLIST_NULL;\n    }\n    else\n    {\n        return entry->data;\n    }\n}": "205", "unsigned int slist_length(SListEntry *list)\n{\n    SListEntry *entry;\n    unsigned int length;\n\n    length = 0;\n    entry = list;\n\n    while (entry != NULL)\n    {\n\n        ++length;\n\n        entry = entry->next;\n    }\n\n    return length;\n}": "206", "SListValue *slist_to_array(SListEntry *list)\n{\n    SListEntry *rover;\n    SListValue *array;\n    unsigned int length;\n    unsigned int i;\n\n    length = slist_length(list);\n\n    array = malloc(sizeof(SListValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    rover = list;\n\n    for (i = 0; i < length; ++i)\n    {\n\n        array[i] = rover->data;\n\n        rover = rover->next;\n    }\n\n    return array;\n}": "207", "int slist_remove_entry(SListEntry **list, SListEntry *entry)\n{\n    SListEntry *rover;\n\n    if (*list == NULL || entry == NULL)\n    {\n        return 0;\n    }\n\n    if (*list == entry)\n    {\n\n        *list = entry->next;\n    }\n    else\n    {\n\n        rover = *list;\n\n        while (rover != NULL && rover->next != entry)\n        {\n            rover = rover->next;\n        }\n\n        if (rover == NULL)\n        {\n\n            return 0;\n        }\n        else\n        {\n\n            rover->next = entry->next;\n        }\n    }\n\n    free(entry);\n\n    return 1;\n}": "208", "unsigned int slist_remove_data(SListEntry **list, SListEqualFunc callback, SListValue data)\n{\n    SListEntry **rover;\n    SListEntry *next;\n    unsigned int entries_removed;\n\n    entries_removed = 0;\n\n    rover = list;\n\n    while (*rover != NULL)\n    {\n\n        if (callback((*rover)->data, data) != 0)\n        {\n\n            next = (*rover)->next;\n            free(*rover);\n            *rover = next;\n\n            ++entries_removed;\n        }\n        else\n        {\n\n            rover = &((*rover)->next);\n        }\n    }\n\n    return entries_removed;\n}": "209", "static SListEntry *slist_sort_internal(SListEntry **list, SListCompareFunc compare_func)\n{\n    SListEntry *pivot;\n    SListEntry *rover;\n    SListEntry *less_list, *more_list;\n    SListEntry *less_list_end, *more_list_end;\n\n    if (*list == NULL || (*list)->next == NULL)\n    {\n        return *list;\n    }\n\n    pivot = *list;\n\n    less_list = NULL;\n    more_list = NULL;\n    rover = (*list)->next;\n\n    while (rover != NULL)\n    {\n        SListEntry *next = rover->next;\n\n        if (compare_func(rover->data, pivot->data) < 0)\n        {\n\n            rover->next = less_list;\n            less_list = rover;\n        }\n        else\n        {\n\n            rover->next = more_list;\n            more_list = rover;\n        }\n\n        rover = next;\n    }\n\n    less_list_end = slist_sort_internal(&less_list, compare_func);\n    more_list_end = slist_sort_internal(&more_list, compare_func);\n\n    *list = less_list;\n\n    if (less_list == NULL)\n    {\n        *list = pivot;\n    }\n    else\n    {\n        less_list_end->next = pivot;\n    }\n\n    pivot->next = more_list;\n\n    if (more_list == NULL)\n    {\n        return pivot;\n    }\n    else\n    {\n        return more_list_end;\n    }\n}": "210", "void slist_sort(SListEntry **list, SListCompareFunc compare_func)\n{\n    slist_sort_internal(list, compare_func);\n}": "211", "SListEntry *slist_find_data(SListEntry *list, SListEqualFunc callback, SListValue data)\n{\n    SListEntry *rover;\n\n    for (rover = list; rover != NULL; rover = rover->next)\n    {\n        if (callback(rover->data, data) != 0)\n        {\n            return rover;\n        }\n    }\n\n    return NULL;\n}": "212", "void slist_iterate(SListEntry **list, SListIterator *iter)\n{\n\n    iter->prev_next = list;\n\n    iter->current = NULL;\n}": "213", "int slist_iter_has_more(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        return *iter->prev_next != NULL;\n    }\n    else\n    {\n\n        return iter->current->next != NULL;\n    }\n}": "214", "SListValue slist_iter_next(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        iter->current = *iter->prev_next;\n    }\n    else\n    {\n\n        iter->prev_next = &iter->current->next;\n        iter->current = iter->current->next;\n    }\n\n    if (iter->current == NULL)\n    {\n        return SLIST_NULL;\n    }\n    else\n    {\n        return iter->current->data;\n    }\n}": "215", "void slist_iter_remove(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n    }\n    else\n    {\n\n        *iter->prev_next = iter->current->next;\n        free(iter->current);\n        iter->current = NULL;\n    }\n}": "216", "Queue *queue_new(void)\n{\n    Queue *queue;\n\n    queue = (Queue *)malloc(sizeof(Queue));\n\n    if (queue == NULL)\n    {\n        return NULL;\n    }\n\n    queue->head = NULL;\n    queue->tail = NULL;\n\n    return queue;\n}": "217", "void queue_free(Queue *queue)\n{\n\n    while (!queue_is_empty(queue))\n    {\n        queue_pop_head(queue);\n    }\n\n    free(queue);\n}": "218", "int queue_push_head(Queue *queue, QueueValue data)\n{\n    QueueEntry *new_entry;\n\n    new_entry = malloc(sizeof(QueueEntry));\n\n    if (new_entry == NULL)\n    {\n        return 0;\n    }\n\n    new_entry->data = data;\n    new_entry->prev = NULL;\n    new_entry->next = queue->head;\n\n    if (queue->head == NULL)\n    {\n\n        queue->head = new_entry;\n        queue->tail = new_entry;\n    }\n    else\n    {\n\n        queue->head->prev = new_entry;\n\n        queue->head = new_entry;\n    }\n\n    return 1;\n}": "219", "QueueValue queue_pop_head(Queue *queue)\n{\n    QueueEntry *entry;\n    QueueValue result;\n\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n\n    entry = queue->head;\n    queue->head = entry->next;\n    result = entry->data;\n\n    if (queue->head == NULL)\n    {\n\n        queue->tail = NULL;\n    }\n    else\n    {\n\n        queue->head->prev = NULL;\n    }\n\n    free(entry);\n\n    return result;\n}": "220", "QueueValue queue_peek_head(Queue *queue)\n{\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n    else\n    {\n        return queue->head->data;\n    }\n}": "221", "int queue_push_tail(Queue *queue, QueueValue data)\n{\n    QueueEntry *new_entry;\n\n    new_entry = malloc(sizeof(QueueEntry));\n\n    if (new_entry == NULL)\n    {\n        return 0;\n    }\n\n    new_entry->data = data;\n    new_entry->prev = queue->tail;\n    new_entry->next = NULL;\n\n    if (queue->tail == NULL)\n    {\n\n        queue->head = new_entry;\n        queue->tail = new_entry;\n    }\n    else\n    {\n\n        queue->tail->next = new_entry;\n\n        queue->tail = new_entry;\n    }\n\n    return 1;\n}": "222", "QueueValue queue_pop_tail(Queue *queue)\n{\n    QueueEntry *entry;\n    QueueValue result;\n\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n\n    entry = queue->tail;\n    queue->tail = entry->prev;\n    result = entry->data;\n\n    if (queue->tail == NULL)\n    {\n\n        queue->head = NULL;\n    }\n    else\n    {\n\n        queue->tail->next = NULL;\n    }\n\n    free(entry);\n\n    return result;\n}": "223", "QueueValue queue_peek_tail(Queue *queue)\n{\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n    else\n    {\n        return queue->tail->data;\n    }\n}": "224", "int queue_is_empty(Queue *queue)\n{\n    return queue->head == NULL;\n}": "225", "unsigned int pointer_hash(void *location)\n{\n    return (unsigned int)(unsigned long)location;\n}": "226", "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}": "227", "static void set_free_entry(Set *set, SetEntry *entry)\n{\n\n    if (set->free_func != NULL)\n    {\n        set->free_func(entry->data);\n    }\n\n    free(entry);\n}": "228", "Set *set_new(SetHashFunc hash_func, SetEqualFunc equal_func)\n{\n    Set *new_set;\n\n    new_set = (Set *)malloc(sizeof(Set));\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    new_set->hash_func = hash_func;\n    new_set->equal_func = equal_func;\n    new_set->entries = 0;\n    new_set->prime_index = 0;\n    new_set->free_func = NULL;\n\n    if (!set_allocate_table(new_set))\n    {\n        free(new_set);\n        return NULL;\n    }\n\n    return new_set;\n}": "229", "void set_free(Set *set)\n{\n    SetEntry *rover;\n    SetEntry *next;\n    unsigned int i;\n\n    for (i = 0; i < set->table_size; ++i)\n    {\n        rover = set->table[i];\n\n        while (rover != NULL)\n        {\n            next = rover->next;\n\n            set_free_entry(set, rover);\n\n            rover = next;\n        }\n    }\n\n    free(set->table);\n\n    free(set);\n}": "230", "void set_register_free_function(Set *set, SetFreeFunc free_func)\n{\n    set->free_func = free_func;\n}": "231", "static int set_enlarge(Set *set)\n{\n    SetEntry *rover;\n    SetEntry *next;\n    SetEntry **old_table;\n    unsigned int old_table_size;\n    unsigned int old_prime_index;\n    unsigned int index;\n    unsigned int i;\n\n    old_table = set->table;\n    old_table_size = set->table_size;\n    old_prime_index = set->prime_index;\n\n    ++set->prime_index;\n\n    if (!set_allocate_table(set))\n    {\n        set->table = old_table;\n        set->table_size = old_table_size;\n        set->prime_index = old_prime_index;\n\n        return 0;\n    }\n\n    for (i = 0; i < old_table_size; ++i)\n    {\n\n        rover = old_table[i];\n\n        while (rover != NULL)\n        {\n\n            next = rover->next;\n\n            index = set->hash_func(rover->data) % set->table_size;\n            rover->next = set->table[index];\n            set->table[index] = rover;\n\n            rover = next;\n        }\n    }\n\n    free(old_table);\n\n    return 1;\n}": "232", "int set_insert(Set *set, SetValue data)\n{\n    SetEntry *newentry;\n    SetEntry *rover;\n    unsigned int index;\n\n    if ((set->entries * 3) / set->table_size > 0)\n    {\n\n        if (!set_enlarge(set))\n        {\n            return 0;\n        }\n    }\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 0;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (SetEntry *)malloc(sizeof(SetEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->data = data;\n\n    newentry->next = set->table[index];\n    set->table[index] = newentry;\n\n    ++set->entries;\n\n    return 1;\n}": "233", "int set_remove(Set *set, SetValue data)\n{\n    SetEntry **rover;\n    SetEntry *entry;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = &set->table[index];\n\n    while (*rover != NULL)\n    {\n        if (set->equal_func(data, (*rover)->data) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            --set->entries;\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return 0;\n}": "234", "int set_query(Set *set, SetValue data)\n{\n    SetEntry *rover;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    return 0;\n}": "235", "unsigned int set_num_entries(Set *set)\n{\n    return set->entries;\n}": "236", "SetValue *set_to_array(Set *set)\n{\n    SetValue *array;\n    int array_counter;\n    unsigned int i;\n    SetEntry *rover;\n\n    array = malloc(sizeof(SetValue) * set->entries);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    array_counter = 0;\n\n    for (i = 0; i < set->table_size; ++i)\n    {\n\n        rover = set->table[i];\n\n        while (rover != NULL)\n        {\n\n            array[array_counter] = rover->data;\n            ++array_counter;\n\n            rover = rover->next;\n        }\n    }\n\n    return array;\n}": "237", "Set *set_union(Set *set1, Set *set2)\n{\n    SetIterator iterator;\n    Set *new_set;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set1->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (!set_insert(new_set, value))\n        {\n\n            set_free(new_set);\n            return NULL;\n        }\n    }\n\n    set_iterate(set2, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(new_set, value) == 0)\n        {\n            if (!set_insert(new_set, value))\n            {\n\n                set_free(new_set);\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}": "238", "Set *set_intersection(Set *set1, Set *set2)\n{\n    Set *new_set;\n    SetIterator iterator;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set2->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(set2, value) != 0)\n        {\n\n            if (!set_insert(new_set, value))\n            {\n                set_free(new_set);\n\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}": "239", "void set_iterate(Set *set, SetIterator *iter)\n{\n    unsigned int chain;\n\n    iter->set = set;\n    iter->next_entry = NULL;\n\n    for (chain = 0; chain < set->table_size; ++chain)\n    {\n\n        if (set->table[chain] != NULL)\n        {\n            iter->next_entry = set->table[chain];\n            break;\n        }\n    }\n\n    iter->next_chain = chain;\n}": "240", "SetValue set_iter_next(SetIterator *iterator)\n{\n    Set *set;\n    SetValue result;\n    SetEntry *current_entry;\n    unsigned int chain;\n\n    set = iterator->set;\n\n    if (iterator->next_entry == NULL)\n    {\n        return SET_NULL;\n    }\n\n    current_entry = iterator->next_entry;\n    result = current_entry->data;\n\n    if (current_entry->next != NULL)\n    {\n\n        iterator->next_entry = current_entry->next;\n    }\n    else\n    {\n\n        iterator->next_entry = NULL;\n\n        chain = iterator->next_chain + 1;\n\n        while (chain < set->table_size)\n        {\n\n            if (set->table[chain] != NULL)\n            {\n\n                iterator->next_entry = set->table[chain];\n\n                break;\n            }\n\n            ++chain;\n        }\n\n        iterator->next_chain = chain;\n    }\n\n    return result;\n}": "241", "int set_iter_has_more(SetIterator *iterator)\n{\n    return iterator->next_entry != NULL;\n}": "242", "unsigned int int_hash(void *vlocation)\n{\n    int *location;\n\n    location = (int *)vlocation;\n\n    return (unsigned int)*location;\n}": "243", "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}": "244", "static void hash_table_free_entry(HashTable *hash_table, HashTableEntry *entry)\n{\n    HashTablePair *pair;\n\n    pair = &(entry->pair);\n\n    if (hash_table->key_free_func != NULL)\n    {\n        hash_table->key_free_func(pair->key);\n    }\n\n    if (hash_table->value_free_func != NULL)\n    {\n        hash_table->value_free_func(pair->value);\n    }\n\n    free(entry);\n}": "245", "HashTable *hash_table_new(HashTableHashFunc hash_func, HashTableEqualFunc equal_func)\n{\n    HashTable *hash_table;\n\n    hash_table = (HashTable *)malloc(sizeof(HashTable));\n\n    if (hash_table == NULL)\n    {\n        return NULL;\n    }\n\n    hash_table->hash_func = hash_func;\n    hash_table->equal_func = equal_func;\n    hash_table->key_free_func = NULL;\n    hash_table->value_free_func = NULL;\n    hash_table->entries = 0;\n    hash_table->prime_index = 0;\n\n    if (!hash_table_allocate_table(hash_table))\n    {\n        free(hash_table);\n\n        return NULL;\n    }\n\n    return hash_table;\n}": "246", "void hash_table_free(HashTable *hash_table)\n{\n    HashTableEntry *rover;\n    HashTableEntry *next;\n    unsigned int i;\n\n    for (i = 0; i < hash_table->table_size; ++i)\n    {\n        rover = hash_table->table[i];\n        while (rover != NULL)\n        {\n            next = rover->next;\n            hash_table_free_entry(hash_table, rover);\n            rover = next;\n        }\n    }\n\n    free(hash_table->table);\n\n    free(hash_table);\n}": "247", "void hash_table_register_free_functions(HashTable *hash_table, HashTableKeyFreeFunc key_free_func,\n                                        HashTableValueFreeFunc value_free_func)\n{\n    hash_table->key_free_func = key_free_func;\n    hash_table->value_free_func = value_free_func;\n}": "248", "static int hash_table_enlarge(HashTable *hash_table)\n{\n    HashTableEntry **old_table;\n    unsigned int old_table_size;\n    unsigned int old_prime_index;\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *next;\n    unsigned int index;\n    unsigned int i;\n\n    old_table = hash_table->table;\n    old_table_size = hash_table->table_size;\n    old_prime_index = hash_table->prime_index;\n\n    ++hash_table->prime_index;\n\n    if (!hash_table_allocate_table(hash_table))\n    {\n\n        hash_table->table = old_table;\n        hash_table->table_size = old_table_size;\n        hash_table->prime_index = old_prime_index;\n\n        return 0;\n    }\n\n    for (i = 0; i < old_table_size; ++i)\n    {\n        rover = old_table[i];\n\n        while (rover != NULL)\n        {\n            next = rover->next;\n\n            pair = &(rover->pair);\n\n            index = hash_table->hash_func(pair->key) % hash_table->table_size;\n\n            rover->next = hash_table->table[index];\n            hash_table->table[index] = rover;\n\n            rover = next;\n        }\n    }\n\n    free(old_table);\n\n    return 1;\n}": "249", "int hash_table_insert(HashTable *hash_table, HashTableKey key, HashTableValue value)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *newentry;\n    unsigned int index;\n\n    if ((hash_table->entries * 3) / hash_table->table_size > 0)\n    {\n\n        if (!hash_table_enlarge(hash_table))\n        {\n\n            return 0;\n        }\n    }\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(pair->key, key) != 0)\n        {\n\n            if (hash_table->value_free_func != NULL)\n            {\n                hash_table->value_free_func(pair->value);\n            }\n\n            if (hash_table->key_free_func != NULL)\n            {\n                hash_table->key_free_func(pair->key);\n            }\n\n            pair->key = key;\n            pair->value = value;\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (HashTableEntry *)malloc(sizeof(HashTableEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->pair.key = key;\n    newentry->pair.value = value;\n\n    newentry->next = hash_table->table[index];\n    hash_table->table[index] = newentry;\n\n    ++hash_table->entries;\n\n    return 1;\n}": "250", "HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    unsigned int index;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            return pair->value;\n        }\n\n        rover = rover->next;\n    }\n\n    return HASH_TABLE_NULL;\n}": "251", "int hash_table_remove(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry **rover;\n    HashTableEntry *entry;\n    HashTablePair *pair;\n    unsigned int index;\n    int result;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    result = 0;\n    rover = &hash_table->table[index];\n\n    while (*rover != NULL)\n    {\n\n        pair = &((*rover)->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            --hash_table->entries;\n\n            result = 1;\n\n            break;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return result;\n}": "252", "unsigned int hash_table_num_entries(HashTable *hash_table)\n{\n    return hash_table->entries;\n}": "253", "void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)\n{\n    unsigned int chain;\n\n    iterator->hash_table = hash_table;\n\n    iterator->next_entry = NULL;\n\n    for (chain = 0; chain < hash_table->table_size; ++chain)\n    {\n\n        if (hash_table->table[chain] != NULL)\n        {\n            iterator->next_entry = hash_table->table[chain];\n            iterator->next_chain = chain;\n            break;\n        }\n    }\n}": "254", "int hash_table_iter_has_more(HashTableIterator *iterator)\n{\n    return iterator->next_entry != NULL;\n}": "255", "HashTablePair hash_table_iter_next(HashTableIterator *iterator)\n{\n    HashTableEntry *current_entry;\n    HashTable *hash_table;\n    HashTablePair pair = {NULL, NULL};\n    unsigned int chain;\n\n    hash_table = iterator->hash_table;\n\n    if (iterator->next_entry == NULL)\n    {\n        return pair;\n    }\n\n    current_entry = iterator->next_entry;\n    pair = current_entry->pair;\n\n    if (current_entry->next != NULL)\n    {\n\n        iterator->next_entry = current_entry->next;\n    }\n    else\n    {\n\n        chain = iterator->next_chain + 1;\n\n        iterator->next_entry = NULL;\n\n        while (chain < hash_table->table_size)\n        {\n\n            if (hash_table->table[chain] != NULL)\n            {\n                iterator->next_entry = hash_table->table[chain];\n                break;\n            }\n\n            ++chain;\n        }\n\n        iterator->next_chain = chain;\n    }\n\n    return pair;\n}": "256", "int int_equal(void *vlocation1, void *vlocation2)\n{\n    int *location1;\n    int *location2;\n\n    location1 = (int *)vlocation1;\n    location2 = (int *)vlocation2;\n\n    return *location1 == *location2;\n}": "257", "int int_compare(void *vlocation1, void *vlocation2)\n{\n    int *location1;\n    int *location2;\n\n    location1 = (int *)vlocation1;\n    location2 = (int *)vlocation2;\n\n    if (*location1 < *location2)\n    {\n        return -1;\n    }\n    else if (*location1 > *location2)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}": "258", "AVLTree *avl_tree_new(AVLTreeCompareFunc compare_func)\n{\n    AVLTree *new_tree;\n\n    new_tree = (AVLTree *)malloc(sizeof(AVLTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->root_node = NULL;\n    new_tree->compare_func = compare_func;\n    new_tree->num_nodes = 0;\n\n    return new_tree;\n}": "259", "static void avl_tree_free_subtree(AVLTree *tree, AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return;\n    }\n\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_LEFT]);\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_RIGHT]);\n\n    free(node);\n}": "260", "void avl_tree_free(AVLTree *tree)\n{\n\n    avl_tree_free_subtree(tree, tree->root_node);\n\n    free(tree);\n}": "261", "int avl_tree_subtree_height(AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return node->height;\n    }\n}": "262", "static void avl_tree_update_height(AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    int left_height, right_height;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height > right_height)\n    {\n        node->height = left_height + 1;\n    }\n    else\n    {\n        node->height = right_height + 1;\n    }\n}": "263", "static AVLTreeNodeSide avl_tree_node_parent_side(AVLTreeNode *node)\n{\n    if (node->parent->children[AVL_TREE_NODE_LEFT] == node)\n    {\n        return AVL_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return AVL_TREE_NODE_RIGHT;\n    }\n}": "264", "static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1, AVLTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = avl_tree_node_parent_side(node1);\n        node1->parent->children[side] = node2;\n\n        avl_tree_update_height(node1->parent);\n    }\n}": "265", "static AVLTreeNode *avl_tree_rotate(AVLTree *tree, AVLTreeNode *node, AVLTreeNodeSide direction)\n{\n    AVLTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    avl_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    avl_tree_update_height(new_root);\n    avl_tree_update_height(node);\n\n    return new_root;\n}": "266", "static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *child;\n    int diff;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2)\n    {\n\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]))\n        {\n\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);\n    }\n    else if (diff <= -2)\n    {\n\n        child = node->children[AVL_TREE_NODE_LEFT];\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]))\n        {\n\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}": "267", "static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *rover;\n\n    rover = node;\n\n    while (rover != NULL)\n    {\n\n        rover = avl_tree_node_balance(tree, rover);\n\n        rover = rover->parent;\n    }\n}": "268", "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}": "269", "static AVLTreeNode *avl_tree_node_get_replacement(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *result;\n    AVLTreeNode *child;\n    int left_height, right_height;\n    int side;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    if (left_subtree == NULL && right_subtree == NULL)\n    {\n        return NULL;\n    }\n\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height < right_height)\n    {\n        side = AVL_TREE_NODE_RIGHT;\n    }\n    else\n    {\n        side = AVL_TREE_NODE_LEFT;\n    }\n\n    result = node->children[side];\n\n    while (result->children[1 - side] != NULL)\n    {\n        result = result->children[1 - side];\n    }\n\n    child = result->children[side];\n    avl_tree_node_replace(tree, result, child);\n\n    avl_tree_update_height(result->parent);\n\n    return result;\n}": "270", "void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *swap_node;\n    AVLTreeNode *balance_startpoint;\n    int i;\n\n    swap_node = avl_tree_node_get_replacement(tree, node);\n\n    if (swap_node == NULL)\n    {\n\n        avl_tree_node_replace(tree, node, NULL);\n\n        balance_startpoint = node->parent;\n    }\n    else\n    {\n\n        if (swap_node->parent == node)\n        {\n            balance_startpoint = swap_node;\n        }\n        else\n        {\n            balance_startpoint = swap_node->parent;\n        }\n\n        for (i = 0; i < 2; ++i)\n        {\n            swap_node->children[i] = node->children[i];\n\n            if (swap_node->children[i] != NULL)\n            {\n                swap_node->children[i]->parent = swap_node;\n            }\n        }\n\n        swap_node->height = node->height;\n\n        avl_tree_node_replace(tree, node, swap_node);\n    }\n\n    free(node);\n\n    --tree->num_nodes;\n\n    avl_tree_balance_to_root(tree, balance_startpoint);\n}": "271", "int avl_tree_remove(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n\n        return 0;\n    }\n\n    avl_tree_remove_node(tree, node);\n\n    return 1;\n}": "272", "AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n\n            return node;\n        }\n        else if (diff < 0)\n        {\n            node = node->children[AVL_TREE_NODE_LEFT];\n        }\n        else\n        {\n            node = node->children[AVL_TREE_NODE_RIGHT];\n        }\n    }\n\n    return NULL;\n}": "273", "AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return AVL_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}": "274", "AVLTreeNode *avl_tree_root_node(AVLTree *tree)\n{\n    return tree->root_node;\n}": "275", "AVLTreeKey avl_tree_node_key(AVLTreeNode *node)\n{\n    return node->key;\n}": "276", "AVLTreeValue avl_tree_node_value(AVLTreeNode *node)\n{\n    return node->value;\n}": "277", "AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)\n{\n    if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}": "278", "AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)\n{\n    return node->parent;\n}": "279", "unsigned int avl_tree_num_entries(AVLTree *tree)\n{\n    return tree->num_nodes;\n}": "280", "static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree, AVLTreeValue *array, int *index)\n{\n    if (subtree == NULL)\n    {\n        return;\n    }\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT], array, index);\n\n    array[*index] = subtree->key;\n    ++*index;\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT], array, index);\n}": "281", "AVLTreeValue *avl_tree_to_array(AVLTree *tree)\n{\n    AVLTreeValue *array;\n    int index;\n\n    array = malloc(sizeof(AVLTreeValue) * tree->num_nodes);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    index = 0;\n\n    avl_tree_to_array_add_subtree(tree->root_node, array, &index);\n\n    return array;\n}": "282", "int string_equal(void *string1, void *string2)\n{\n    return strcmp((char *)string1, (char *)string2) == 0;\n}": "283", "int string_compare(void *string1, void *string2)\n{\n    int result;\n\n    result = strcmp((char *)string1, (char *)string2);\n\n    if (result < 0)\n    {\n        return -1;\n    }\n    else if (result > 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}": "284", "int string_nocase_equal(void *string1, void *string2)\n{\n    return string_nocase_compare((char *)string1, (char *)string2) == 0;\n}": "285", "int string_nocase_compare(void *string1, void *string2)\n{\n    char *p1;\n    char *p2;\n    int c1, c2;\n\n    p1 = (char *)string1;\n    p2 = (char *)string2;\n\n    for (;;)\n    {\n\n        c1 = tolower(*p1);\n        c2 = tolower(*p2);\n\n        if (c1 != c2)\n        {\n\n            if (c1 < c2)\n            {\n                return -1;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n\n        if (c1 == '\\0')\n            break;\n\n        ++p1;\n        ++p2;\n    }\n\n    return 0;\n}": "286", "static RBTreeNodeSide rb_tree_node_side(RBTreeNode *node)\n{\n    if (node->parent->children[RB_TREE_NODE_LEFT] == node)\n    {\n        return RB_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return RB_TREE_NODE_RIGHT;\n    }\n}": "287", "static RBTreeNode *rb_tree_node_sibling(RBTreeNode *node)\n{\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    return node->parent->children[1 - side];\n}": "288", "RBTreeNode *rb_tree_node_uncle(RBTreeNode *node)\n{\n    return rb_tree_node_sibling(node->parent);\n}": "289", "static void rb_tree_node_replace(RBTree *tree, RBTreeNode *node1, RBTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = rb_tree_node_side(node1);\n        node1->parent->children[side] = node2;\n    }\n}": "290", "static RBTreeNode *rb_tree_rotate(RBTree *tree, RBTreeNode *node, RBTreeNodeSide direction)\n{\n    RBTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    rb_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    return new_root;\n}": "291", "RBTree *rb_tree_new(RBTreeCompareFunc compare_func)\n{\n    RBTree *new_tree;\n\n    new_tree = malloc(sizeof(RBTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->root_node = NULL;\n    new_tree->num_nodes = 0;\n    new_tree->compare_func = compare_func;\n\n    return new_tree;\n}": "292", "static void rb_tree_free_subtree(RBTreeNode *node)\n{\n    if (node != NULL)\n    {\n\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_LEFT]);\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_RIGHT]);\n\n        free(node);\n    }\n}": "293", "void rb_tree_free(RBTree *tree)\n{\n\n    rb_tree_free_subtree(tree->root_node);\n\n    free(tree);\n}": "294", "static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)\n{\n    if (node->parent == NULL)\n    {\n\n        node->color = RB_TREE_NODE_BLACK;\n    }\n    else\n    {\n\n        rb_tree_insert_case2(tree, node);\n    }\n}": "295", "static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)\n{\n\n    if (node->parent->color != RB_TREE_NODE_BLACK)\n    {\n        rb_tree_insert_case3(tree, node);\n    }\n}": "296", "static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *grandparent;\n    RBTreeNode *uncle;\n\n    grandparent = node->parent->parent;\n    uncle = rb_tree_node_uncle(node);\n\n    if (uncle != NULL && uncle->color == RB_TREE_NODE_RED)\n    {\n\n        node->parent->color = RB_TREE_NODE_BLACK;\n        uncle->color = RB_TREE_NODE_BLACK;\n        grandparent->color = RB_TREE_NODE_RED;\n\n        rb_tree_insert_case1(tree, grandparent);\n    }\n    else\n    {\n        rb_tree_insert_case4(tree, node);\n    }\n}": "297", "void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *next_node;\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    if (side != rb_tree_node_side(node->parent))\n    {\n\n        next_node = node->parent;\n\n        rb_tree_rotate(tree, node->parent, 1 - side);\n    }\n    else\n    {\n        next_node = node;\n    }\n\n    rb_tree_insert_case5(tree, next_node);\n}": "298", "void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *parent;\n    RBTreeNode *grandparent;\n    RBTreeNodeSide side;\n\n    parent = node->parent;\n    grandparent = parent->parent;\n\n    side = rb_tree_node_side(node);\n\n    rb_tree_rotate(tree, grandparent, 1 - side);\n\n    parent->color = RB_TREE_NODE_BLACK;\n    grandparent->color = RB_TREE_NODE_RED;\n}": "299", "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}": "300", "RBTreeNode *rb_tree_lookup_node(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n    RBTreeNodeSide side;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n            return node;\n        }\n        else if (diff < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        node = node->children[side];\n    }\n\n    return NULL;\n}": "301", "RBTreeValue rb_tree_lookup(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return RB_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}": "302", "void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)\n{\n}": "303", "int rb_tree_remove(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return 0;\n    }\n\n    rb_tree_remove_node(tree, node);\n\n    return 1;\n}": "304", "RBTreeNode *rb_tree_root_node(RBTree *tree)\n{\n    return tree->root_node;\n}": "305", "RBTreeKey rb_tree_node_key(RBTreeNode *node)\n{\n    return node->key;\n}": "306", "RBTreeValue rb_tree_node_value(RBTreeNode *node)\n{\n    return node->value;\n}": "307", "RBTreeNode *rb_tree_node_child(RBTreeNode *node, RBTreeNodeSide side)\n{\n    if (side == RB_TREE_NODE_LEFT || side == RB_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}": "308", "RBTreeNode *rb_tree_node_parent(RBTreeNode *node)\n{\n    return node->parent;\n}": "309", "RBTreeValue *rb_tree_to_array(RBTree *tree)\n{\n\n    return NULL;\n}": "310", "int rb_tree_num_entries(RBTree *tree)\n{\n    return tree->num_nodes;\n}": "311", "Trie *trie_new(void)\n{\n    Trie *new_trie;\n\n    new_trie = (Trie *)malloc(sizeof(Trie));\n\n    if (new_trie == NULL)\n    {\n        return NULL;\n    }\n\n    new_trie->root_node = NULL;\n\n    return new_trie;\n}": "312", "static void trie_free_list_push(TrieNode **list, TrieNode *node)\n{\n    node->data = *list;\n    *list = node;\n}": "313", "static TrieNode *trie_free_list_pop(TrieNode **list)\n{\n    TrieNode *result;\n\n    result = *list;\n    *list = result->data;\n\n    return result;\n}": "314", "void trie_free(Trie *trie)\n{\n    TrieNode *free_list;\n    TrieNode *node;\n    int i;\n\n    free_list = NULL;\n\n    if (trie->root_node != NULL)\n    {\n        trie_free_list_push(&free_list, trie->root_node);\n    }\n\n    while (free_list != NULL)\n    {\n        node = trie_free_list_pop(&free_list);\n\n        for (i = 0; i < 256; ++i)\n        {\n            if (node->next[i] != NULL)\n            {\n                trie_free_list_push(&free_list, node->next[i]);\n            }\n        }\n\n        free(node);\n    }\n\n    free(trie);\n}": "315", "static TrieNode *trie_find_end(Trie *trie, char *key)\n{\n    TrieNode *node;\n    char *p;\n\n    node = trie->root_node;\n\n    for (p = key; *p != '\\0'; ++p)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        node = node->next[(unsigned char)*p];\n    }\n\n    return node;\n}": "316", "static TrieNode *trie_find_end_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    int j;\n    int c;\n\n    node = trie->root_node;\n\n    for (j = 0; j < key_length; j++)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        c = (unsigned char)key[j];\n\n        node = node->next[c];\n    }\n\n    return node;\n}": "317", "static void trie_insert_rollback(Trie *trie, unsigned char *key)\n{\n    TrieNode *node;\n    TrieNode **prev_ptr;\n    TrieNode *next_node;\n    TrieNode **next_prev_ptr;\n    unsigned char *p;\n\n    node = trie->root_node;\n    prev_ptr = &trie->root_node;\n    p = key;\n\n    while (node != NULL)\n    {\n\n        next_prev_ptr = &node->next[(unsigned char)*p];\n        next_node = *next_prev_ptr;\n        ++p;\n\n        --node->use_count;\n\n        if (node->use_count == 0)\n        {\n            free(node);\n\n            if (prev_ptr != NULL)\n            {\n                *prev_ptr = NULL;\n            }\n\n            next_prev_ptr = NULL;\n        }\n\n        node = next_node;\n        prev_ptr = next_prev_ptr;\n    }\n}": "318", "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}": "319", "int trie_insert_binary(Trie *trie, unsigned char *key, int key_length, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    int p, c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)key[p];\n\n        if (p == key_length)\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}": "320", "int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    int p, c;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        c = (unsigned char)key[p];\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (p == key_length)\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}": "321", "int trie_remove(Trie *trie, char *key)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    char *p;\n    int c;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        c = (unsigned char)*p;\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (c == '\\0')\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}": "322", "TrieValue trie_lookup(Trie *trie, char *key)\n{\n    TrieNode *node;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}": "323", "TrieValue trie_lookup_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}": "324", "unsigned int trie_num_entries(Trie *trie)\n{\n\n    if (trie->root_node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return trie->root_node->use_count;\n    }\n}": "325", "void CmptlzLogWrite(size_t errorCode, const char *funcName, unsigned short line, const char *fmt, ...)\n    {\n        va_list alist;\n        char output[LOG_BUF_SIZE];\n        int ret;\n        size_t len;\n        CmptlzLogFunc func = g_cmptlzLogFunc;\n\n        if (func == NULL)\n        {\n            return;\n        }\n\n        ret = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1, \"\\n[Cmptlz-Log] Func=%s, Line=%u, Error=0x%zx\\n\",\n                         funcName, line, errorCode);\n        if (ret < 0)\n        {\n            return;\n        }\n        len = (size_t)ret;\n\n        va_start(alist, fmt);\n        ret = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1, fmt, alist);\n        va_end(alist);\n        if (ret < 0)\n        {\n            return;\n        }\n\n        func(output, strlen(output) + 1);\n    }": "326", "void CmptlzLogRegister(CmptlzLogFunc func)\n    {\n        g_cmptlzLogFunc = func;\n    }": "327", "static inline int CmptlzIsLE(void)\n    {\n#if (defined(__GNUC__) || defined(__clang__))\n        return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n        int n = 1;\n        return *(char *)(&n);\n    }": "328", "static inline uint32_t CmptlzSwap32(uint32_t val)\n    {\n#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)))\n        return (uint32_t)__builtin_bswap32(val);\n#endif\n        return ((0xff000000 & (val << 24)) | (0x000000ff & (val >> 24)) | (0x00ff0000 & (val << 8)) |\n                (0x0000ff00 & (val >> 8)));\n    }": "329", "static inline void CmptlzWriteLE32Bit(void *addr, uint32_t val)\n    {\n        if (CmptlzIsLE() != 0)\n        {\n            CMPTLZ_WRITE32BIT(addr, val);\n        }\n        else\n        {\n            CMPTLZ_WRITE32BIT(addr, CmptlzSwap32(val));\n        }\n    }": "330", "static inline CmptLzDecProb *CmptLzGetProbsMatrix(CmptLzDecCtx *decCtx)\n    {\n\n        return decCtx->probsPlus1664;\n    }": "331", "static inline CmptLzDecProb *CmptLzGetIsMatchProb(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_IS_MATCH;\n    }": "332", "static inline CmptLzDecProb *CmptLzGetIsRepProb(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_ISREP;\n    }": "333", "static inline CmptLzDecProb *CmptLzGetIsRepG0Prob(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_ISREPG0;\n    }": "334", "static inline CmptLzDecProb *CmptLzGetIsRepG1Prob(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ISREPG1;\n    }": "335", "static inline CmptLzDecProb *CmptLzGetIsRepG2Prob(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ISREPG2;\n    }": "336", "static inline CmptLzDecProb *CmptLzGetIsRepG0LongProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_REP0_LONG;\n    }": "337", "static inline CmptLzDecProb *CmptLzGetLiteralProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_LITERAL;\n    }": "338", "static inline CmptLzDecProb *CmptLzGetPosSlotProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_POSSLOT;\n    }": "339", "static inline CmptLzDecProb *CmptLzGetSpecPosProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_SPEC_POS;\n    }": "340", "static inline CmptLzDecProb *CmptLzGetAilgnProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ALIGN;\n    }": "341", "static inline CmptLzDecProb *CmptLzGetRepLenCoderProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_REP_LEN_CODER;\n    }": "342", "static inline CmptLzDecProb *CmptLzGetMatchLenCoderProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_MATCH_LEN_CODER;\n    }": "343", "static inline uint32_t CmptLzGetLenCondition(uint32_t decLen)\n    {\n        return ((decLen < CMPTLZ_LEN_CONDITION_TO_POSSLOT ? decLen : CMPTLZ_LEN_CONDITION_TO_POSSLOT - 1)\n                << CMPTLZ_POS_SLOT_BITS);\n    }": "344", "static inline uint32_t CmptLzGetBaseDistByPosSlot(uint32_t posSlot)\n    {\n        return (2 | (posSlot & 1));\n    }": "345", "static inline uint32_t CmptLzGetNumProbs(CmptLzDecProt *decProt)\n    {\n\n        return (NUM_BASE_PROBS + ((uint32_t)0x300 << (decProt->litCtx + decProt->litPos)));\n    }": "346", "static inline void CmptLzDecCheckDictSizeUpdate(CmptLzDecCtx *decCtx)\n{\n    if (decCtx->checkDicSize == 0 && decCtx->processedPos >= decCtx->prop.dicSize)\n    {\n        decCtx->checkDicSize = decCtx->prop.dicSize;\n    }\n}": "347", "static inline void CmptLzDecRemWriteInDict(CmptLzDecCtx *decCtx, size_t dicPosLimit)\n{\n    size_t dictPos = decCtx->dictPos;\n    size_t remainDecLen = decCtx->remainLen;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t remainDicLen = dicPosLimit - dictPos;\n    if (remainDicLen < remainDecLen)\n    {\n        remainDecLen = remainDicLen;\n    }\n\n    if (remainDecLen == 0)\n    {\n        return;\n    }\n\n    decCtx->processedPos += (uint32_t)remainDecLen;\n    decCtx->remainLen -= (uint32_t)remainDecLen;\n\n    unsigned char *dict = decCtx->dict;\n    size_t rep0 = decCtx->reps[0];\n    while (remainDecLen != 0)\n    {\n        remainDecLen--;\n        dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n        dictPos++;\n    }\n    decCtx->dictPos = dictPos;\n\n    CmptLzDecCheckDictSizeUpdate(decCtx);\n}": "348", "static inline void CmptLzDecGetProbsInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t idx;\n    uint32_t numProbs = CmptLzGetNumProbs(&(decCtx->prop));\n    CmptLzDecProb *decProbs = decCtx->probs;\n\n    for (idx = 0; idx < numProbs; idx++)\n    {\n        decProbs[idx] = CMPTLZ_PROB_LG >> 1;\n    }\n    decCtx->state = 0;\n}": "349", "static inline void CmptLzRangeCodeInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t rangeCode = (uint32_t)(decCtx->tempBuf[1]) << 24;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[2]) << 16;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[3]) << 8;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[4]);\n    decCtx->code = rangeCode;\n    decCtx->range = 0xFFFFFFFF;\n}": "350", "static inline int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                                      EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n\n    decCtx->remainLen = 0;\n\n    return CMPT_OK;\n}": "351", "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}": "352", "int CmptLzDecDecodeToBuf(CmptLzDecCtx *decCtx, CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, EnCmptLzFinMode finMode,\n                         EnCmptLzStatus *finStatus)\n{\n    int res = CMPT_OK;\n    size_t dictPos;\n    size_t dictPosLimit;\n    size_t srcCostSize;\n\n    size_t leftSrcSize = pDecIn->strInLen;\n    size_t leftDestSize = pDecOut->destOutLen;\n    const unsigned char *pSrcIn = pDecIn->pSrcIn;\n    unsigned char *pDestOut = pDecOut->pDestOut;\n    EnCmptLzFinMode tmpFinMode;\n\n    do\n    {\n        if (decCtx->dictPos == decCtx->dictBufSize)\n        {\n            decCtx->dictPos = 0;\n        }\n        dictPos = decCtx->dictPos;\n        if (leftDestSize > decCtx->dictBufSize - dictPos)\n        {\n            dictPosLimit = decCtx->dictBufSize;\n            tmpFinMode = CMPTLZ_FINISH_ANY;\n        }\n        else\n        {\n            dictPosLimit = dictPos + leftDestSize;\n            tmpFinMode = finMode;\n        }\n        srcCostSize = leftSrcSize;\n        res = CmptLzDecDecodeToDic(decCtx, dictPosLimit, pSrcIn, &srcCostSize, tmpFinMode, finStatus);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n        pSrcIn += srcCostSize;\n        leftSrcSize -= srcCostSize;\n        dictPosLimit = decCtx->dictPos - dictPos;\n        leftDestSize -= dictPosLimit;\n        if (dictPosLimit == 0)\n        {\n            break;\n        }\n        if (memcpy_s(pDestOut, (pDecOut->destOutLen - leftDestSize), decCtx->dict + dictPos, dictPosLimit) != EOK)\n        {\n            return CMPT_ERROR_MEM;\n        }\n        pDestOut += dictPosLimit;\n    } while (leftDestSize != 0);\n\n    pDecIn->strInCostLen = pDecIn->strInLen - leftSrcSize;\n    pDecOut->destOutFillLen = pDecOut->destOutLen - leftDestSize;\n\n    return res;\n}": "353", "int CmptlzDecompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzDecParam *param)\n{\n    if (src == NULL || dst == NULL || dstSize == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The input parameter NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"dstSize:0x%zx srcSize:0x%zx\", *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (param == NULL || param->memHook == NULL || param->protData == NULL || param->protSize != CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The compress param NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecIn decIn = {.pSrcIn = src, .strInLen = srcSize, .strInCostLen = 0};\n    CmptLzDecOut decOut = {.pDestOut = dst, .destOutLen = *dstSize, .destOutFillLen = 0};\n    EnCmptLzStatus enFinStat = CMPTLZ_STATUS_BUT;\n    int ret = CmptLzDecode(&decIn, &decOut, param->protData, CMPTLZ_FINISH_ANY, &enFinStat, param->memHook);\n\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}": "354", "static inline int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                         uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                         const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}": "355", "static inline int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                        const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}": "356", "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}": "357", "int CmptLzDecCarefulProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    int res = CMPT_OK;\n    uint32_t remainLen;\n    const unsigned char *bufLimitTmp;\n    const unsigned char *pSrcIn;\n\n    do\n    {\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx->buf;\n\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, &bufLimitTmp);\n        if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if ((res != CMPT_OK) || (decCtx->buf != bufLimitTmp))\n        {\n            return CMPT_ERROR_DATA;\n        }\n        if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n        {\n            break;\n        }\n    } while (decCtx->dictPos < dicPosLimit);\n\n    if ((res == CMPTLZ_DEC_INPUT_EOF) && (decCtx->buf < bufLimit))\n    {\n        remainLen = (uint32_t)(bufLimit - decCtx->buf);\n        decCtx->tempBufSize = remainLen;\n        for (uint32_t idx = 0; idx < remainLen; idx++)\n        {\n            decCtx->tempBuf[idx] = decCtx->buf[idx];\n        }\n    }\n\n    return CMPT_OK;\n}": "358", "int CmptLzDecSinglePacket(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t srcInLen,\n                          size_t *psrcCostLen)\n{\n    int res;\n    size_t lookAheadLen = 0;\n    uint32_t newTempBufSize = decCtx->tempBufSize;\n    unsigned char *oldTmpBuf = &(decCtx->tempBuf[decCtx->tempBufSize]);\n\n    while (newTempBufSize < CMPTLZ_REQUIRED_INPUT_MAX && lookAheadLen < srcInLen)\n    {\n        decCtx->tempBuf[newTempBufSize++] = pSrcIn[lookAheadLen++];\n    }\n\n    const unsigned char *bufLimit = decCtx->tempBuf + newTempBufSize;\n    res = CmptLzTryDecOnePacket(decCtx, &(decCtx->tempBuf[0]), &bufLimit);\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *psrcCostLen = lookAheadLen;\n        decCtx->tempBufSize = newTempBufSize;\n        return CMPTLZ_DEC_INPUT_EOF;\n    }\n\n    if (res == CMPT_ERROR_DATA)\n    {\n        return res;\n    }\n\n    decCtx->buf = &(decCtx->tempBuf[0]);\n\n    res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimit);\n    if ((res != CMPT_OK) || (bufLimit != decCtx->buf) || (bufLimit <= oldTmpBuf))\n    {\n        *psrcCostLen = 0;\n        return CMPT_ERROR_DATA;\n    }\n    *psrcCostLen = (size_t)(bufLimit - oldTmpBuf);\n    decCtx->tempBufSize = 0;\n    return res;\n}": "359", "static inline int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n\n    return CMPT_OK;\n}": "360", "void CmptLzDecInit(CmptLzDecCtx *decCtx)\n{\n    decCtx->dictPos = 0;\n    decCtx->tempBufSize = 0;\n    decCtx->processedPos = 0;\n    decCtx->checkDicSize = 0;\n    decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN + 2;\n}": "361", "static inline void *CmptLzDecMemAlloc(CmptLzMemHook *memHook, int32_t memHandle, size_t allocSize)\n{\n    return memHook->CmptLzAlloc(memHandle, allocSize);\n}": "362", "static inline void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}": "363", "static inline void CmptLzDecFreeProbs(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->probs != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_PROB_HANDLE, decCtx->probs);\n        decCtx->probs = NULL;\n    }\n}": "364", "static inline void CmptLzFreeDict(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->dict != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_DICT_HANDLE, decCtx->dict);\n        decCtx->dict = NULL;\n    }\n}": "365", "static inline int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n\n    return CMPT_OK;\n}": "366", "int CmptLzDecAllocate(CmptLzDecCtx *decCtx, const unsigned char *protData, unsigned protSize, CmptLzMemHook *memHook)\n{\n    int res;\n    uint32_t dictMask;\n    size_t dictBufSize;\n    CmptLzDecProt decProt;\n\n    if ((decCtx == NULL) || (protData == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    res = CmptLzPropsDecode(protData, protSize, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    uint32_t dictSize = decProt.dicSize;\n    if (dictSize >= ((uint32_t)1 << CMPTLZ_BIG_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE) - 1;\n    }\n    else if (dictSize >= ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_SMALL_DICT_LG_SIZE) - 1;\n    }\n    else\n    {\n        dictMask = CMPTLZ_DICT_MIN_LEN - 1;\n    }\n\n    dictBufSize = ((size_t)dictSize + dictMask) & ~dictMask;\n    if (dictBufSize < dictSize)\n    {\n        dictBufSize = dictSize;\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n    }\n    else\n    {\n        if (dictBufSize != decCtx->dictBufSize)\n        {\n            CmptLzFreeDict(decCtx, memHook);\n            decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n        }\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        CmptLzDecFreeProbs(decCtx, memHook);\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->dictBufSize = dictBufSize;\n    decCtx->prop = decProt;\n\n    return CMPT_OK;\n}": "367", "int CmptLzDecFree(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if ((decCtx == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecFreeProbs(decCtx, memHook);\n    CmptLzFreeDict(decCtx, memHook);\n\n    return CMPT_OK;\n}": "368", "void CmptLzDecConstruct(CmptLzDecCtx *decCtx)\n{\n    decCtx->dict = NULL;\n    decCtx->probs = NULL;\n}": "369", "int CmptLzDecode(CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, const unsigned char *protData, EnCmptLzFinMode finMode,\n                 EnCmptLzStatus *finStatus, CmptLzMemHook *memHook)\n{\n    int res;\n    size_t inSize = pDecIn->strInLen;\n    CmptLzDecProt decProt;\n    CmptLzDecCtx decCtx;\n    decCtx.numProbs = 0;\n\n    if (inSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecConstruct(&decCtx);\n    res = CmptLzPropsDecode(protData, CMPTLZ_PROPS_SIZE, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(&decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    decCtx.prop = decProt;\n    decCtx.dict = pDecOut->pDestOut;\n    decCtx.dictBufSize = pDecOut->destOutLen;\n    CmptLzDecInit(&decCtx);\n\n    *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n    res = CmptLzDecDecodeToDic(&decCtx, pDecOut->destOutLen, pDecIn->pSrcIn, &inSize, finMode, finStatus);\n    pDecIn->strInCostLen = inSize;\n    pDecOut->destOutFillLen = decCtx.dictPos;\n    CmptLzDecFreeProbs(&decCtx, memHook);\n\n    return res;\n}": "370", "static inline void CmptLzDistDecHelper(CmptLzDecCtx *decCtx, uint32_t distDec, const unsigned char *bufToDec,\n                                       uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound, uint32_t range,\n                                       uint32_t rangeCode, uint32_t rangeBound)\n{\n    decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n    decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n    decCtx->reps[1] = decCtx->reps[0];\n    decCtx->reps[0] = (distDec + 1);\n\n    decCtx->buf = bufToDec;\n    decCtx->state = (decCtx->state < CMPTLZ_LIT_STATES) ? CMPTLZ_LIT_STATES : CMPTLZ_LIT_STATES + CMPTLZ_REP3;\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n}": "371", "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}": "372", "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    return decLen;\n}": "373", "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n\n    return CMPT_OK;\n}": "374", "static inline void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}": "375", "static inline uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                                    size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}": "376", "static inline uint32_t CmptLzMatchDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode,\n                                      uint32_t *pRangeBound, size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t matchLen;\n    size_t matchDist;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n    if (matchDist > decCtx->dictBufSize)\n    {\n        if (matchDist == (size_t)0xFFFFFFFF)\n        {\n            decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN;\n            decCtx->state -= CMPTLZ_MKSTATE_NUM;\n            return CMPT_OK;\n        }\n        else\n        {\n            return CMPT_ERROR_DATA;\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, matchLen + 2, dicPosLimit);\n}": "377", "static inline uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n\n    return CMPT_OK;\n}": "378", "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n\n    return (int)decRes;\n}": "379", "static inline void CmptlzDpInitShortRep(CmptLzEncCtx *encCtx, uint32_t repMatchPrice, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, encCtx->state, posState);\n    if (shortRepPrice < encCtx->opts[1].price)\n    {\n        encCtx->opts[1].price = shortRepPrice;\n        encCtx->opts[1].backPrev = 0;\n    }\n}": "380", "static inline void CmptlzDpInitLongRep(CmptLzEncCtx *encCtx, uint32_t *repLens, const uint32_t repMatchPrice,\n                                       const uint32_t posState)\n{\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        uint32_t repLen = repLens[i];\n        if (repLen < CMPTLZ_MATCH_LEN_MIN)\n        {\n            continue;\n        }\n        const uint32_t price = repMatchPrice + CmptPriceLongRep(encCtx, i, encCtx->state, posState);\n        do\n        {\n            const uint32_t curAndLenPrice = price + CmptPriceLen(&encCtx->repLenEncoder, repLen, posState);\n            if (curAndLenPrice < encCtx->opts[repLen].price)\n            {\n                encCtx->opts[repLen].price = curAndLenPrice;\n                encCtx->opts[repLen].posPrev = 0;\n                encCtx->opts[repLen].backPrev = i;\n            }\n            repLen--;\n        } while (repLen >= CMPTLZ_MATCH_LEN_MIN);\n    }\n}": "381", "static inline void CmptlzDpInitMatch(CmptLzEncCtx *encCtx, uint32_t matchesCount, uint32_t normalMatchPrice,\n                                     uint32_t posState, uint32_t len)\n{\n    uint32_t i = 0;\n    while (len > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    for (;; len++)\n    {\n        const uint32_t dist = encCtx->matches[i].dist;\n        const uint32_t curAndLenPrice = normalMatchPrice + CmptPriceDistWithLen(encCtx, dist, len, posState);\n        if (curAndLenPrice < encCtx->opts[len].price)\n        {\n            encCtx->opts[len].price = curAndLenPrice;\n            encCtx->opts[len].posPrev = 0;\n            encCtx->opts[len].backPrev = dist + CMPTLZ_NUM_REPS;\n        }\n        if (len == encCtx->matches[i].len)\n        {\n            if (++i == matchesCount)\n            {\n                break;\n            }\n        }\n    }\n}": "382", "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[0].state = encCtx->state;\n\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}": "383", "static inline void CmptlzDpPre(CmptLzEncCtx *encCtx, uint32_t *mainReps, const uint32_t cur)\n{\n    uint32_t posPointer = encCtx->opts[cur].posPrev;\n    CmptlzState state = encCtx->opts[posPointer].state;\n\n    if (posPointer == cur - 1)\n    {\n        if (encCtx->opts[cur].backPrev == 0)\n        {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_LIT(state);\n        }\n    }\n    else\n    {\n        uint32_t backPointer;\n        backPointer = encCtx->opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_MATCH(state);\n        }\n\n        uint32_t i;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            mainReps[0] = encCtx->opts[posPointer].backs[backPointer];\n\n            for (i = 1; i <= backPointer; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n            for (; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i];\n            }\n        }\n        else\n        {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS;\n            for (i = 1; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n        }\n    }\n\n    encCtx->opts[cur].state = state;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[cur].backs[i] = mainReps[i];\n    }\n}": "384", "static inline void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                        const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                        const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}": "385", "static inline void CmptlzDpTryCurAndShort(CmptLzEncCtx *encCtx, const uint32_t repMatchPrice, const uint32_t cur,\n                                          CmptlzState curState, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, curState, posState);\n    if (shortRepPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = shortRepPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = 0;\n    }\n}": "386", "static inline void CmptlzDpTryCurAndLong(CmptLzEncCtx *encCtx, const uint32_t prefixPrice, const uint32_t cur,\n                                         uint32_t mainRepIndex, uint32_t lenEqual, const uint32_t posState)\n{\n    do\n    {\n        const uint32_t curLongRepPrice = prefixPrice + CmptPriceLen(&encCtx->repLenEncoder, lenEqual, posState);\n\n        if (curLongRepPrice < encCtx->opts[cur + lenEqual].price)\n        {\n            encCtx->opts[cur + lenEqual].price = curLongRepPrice;\n            encCtx->opts[cur + lenEqual].posPrev = cur;\n            encCtx->opts[cur + lenEqual].backPrev = mainRepIndex;\n        }\n    } while (--lenEqual >= CMPTLZ_MATCH_LEN_MIN);\n}": "387", "static inline void CmptlzDpTryCurAndMatch(CmptLzEncCtx *encCtx, uint32_t startLen, uint32_t matchCount,\n                                          const uint32_t normalmatch_prefixPrice, const uint32_t cur,\n                                          const uint32_t posState)\n{\n    uint32_t i = 0;\n    while (startLen > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    uint32_t lenTest;\n    for (lenTest = startLen;; lenTest++)\n    {\n        const uint32_t curBack = encCtx->matches[i].dist;\n        uint32_t cur_normalmatchPrice =\n            normalmatch_prefixPrice + CmptPriceDistWithLen(encCtx, curBack, lenTest, posState);\n        if (cur_normalmatchPrice < encCtx->opts[cur + lenTest].price)\n        {\n            encCtx->opts[cur + lenTest].price = cur_normalmatchPrice;\n            encCtx->opts[cur + lenTest].posPrev = cur;\n            encCtx->opts[cur + lenTest].backPrev = curBack + CMPTLZ_NUM_REPS;\n        }\n        if (lenTest == encCtx->matches[i].len)\n        {\n            if (++i == matchCount)\n            {\n                break;\n            }\n        }\n    }\n}": "388", "static inline uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                       uint32_t position, const uint32_t cur)\n{\n\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n\n        const uint32_t lenEqualMem = lenEqual;\n\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}": "389", "static inline void CmptlzDpReverse(CmptLzEncCtx *encCtx, uint32_t cur)\n{\n    encCtx->optEndIndex = cur;\n    uint32_t posTmp = encCtx->opts[cur].posPrev;\n    uint32_t backTmp = encCtx->opts[cur].backPrev;\n    uint32_t posPrev, backCurPacket;\n    do\n    {\n        posPrev = posTmp;\n        backCurPacket = backTmp;\n\n        backTmp = encCtx->opts[posPrev].backPrev;\n        posTmp = encCtx->opts[posPrev].posPrev;\n\n        encCtx->opts[posPrev].backPrev = backCurPacket;\n        encCtx->opts[posPrev].posPrev = cur;\n        cur = posPrev;\n    } while (cur != 0);\n\n    encCtx->lenRes = encCtx->opts[0].posPrev;\n    encCtx->backRes = encCtx->opts[0].backPrev;\n    encCtx->optsCurIndex = encCtx->opts[0].posPrev;\n}": "390", "void CmptlzDp(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    uint32_t curIndex = encCtx->optsCurIndex;\n    uint32_t endIndex = encCtx->optEndIndex;\n\n    if (endIndex != curIndex)\n    {\n        encCtx->lenRes = encCtx->opts[curIndex].posPrev - curIndex;\n        encCtx->backRes = encCtx->opts[curIndex].backPrev;\n        encCtx->optsCurIndex = encCtx->opts[curIndex].posPrev;\n        return;\n    }\n    uint32_t lenEnd = CmptlzDpInit(encCtx, mf, position);\n\n    if (lenEnd == CMPTLZ_UINT32_MAX)\n    {\n        return;\n    }\n    uint32_t mainReps[CMPTLZ_NUM_REPS];\n    memcpy_s(mainReps, sizeof(mainReps), encCtx->reps, sizeof(encCtx->reps));\n\n    uint32_t cur;\n    for (cur = 1; cur < lenEnd; cur++)\n    {\n        encCtx->longestMatchLen = CmptlzMatchFinder(mf, &encCtx->matchesCount, encCtx->matches);\n        if (encCtx->longestMatchLen >= mf->niceLen)\n        {\n            break;\n        }\n        CmptlzDpPre(encCtx, mainReps, cur);\n        lenEnd = CmptlzDpProcess(encCtx, mf, mainReps, lenEnd, position + cur, cur);\n    }\n    CmptlzDpReverse(encCtx, cur);\n    return;\n}": "391", "static inline uint32_t CmptPriceOneBitDirect(uint32_t bit)\n    {\n        return (bit << CMPT_PRICE_BITS_MOVING_NUM);\n    }": "392", "static inline uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                      CMPT_PRICE_BITS_MOVING_NUM];\n    }": "393", "static inline uint32_t CmptPriceBit0(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM];\n    }": "394", "static inline uint32_t CmptPriceBit1(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM - 1)) >> CMPT_PRICE_BITS_MOVING_NUM];\n    }": "395", "static inline uint32_t CmptPriceSymbol(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                           uint32_t symbol)\n    {\n        uint32_t price = 0;\n        symbol += (1U << symbolBitsNum);\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[symbol], bit);\n        } while (symbol != 1);\n        return price;\n    }": "396", "static inline uint32_t CmptPriceSymbolReverse(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                                  uint32_t symbol)\n    {\n        uint32_t price = 0;\n        uint32_t i = 1;\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[i], bit);\n            i = (i << 1) + bit;\n        } while (--symbolBitsNum);\n\n        return price;\n    }": "397", "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}": "398", "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx);\n\n    res = CmptEncodeAll(encCtx);\n\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n\n    *destLen -= encCtx->rcCtx->outBufLeft;\n\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}": "399", "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}": "400", "int CmptlzCompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzCompParam *param)\n{\n    if ((src == NULL) && (srcSize != 0))\n    {\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    const int endMarker = 0;\n\n    CmptlzEncParam props;\n    props.level = param->level;\n    props.dictSize = param->dictSize;\n    props.litCtx = param->litCtx;\n    props.litPos = param->litPos;\n    props.posBits = param->posBits;\n    props.fastBytes = param->fastBytes;\n    props.numThreads = param->numThreads;\n    CmptLzMemHook *alloc = param->memHook;\n    return CmptlzEncode((uint8_t *)dst, dstSize, (const uint8_t *)src, srcSize, &props, param->protData,\n                        &param->protSize, endMarker, alloc);\n}": "401", "static inline int CmptRcLitProcess(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, bit0Prob, newBound, curBit;\n\n        for (sym |= 0x100; sym < 0x10000; sym <<= 1)\n        {\n            CmptlzProb *litProbTableIndex = prob + (sym >> 8);\n            curBit = (sym >> 7) & 1;\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }": "402", "static inline int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n        for (sym |= 0x100; sym < 0x10000;)\n        {\n            matchByte <<= 1;\n            CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n            curBit = (sym >> 7) & 1;\n            sym <<= 1;\n            offs &= ~(matchByte ^ sym);\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }": "403", "int CmptHeadWrite(CmptLzEncCtx *encCtx, uint8_t *protData, size_t *propsSize)\n{\n    if (protData == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"protData is NULL\");\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"propsSize need 5 bytes, get %zu\", *propsSize);\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    CmptlzWriteLE32Bit(protData + 1, encCtx->dicSize);\n    protData[0] = (encCtx->posBits * CMPTLZ_POS_STATE_MAX + encCtx->litPos) * CMPTLZ_LIT_CTX_MAX + encCtx->litCtx;\n    *propsSize = CMPTLZ_PROPS_SIZE;\n    return 0;\n}": "404", "void CmptPriceGenRootTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t *rootTable = encCtx->priceRootTable;\n\n    const unsigned expandCycleNum = 4;\n    const unsigned bitsTotalModeNum = 11;\n    const unsigned valueForNormal = 15;\n    const unsigned wTopBoarder = 1 << 16;\n\n    for (unsigned i = 0; i < ((uint32_t)1 << bitsTotalModeNum >> CMPT_PRICE_BITS_MOVING_NUM); i++)\n    {\n        unsigned w = (i << CMPT_PRICE_BITS_MOVING_NUM) + (1 << (CMPT_PRICE_BITS_MOVING_NUM - 1));\n        unsigned dummyNormalizeCnt = 0;\n        for (unsigned j = 0; j < expandCycleNum; j++)\n        {\n            w = w * w;\n            dummyNormalizeCnt <<= 1;\n            while (w >= wTopBoarder)\n            {\n                w >>= 1;\n                dummyNormalizeCnt++;\n            }\n        }\n        rootTable[i] = (uint32_t)((bitsTotalModeNum << expandCycleNum) - valueForNormal - dummyNormalizeCnt);\n    }\n}": "405", "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n\n    encCtx->matchPriceCount = 0;\n}": "406", "void CmptPriceGenAlignTable(CmptLzEncCtx *encCtx)\n{\n    for (uint32_t i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->priceAlignTable[i] = CmptPriceSymbolReverse(encCtx, encCtx->probAlign, CMPTLZ_ALIGN_BITS, i);\n    }\n}": "407", "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}": "408", "static void CmptPriceSet(CmptLzEncCtx *encCtx, const CmptlzProb *probs, uint32_t startPrice, uint32_t *prices)\n{\n    uint32_t i;\n    for (i = 0; i < 8; i += 2)\n    {\n        uint32_t price = startPrice;\n        uint32_t prob;\n        price += CmptPriceOneBit(encCtx, probs[1], (i >> 2));\n        price += CmptPriceOneBit(encCtx, probs[2 + (i >> 2)], (i >> 1) & 1);\n        prob = probs[4 + (i >> 1)];\n        prices[i] = price + CmptPriceBit0(encCtx, prob);\n        prices[i + 1] = price + CmptPriceBit1(encCtx, prob);\n    }\n}": "409", "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n\n    uint32_t b;\n\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}": "410", "uint32_t CmptPriceLen(CmptLenEncoder *lenEncoder, uint32_t len, uint32_t posState)\n{\n\n    return lenEncoder->prices[posState][len - CMPTLZ_MATCH_LEN_MIN];\n}": "411", "uint32_t CmptPriceShortRep(CmptLzEncCtx *encCtx, CmptlzState state, uint32_t posState)\n{\n    return CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRep0Long[state][posState]);\n}": "412", "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}": "413", "uint32_t CmptPriceDistWithLen(CmptLzEncCtx *encCtx, uint32_t dist, uint32_t len, uint32_t posState)\n{\n    const uint32_t distState = CMPT_GET_DIST_STATE(len);\n    uint32_t price;\n    if (dist < 128)\n    {\n        price = encCtx->priceDistTable[distState][dist];\n    }\n    else\n    {\n\n        uint32_t distSlot = PosSloter(dist);\n        price = encCtx->priceDistSlotTable[distState][distSlot] +\n                encCtx->priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS) - 1)];\n    }\n\n    price += CmptPriceLen(&encCtx->matchLenEncoder, len, posState);\n\n    return price;\n}": "414", "static void CmptlzMfGenHashTable(CmptMfCtx *mf)\n{\n    uint32_t *hashRootTable = mf->hashRootTable;\n    const uint32_t poly32 = 0xEDB88320;\n    uint32_t i, j;\n    for (i = 0; i < CMPT_MF_HASH_TABLE_SIZE; i++)\n    {\n        uint32_t value = i;\n        for (j = 0; j < 8; j++)\n        {\n            if (value & 1)\n            {\n                value = (value >> 1) ^ poly32;\n            }\n            else\n            {\n                value >>= 1;\n            }\n        }\n        hashRootTable[i] = value;\n    }\n    return;\n}": "415", "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}": "416", "static void CmptMfMovePos(CmptMfCtx *mf)\n{\n    const uint32_t subvalue = (CMPTLZ_UINT32_MAX - mf->cycleSize);\n    uint32_t i;\n    for (i = 0; i < mf->hashCount; i++)\n    {\n        if (mf->hash[i] <= subvalue)\n        {\n            mf->hash[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->hash[i] -= subvalue;\n        }\n    }\n    for (i = 0; i < mf->sonsCount; ++i)\n    {\n        if (mf->son[i] <= subvalue)\n        {\n            mf->son[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->son[i] -= subvalue;\n        }\n    }\n    mf->offset -= subvalue;\n}": "417", "static CmptlzMatchPair *CmptBtFind(CmptMfCtx *mf, uint32_t curMatch, CmptlzMatchPair *matches, uint32_t longestLen)\n{\n\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return matches;\n        }\n        uint32_t *const pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *const pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, niceLen);\n            if (longestLen < len)\n            {\n                longestLen = len;\n                matches->len = len;\n                matches->dist = delta - 1;\n                ++matches;\n                if (len == niceLen)\n                {\n                    *ptr1 = pair[0];\n                    *ptr0 = pair[1];\n                    return matches;\n                }\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}": "418", "static void CmptBtSkip(CmptMfCtx *mf, const uint32_t lenLimit, const uint32_t pos, const uint8_t *const cur,\n                       uint32_t curMatch)\n{\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return;\n        }\n        uint32_t *pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, lenLimit);\n            if (len == lenLimit)\n            {\n                *ptr1 = pair[0];\n                *ptr0 = pair[1];\n                return;\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}": "419", "static uint32_t CmptlzBt4Finder(CmptMfCtx *mf, CmptlzMatchPair *matches)\n{\n    const uint32_t niceLen = mf->niceLen;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t temp, hash2Value, hash3Value, hashValue;\n    uint32_t longestLen = 1, matchesCount = 0;\n    CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    uint32_t delta2 = pos - mf->hash[hash2Value];\n    uint32_t delta3 = pos - mf->hash[CMPTLZ_FIX_3_HASH + hash3Value];\n    uint32_t curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n    CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0)\n    {\n        longestLen = CmptMemCmpLenSafe(cur, cur - delta2, longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen)\n        {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS(mf);\n            return matchesCount;\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES)\n    {\n        longestLen = CMPT_MF_MATCH_3_BYTES;\n    }\n    matchesCount = (uint32_t)(CmptBtFind(mf, curMatch, matches + matchesCount, longestLen) - matches);\n\n    CMPT_MF_MOVE_POS(mf);\n    return matchesCount;\n}": "420", "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}": "421", "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}": "422", "static void CmptlzEndMarker(void)\n{\n\n    return;\n}": "423", "static int CmptlzFlush(CmptLzEncCtx *encCtx)\n{\n    encCtx->encNeedFinish = true;\n    if (encCtx->endMarker != 0)\n    {\n        CmptlzEndMarker();\n    }\n\n    CmptRcFlushData(encCtx->rcCtx);\n    return CmptRcFlush64Kb(encCtx->rcCtx);\n}": "424", "static inline void CmptPriceCheck(CmptLzEncCtx *encCtx)\n{\n\n    if (encCtx->matchPriceCount >= CMPT_PRICE_COUNT)\n    {\n        CmptPriceGenDistTable(encCtx);\n        CmptPriceGenAlignTable(encCtx);\n        CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    }\n    if (encCtx->repLenPriceCount <= 0)\n    {\n        encCtx->repLenPriceCount = CMPT_PRICE_COUNT;\n        CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n    }\n}": "425", "static inline int CmptEncShortOrRep0(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    if (lenRes == 1)\n    {\n        shiftRes = CmptlzEncShortRep(encCtx, nowpos32);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        shiftRes = CmptlzEncLongRep(encCtx, 0, nowpos32, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}": "426", "CMPTLZ_static int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n#ifdef CMPTLZ_PRINTF_ENC_PROCESS\n        printf(\" now in CmptEncodeOneBlock process, backRes is %u, lenRes is %u\\n\", backRes, lenRes);\n        printf(\" nowpos32 is %u\\n\", nowpos32);\n#endif\n\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n\n        if (mf->readAhead == 0)\n        {\n\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}": "427", "int CmptEncodeAll(CmptLzEncCtx *encCtx)\n{\n    CmptRcCtx *rc = encCtx->rcCtx;\n    CmptMfCtx *mf = encCtx->mfCtx;\n\n    if (mf->srcLen == 0)\n    {\n        return CmptlzFlush(encCtx);\n    }\n\n    if (encCtx->nowpos64 == 0)\n    {\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][0];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        int shiftRes = CMPT_OK;\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        uint8_t curByte = *(mf->srcStart);\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        mf->mfStart++;\n        encCtx->nowpos64++;\n        mf->readPos++;\n        if (mf->srcLen == 1)\n        {\n            return CmptlzFlush(encCtx);\n        }\n    }\n\n    int res;\n    while (true)\n    {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0 || encCtx->encNeedFinish)\n        {\n            break;\n        }\n    }\n    return res;\n}": "428", "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n\n    encCtx->rcCtx = rc;\n\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}": "429", "int CmptRcFlush64Kb(CmptRcCtx *rcCtx)\n{\n    size_t flushOutLen = rcCtx->buf - rcCtx->bufBase;\n    int res = memcpy_s(rcCtx->outBuf, rcCtx->outBufLeft, rcCtx->bufBase, flushOutLen);\n    if (res != 0)\n    {\n        return CMPT_ENC_ERROR_WRITE;\n    }\n    rcCtx->outBuf += flushOutLen;\n    rcCtx->outBufLeft -= flushOutLen;\n    rcCtx->buf = rcCtx->bufBase;\n    return CMPT_OK;\n}": "430", "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}": "431", "int CmptRcFlushData(CmptRcCtx *rcCtx)\n{\n    int i;\n    int res;\n    for (i = 0; i < 5; i++)\n    {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n    }\n    return res;\n}": "432", "void CmptRcCtxInit(CmptRcCtx *rcCtx)\n{\n    rcCtx->range = 0xFFFFFFFF;\n    rcCtx->cache = 0;\n    rcCtx->low = 0;\n    rcCtx->cacheSize = 0;\n    rcCtx->buf = rcCtx->bufBase;\n}": "433", "int CmptRcLenProcess(CmptLenEncoder *lenEncoder, CmptRcCtx *rcCtx, uint32_t len, uint64_t posState)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t newBound, bit0Prob;\n    len -= CMPTLZ_MATCH_LEN_MIN;\n\n    CmptlzProb *probs = lenEncoder->low;\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND)\n    {\n        CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs += CMPT_LEN_BOUND;\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND * CMPT_DOUBLE)\n        {\n            CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            rcCtx->range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder->high, len - CMPT_LEN_BOUND * CMPT_DOUBLE);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            return CMPT_OK;\n        }\n        len -= CMPT_LEN_BOUND;\n    }\n\n    uint32_t m, bit;\n    CMPT_RC_BIT_0_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs += (posState << (1 + 3));\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rcCtx->range = range;\n    return CMPT_OK;\n}": "434", "inline int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}": "435", "static inline int CmptRcReverseProcess(CmptRcCtx *rcCtx, CmptlzProb *probs, uint32_t numBits, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    uint32_t m = 1;\n    do\n    {\n        bit = sym & 1;\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        m = (m << 1) | bit;\n    } while (--numBits);\n\n    rcCtx->range = range;\n    return CMPT_OK;\n}": "436", "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}": "437", "static inline uint32_t CmptMemCmpByOneByte(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        uint32_t lenIn = len;\n        while ((lenIn < limit) && (buf1[lenIn] == buf2[lenIn]))\n        {\n            lenIn++;\n        }\n        return lenIn;\n    }": "438", "static inline uint32_t CmptMemCmpLenSafe(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n    }": "439", "static inline uint32_t CmptMemCmpLen(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n    }": "440", "static inline uint32_t CmptMfAvail(const CmptMfCtx *mf)\n    {\n        return mf->srcLen - mf->readPos;\n    }": "441", "static inline const uint8_t *CmptMfGetPtr(const CmptMfCtx *mf)\n    {\n        return mf->srcStart + mf->readPos;\n    }": "442", "static inline uint32_t PosSlotHelper(uint32_t n)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return 31 - (uint32_t)__builtin_clz(n);\n#else\n    uint32_t i = 31;\n    if ((n & 0xFFFF0000) == 0)\n    {\n        n <<= 16;\n        i = 15;\n    }\n    if ((n & 0xFF000000) == 0)\n    {\n        n <<= 8;\n        i -= 8;\n    }\n    if ((n & 0xF0000000) == 0)\n    {\n        n <<= 4;\n        i -= 4;\n    }\n    if ((n & 0xC0000000) == 0)\n    {\n        n <<= 2;\n        i -= 2;\n    }\n    if ((n & 0x80000000) == 0)\n        --i;\n    return i;\n#endif\n    }": "443", "static inline uint32_t PosSloter(uint32_t dist)\n    {\n        if (dist <= 4)\n        {\n            return dist;\n        }\n        uint32_t helper = PosSlotHelper(dist);\n        return (helper + helper + ((dist >> (helper - 1)) & 1));\n    }": "444", "void CmptlzParamNormalize(CmptlzEncParam *props)\n{\n\n    int level = props->level;\n    if (level < 0 || level > 9)\n    {\n        level = 5;\n    }\n    props->level = level;\n\n    if (props->dictSize < CMPTLZ_MIN_DICTSIZE || props->dictSize > CMPTLZ_MAX_DICTSIZE)\n    {\n        CMPTLZ_SET_DICTSIZE_BY_LEVEL(level, props->dictSize);\n    }\n    if (props->fastBytes < 5 || props->fastBytes > CMPT_MF_LONGEST_MATCH)\n    {\n        CMPTLZ_SET_FB_BY_LEVEL(level, props->fastBytes);\n    }\n\n    if (props->litCtx < 0 || props->litCtx > CMPTLZ_LC_MAX)\n    {\n        props->litCtx = 3;\n    }\n    if (props->litPos < 0 || props->litPos > CMPTLZ_LP_MAX)\n    {\n        props->litPos = 0;\n    }\n    if (props->posBits < 0 || props->posBits > CMPTLZ_PB_MAX)\n    {\n        props->posBits = 2;\n    }\n\n    props->numThreads = 1;\n}": "445", "void CmptlzSetParam(CmptLzEncCtx *encCtx, const CmptlzEncParam *props)\n{\n    CmptlzEncParam param = *props;\n\n    CmptlzParamNormalize(&param);\n\n    encCtx->dicSize = param.dictSize;\n    encCtx->numFastBytes = param.fastBytes;\n    encCtx->litCtx = param.litCtx;\n    encCtx->litPos = param.litPos;\n    encCtx->posBits = param.posBits;\n    uint32_t i;\n    for (i = 7; i < 32; i++)\n    {\n        if (encCtx->dicSize <= (uint32_t)(1 << i))\n        {\n            break;\n        }\n    }\n    encCtx->distTableSize = i * 2;\n}": "446", "void CmptlzPriceInit(CmptLzEncCtx *encCtx)\n{\n    CmptPriceGenRootTable(encCtx);\n    CmptPriceGenDistTable(encCtx);\n    CmptPriceGenAlignTable(encCtx);\n}": "447", "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n\n    CmptlzPriceInit(encCtx);\n\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}": "448", "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}": "449", "static inline int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        CmptRcCtx *rc = encCtx->rcCtx;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n        probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n        CmptlzState state = encCtx->state;\n        CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n        if (state < 7)\n        {\n            shiftRes = CmptRcLitProcess(rc, probs, curByte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        else\n        {\n            const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n            shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }": "450", "static inline int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        return CMPT_OK;\n    }": "451", "static inline int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        encCtx->rcCtx->range = range;\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n\n        shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        backRes -= CMPTLZ_NUM_REPS;\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = backRes;\n\n        encCtx->matchPriceCount++;\n\n        uint32_t posSlot = PosSloter(backRes);\n        shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        if (backRes >= 4)\n        {\n            shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }": "452", "static inline int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n\n        uint32_t range, bit0Prob, newBound;\n        uint32_t realDist;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n\n        switch (repIndex)\n        {\n        case 0:\n            CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRep0Long[encCtx->state][posState];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        case 1:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 2:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 3:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx->reps[3];\n            encCtx->reps[3] = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        default:\n            break;\n        }\n        CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        --encCtx->repLenPriceCount;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        return CMPT_OK;\n    }": "453", "static void VOS_MD5CalcDigestOfBuff(MD5_CTX *context)\n    {\n        uint32_t i;\n        uint32_t tmpValue;\n        uint32_t textFragment[16];\n        uint32_t tmpState[4];\n        uint8_t *tmpText = context->aucBuffer;\n\n        tmpState[0] = context->aulState[0];\n        tmpState[1] = context->aulState[1];\n        tmpState[2] = context->aulState[2];\n        tmpState[3] = context->aulState[3];\n\n        for (i = 0; i < 16; i += 4)\n        {\n            textFragment[i] = (uint32_t)(tmpText[0]) + ((uint32_t)(tmpText[1]) << 8) + ((uint32_t)(tmpText[2]) << 16) +\n                              ((uint32_t)(tmpText[3]) << 24);\n\n            textFragment[i + 1] = (uint32_t)(tmpText[4]) + ((uint32_t)(tmpText[5]) << 8) +\n                                  ((uint32_t)(tmpText[6]) << 16) + ((uint32_t)(tmpText[7]) << 24);\n\n            textFragment[i + 2] = (uint32_t)(tmpText[8]) + ((uint32_t)(tmpText[9]) << 8) +\n                                  ((uint32_t)(tmpText[10]) << 16) + ((uint32_t)(tmpText[11]) << 24);\n\n            textFragment[i + 3] = (uint32_t)(tmpText[12]) + ((uint32_t)(tmpText[13]) << 8) +\n                                  ((uint32_t)(tmpText[14]) << 16) + ((uint32_t)(tmpText[15]) << 24);\n            tmpText += 16;\n        }\n\n        MD5_F_PROC(tmpValue, tmpState, textFragment);\n        MD5_G_PROC(tmpValue, tmpState, textFragment);\n        MD5_H_PROC(tmpValue, tmpState, textFragment);\n        MD5_I_PROC(tmpValue, tmpState, textFragment);\n\n        context->aulState[0] += tmpState[0];\n        context->aulState[1] += tmpState[1];\n        context->aulState[2] += tmpState[2];\n        context->aulState[3] += tmpState[3];\n    }": "454", "static bool VOS_MD5PadBuff(MD5_CTX *context)\n    {\n\n        bool needAnotherBuff = (context->uiPos >= MD5_TEXT_IN_BUFFER_MAX);\n\n        context->aucBuffer[context->uiPos] = 0x80;\n        context->uiPos++;\n        if (needAnotherBuff)\n        {\n\n            while (context->uiPos < MD5_BUFFER_SIZE)\n            {\n                context->aucBuffer[context->uiPos] = 0;\n                context->uiPos++;\n            }\n        }\n        else\n        {\n\n            while (context->uiPos < MD5_TEXT_IN_BUFFER_MAX)\n            {\n                context->aucBuffer[context->uiPos] = 0;\n                context->uiPos++;\n            }\n\n            MD5_RECORD_MESSAGE_LEN(context);\n        }\n\n        return needAnotherBuff;\n    }": "455", "void VOS_MD5Init(MD5_CTX *context)\n    {\n        if (context == NULL)\n        {\n            return;\n        }\n\n        (void)memset_s(context, sizeof(MD5_CTX), 0, sizeof(MD5_CTX));\n\n        context->aulState[0] = 0x67452301;\n        context->aulState[1] = 0xefcdab89;\n        context->aulState[2] = 0x98badcfe;\n        context->aulState[3] = 0x10325476;\n    }": "456", "void VOS_MD5Update(MD5_CTX *context, uint8_t *input, uint32_t inputLen)\n    {\n        uint64_t totalInputBits;\n        uint32_t inputIndex = 0;\n        uint64_t inputBit;\n        uint32_t tmpPos;\n        uint8_t *contextBuffer = NULL;\n\n        if ((context == NULL) || ((input == NULL) && (inputLen != 0)))\n        {\n            return;\n        }\n\n        inputBit = (uint64_t)inputLen << 3;\n\n        totalInputBits = ((uint64_t)context->aulCount[1] << 32) + context->aulCount[0];\n        if ((MD5_INPUT_LEN_MAX - totalInputBits) < inputBit)\n        {\n            return;\n        }\n        totalInputBits += inputBit;\n        context->aulCount[0] = (uint32_t)totalInputBits;\n        context->aulCount[1] = (uint32_t)(totalInputBits >> 32);\n\n        tmpPos = context->uiPos;\n        contextBuffer = context->aucBuffer;\n        while (inputIndex < inputLen)\n        {\n\n            if (tmpPos < MD5_BUFFER_SIZE)\n            {\n                contextBuffer[tmpPos] = input[inputIndex];\n                ++inputIndex;\n                ++tmpPos;\n                continue;\n            }\n\n            VOS_MD5CalcDigestOfBuff(context);\n            tmpPos = 0;\n        }\n\n        if (tmpPos == MD5_BUFFER_SIZE)\n        {\n            VOS_MD5CalcDigestOfBuff(context);\n            tmpPos = 0;\n        }\n        context->uiPos = tmpPos;\n        return;\n    }": "457", "void VOS_MD5FinalEx(uint8_t digest[], uint32_t bufLen, MD5_CTX *context)\n    {\n        bool needAnotherBuff = 0;\n\n        if ((digest == NULL) || (context == NULL) || (bufLen < MD5_DIGEST_LEN))\n        {\n            return;\n        }\n\n        needAnotherBuff = VOS_MD5PadBuff(context);\n        VOS_MD5CalcDigestOfBuff(context);\n\n        if (needAnotherBuff)\n        {\n            context->uiPos = 0;\n            while (context->uiPos < MD5_TEXT_IN_BUFFER_MAX)\n            {\n                context->aucBuffer[context->uiPos] = 0;\n                context->uiPos++;\n            }\n            MD5_RECORD_MESSAGE_LEN(context);\n            VOS_MD5CalcDigestOfBuff(context);\n        }\n\n        MD5_COMPOSE_DIGEST(digest, context->aulState);\n\n        (void)memset_s(context, sizeof(MD5_CTX), 0, sizeof(MD5_CTX));\n    }": "458", "void VOS_MD5Final(uint8_t digest[16], MD5_CTX *context)\n    {\n        VOS_MD5FinalEx(digest, MD5_DIGEST_LEN, context);\n    }": "459", "void VOS_MD5CalcEx(uint8_t *output, uint32_t outputLen, const uint8_t *input, uint32_t inputLen)\n    {\n        MD5_CTX context;\n\n        if (outputLen < MD5_DIGEST_LEN)\n        {\n            return;\n        }\n\n        VOS_MD5Init(&context);\n        VOS_MD5Update(&context, (uint8_t *)(uintptr_t)input, inputLen);\n        VOS_MD5FinalEx(output, outputLen, &context);\n    }": "460", "void VOS_MD5Calc(uint8_t *output, uint8_t *input, uint32_t inputLen)\n    {\n        VOS_MD5CalcEx(output, MD5_DIGEST_LEN, input, inputLen);\n    }": "461", "static inline int RapidlzZeroBytesDecode(const char *const src, int srcSize)\n    {\n        if ((*src == 0) && (srcSize == 1))\n        {\n            return RAPIDLZ_DEC_NOT_OK;\n        }\n        return RAPIDLZ_ERROR_PARAM_UNSUPPORTED;\n    }": "462", "static inline void RapidlzDictSizeNorm(RapidlzStreamCtx *strmCtx, char *src, char *dictEnd)\n    {\n        if (strmCtx->dictSize < RAPIDLZ_STREAM_HASH_BYTES)\n        {\n            strmCtx->dictSize = 0;\n            strmCtx->dict = (uint8_t *)src;\n            dictEnd = src;\n        }\n        if (strmCtx->dictSize > RAPIDLZ_MAX_DICT_SIZE)\n        {\n            strmCtx->dict = (uint8_t *)(dictEnd - RAPIDLZ_MAX_DICT_SIZE);\n            strmCtx->dictSize = RAPIDLZ_MAX_DICT_SIZE;\n        }\n    }": "463", "static inline uint32_t RapidlzHash4GetPos(uint32_t hashValue, uint32_t *hashTable)\n    {\n        return hashTable[hashValue];\n    }": "464", "static inline void RapidlzHash4PutPos(uint32_t pos, uint32_t hashValue, uint32_t *hashTable)\n    {\n        hashTable[hashValue] = pos;\n    }": "465", "static inline uint32_t RapidlzHash4CalcValue(const uint8_t *curSrc)\n    {\n        return (RAPIDLZ_READ32BIT(curSrc) * RAPIDLZ_GOLDEN_SECTION_PRIME) >> RAPIDLZ_STREAM_HASH_BITS;\n    }": "466", "static inline size_t RapidlzStoreLiteralLen(uint32_t litLen, uint8_t *curDest)\n    {\n        uint8_t *curDestAnchor = curDest;\n        if (litLen >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            uint32_t tmp = litLen - RAPIDLZ_MAX_4BIT_VALUE;\n            *(curDest)++ = (RAPIDLZ_MAX_4BIT_VALUE << 4);\n            for (; tmp >= RAPIDLZ_MAX_BYTE_VALUE; tmp -= RAPIDLZ_MAX_BYTE_VALUE)\n            {\n                *(curDest)++ = RAPIDLZ_MAX_BYTE_VALUE;\n            }\n            *(curDest)++ = (uint8_t)tmp;\n        }\n        else\n        {\n            *(curDest)++ = (uint8_t)(litLen << 4);\n        }\n        return curDest - curDestAnchor;\n    }": "467", "static inline size_t RapidlzStoreMatchLen(uint32_t matchLen, uint8_t *token, uint8_t *curDest)\n    {\n        uint8_t *curDestAnchor = curDest;\n        if (matchLen >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            *token += RAPIDLZ_MAX_4BIT_VALUE;\n            matchLen -= RAPIDLZ_MAX_4BIT_VALUE;\n            *curDest = RAPIDLZ_MAX_BYTE_VALUE;\n            while (matchLen >= RAPIDLZ_MAX_BYTE_VALUE)\n            {\n                *(++curDest) = RAPIDLZ_MAX_BYTE_VALUE;\n                matchLen -= RAPIDLZ_MAX_BYTE_VALUE;\n            }\n            curDest += matchLen / RAPIDLZ_MAX_BYTE_VALUE;\n            *curDest++ = (uint8_t)(matchLen % RAPIDLZ_MAX_BYTE_VALUE);\n        }\n        else\n        {\n            *token += (uint8_t)(matchLen);\n        }\n        return curDest - curDestAnchor;\n    }": "468", "static inline int RapidlzZeroBytesEncode(char *dest, int destSize)\n    {\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(destSize <= 0), RAPIDLZ_ENC_NOT_OK);\n        dest[0] = 0;\n        return 1;\n    }": "469", "static int RapidlzEncLastLiterals(uint8_t *curSrcAnchor, uint8_t *srcEnd, uint8_t *curDest, uint8_t *destEnd,\n                                      char *destStart)\n    {\n        size_t lastLiteralsLen = (size_t)(srcEnd - curSrcAnchor);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_LITERAL_LEN_COPY_END(curDest, lastLiteralsLen) > destEnd),\n                                   RAPIDLZ_ENC_NOT_OK);\n        curDest += RapidlzStoreLiteralLen(lastLiteralsLen, curDest);\n        RAPIDLZ_RETURN_IF_NOT_EOK(memcpy_s(curDest, destEnd - curDest, curSrcAnchor, lastLiteralsLen),\n                                  RAPIDLZ_ENC_NOT_OK);\n        curDest += lastLiteralsLen;\n        return (int)((void *)curDest - (void *)destStart);\n    }": "470", "static inline bool RapidlzStreamEncLiterals(uint8_t *curSrc, uint8_t *curSrcAnchor, uint8_t **curDest,\n                                                uint8_t *destEnd)\n    {\n        uint32_t litLen = curSrc - curSrcAnchor;\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_UNLIKELY(RAPIDLZ_LITERAL_LEN_COPY_END(*curDest, litLen) > destEnd)),\n                                   false);\n        *curDest += RapidlzStoreLiteralLen(litLen, *curDest);\n        RapidlzWildCopy8(curSrcAnchor, *curDest, *curDest + litLen);\n        *curDest += litLen;\n        return true;\n    }": "471", "int RapidlzLoadDict(RapidlzStreamCtx *strmCtx, const char *dictionary, int dictSize)\n    {\n        const uint8_t *dictStart = (const uint8_t *)dictionary;\n        const uint8_t *dictEnd = (const uint8_t *)dictionary + dictSize;\n        RAPIDLZ_RETURN_IF_NOT_EOK(memset_s(strmCtx, sizeof(RapidlzStreamCtx), 0, sizeof(RapidlzStreamCtx)),\n                                  RAPIDLZ_ENC_NOT_OK);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(dictSize < RAPIDLZ_STREAM_HASH_BYTES), RAPIDLZ_ENC_NOT_OK);\n\n        if (dictSize > RAPIDLZ_MAX_DICT_SIZE)\n        {\n            dictStart = dictEnd - RAPIDLZ_MAX_DICT_SIZE;\n        }\n\n        strmCtx->dict = (uint8_t *)dictStart;\n        strmCtx->dictSize = dictEnd - dictStart;\n        strmCtx->currentOffset = RAPIDLZ_MAX_DICT_SIZE;\n\n        uint32_t index32 = strmCtx->currentOffset - strmCtx->dictSize;\n\n        const uint8_t *curDict = dictStart;\n        while (curDict <= dictEnd - RAPIDLZ_STREAM_HASH_BYTES)\n        {\n            uint32_t hashValue = RapidlzHash4CalcValue(curDict);\n            RapidlzHash4PutPos(index32, hashValue, strmCtx->hashTable);\n            curDict += RAPIDLZ_DICT_HASH_MOVE_BYTES;\n            index32 += RAPIDLZ_DICT_HASH_MOVE_BYTES;\n        }\n\n        return (int)strmCtx->dictSize;\n    }": "472", "int RapidlzCompWithExternalDict(RapidlzStreamCtx *strmCtx, const char *src, char *dest, int srcSize, int destSize)\n    {\n\n        uint8_t *curSrc = (uint8_t *)src;\n        uint8_t *curSrcAnchor = (uint8_t *)curSrc;\n        uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + destSize;\n        if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH)\n        {\n            return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n        }\n\n        uint8_t *matchStartLimit = srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE + 1;\n        uint8_t *matchEndLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        uint32_t startIndex = strmCtx->currentOffset;\n        uint8_t *base = (uint8_t *)src - startIndex;\n\n        const uint8_t *dict, *dictBase, *dictEnd, *prefixDictStart;\n        uint32_t dictSize;\n        uint32_t offset = 0;\n\n        dict = strmCtx->dict;\n        dictSize = strmCtx->dictSize;\n        dictBase = dict + dictSize - strmCtx->currentOffset;\n        prefixDictStart = 0;\n        dictBase = dict + dictSize - strmCtx->currentOffset;\n        dictEnd = dict + dictSize;\n        strmCtx->dictSize += srcSize;\n\n        uint32_t prefixDictLimit = startIndex - dictSize;\n        strmCtx->currentOffset += (uint32_t)srcSize;\n\n        uint32_t hashValue = RapidlzHash4CalcValue(curSrc);\n        RapidlzHash4PutPos(startIndex, hashValue, strmCtx->hashTable);\n        curSrc++;\n        uint32_t forwardHashValue = RapidlzHash4CalcValue(curSrc);\n\n        const uint8_t *match;\n        uint8_t *token;\n        int acceleration = strmCtx->acceleration;\n        while (true)\n        {\n            uint8_t *forwardPos = curSrc;\n            int jumpStep = 1;\n            int searchMatchNb = acceleration << RAPIDLZ_STEP_FORWARD_BASE;\n            do\n            {\n                hashValue = forwardHashValue;\n                uint32_t current = (forwardPos - base);\n                uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n                curSrc = forwardPos;\n                forwardPos += jumpStep;\n                jumpStep = (searchMatchNb++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (RAPIDLZ_UNLIKELY(forwardPos > matchStartLimit))\n                {\n                    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n                }\n\n                if (matchOffset < startIndex)\n                {\n\n                    match = dictBase + matchOffset;\n                    prefixDictStart = dict;\n                }\n                else\n                {\n                    match = base + matchOffset;\n                    prefixDictStart = (uint8_t *)src;\n                }\n\n                forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n                RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n                RAPIDLZ_CONTINUE_IF_NOT_A_MATCH(matchOffset, prefixDictLimit, current);\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    offset = current - matchOffset;\n                    break;\n                }\n            } while (1);\n\n            RAPIDLZ_EXPAND_FORWARD(prefixDictStart, match, curSrc, curSrcAnchor);\n\n            token = curDest;\n            RAPIDLZ_RETURN_IF_NOT_TRUE(RapidlzStreamEncLiterals(curSrc, curSrcAnchor, &curDest, destEnd),\n                                       RAPIDLZ_ENC_NOT_OK);\n\n        _OFFSET_AND_MATCH:\n\n            RapidlzWriteLE16(curDest, offset);\n            curDest += 2;\n\n            uint32_t matchLen;\n            uint8_t *curSrcMatchEnd;\n\n            if (prefixDictStart == dict)\n            {\n                uint8_t *srcLimitOnlyWithDict = curSrc + (dictEnd - match);\n                if (srcLimitOnlyWithDict > matchEndLimit)\n                {\n                    srcLimitOnlyWithDict = matchEndLimit;\n                }\n                curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(\n                    srcLimitOnlyWithDict, match + RAPIDLZ_MIN_MATCH, curSrc + RAPIDLZ_MIN_MATCH);\n                matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n                curSrc = curSrcMatchEnd;\n\n                if (curSrc == srcLimitOnlyWithDict)\n                {\n                    curSrcMatchEnd =\n                        (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, (uint8_t *)src, srcLimitOnlyWithDict);\n                    matchLen += (curSrcMatchEnd - curSrc);\n                    curSrc = curSrcMatchEnd;\n                }\n            }\n            else\n            {\n                curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, match + RAPIDLZ_MIN_MATCH,\n                                                                          curSrc + RAPIDLZ_MIN_MATCH);\n                matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n                curSrc = curSrcMatchEnd;\n            }\n#ifdef RAPIDLZ_DEBUG\n            if (RAPIDLZ_UNLIKELY(RAPIDLZ_LIT_AND_MATCH_COPY_END(curDest, matchLen) > destEnd))\n            {\n                return RAPIDLZ_ENC_NOT_OK;\n            }\n#endif\n            curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n            curSrcAnchor = curSrc;\n            if (curSrc >= matchStartLimit)\n            {\n                break;\n            }\n            uint32_t hv2 = RapidlzHash4CalcValue(curSrc - 2);\n            uint32_t index = curSrc - 2 - base;\n            RapidlzHash4PutPos(index, hv2, strmCtx->hashTable);\n\n            hashValue = RapidlzHash4CalcValue(curSrc);\n            uint32_t current = (curSrc - base);\n            uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n            if (matchOffset < startIndex)\n            {\n\n                match = dictBase + matchOffset;\n                prefixDictStart = dict;\n            }\n            else\n            {\n                match = base + matchOffset;\n                prefixDictStart = (uint8_t *)src;\n            }\n\n            RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n\n            if ((matchOffset >= prefixDictLimit) && (matchOffset + RAPIDLZ_MAX_OFFSET >= current))\n            {\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    token = curDest++;\n                    *token = 0;\n                    offset = current - matchOffset;\n                    goto _OFFSET_AND_MATCH;\n                }\n            }\n            forwardHashValue = RapidlzHash4CalcValue(++curSrc);\n        }\n\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }": "473", "int RapidlzCompWithPrefixDict(RapidlzStreamCtx *strmCtx, const char *src, char *dest, int srcSize, int destSize)\n    {\n        uint8_t *curSrc = (uint8_t *)src;\n        uint8_t *curSrcAnchor = (uint8_t *)curSrc;\n        uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + destSize;\n        if (srcSize < RAPIDLZ_LAST_LITERAL_LENGTH)\n        {\n            return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n        }\n        uint8_t *matchStartLimit = srcEnd - RAPIDLZ_MIN_COMPRESSED_SIZE + 1;\n        uint8_t *matchEndLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        uint32_t startIndex = strmCtx->currentOffset;\n        uint8_t *base = (uint8_t *)src - startIndex;\n\n        uint8_t *prefixDictStart;\n        uint32_t dictSize;\n        dictSize = strmCtx->dictSize;\n        prefixDictStart = (uint8_t *)src - dictSize;\n        strmCtx->dictSize += srcSize;\n        uint32_t prefixDictLimit = startIndex - dictSize;\n        strmCtx->currentOffset += (uint32_t)srcSize;\n\n        uint32_t hashValue = RapidlzHash4CalcValue(curSrc);\n        RapidlzHash4PutPos(startIndex, hashValue, strmCtx->hashTable);\n        curSrc++;\n        uint32_t forwardHashValue = RapidlzHash4CalcValue(curSrc);\n\n        uint8_t *match, *token;\n        int acceleration = strmCtx->acceleration;\n        while (true)\n        {\n            uint8_t *forwardPos = curSrc;\n            int step = 1;\n            int searchMatchNb = acceleration << RAPIDLZ_STEP_FORWARD_BASE;\n            do\n            {\n                hashValue = forwardHashValue;\n                uint32_t current = (forwardPos - base);\n                uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n                curSrc = forwardPos;\n                forwardPos += step;\n                step = (searchMatchNb++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (RAPIDLZ_UNLIKELY(forwardPos > matchStartLimit))\n                {\n                    return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n                }\n\n                match = base + matchOffset;\n                forwardHashValue = RapidlzHash4CalcValue(forwardPos);\n                RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n\n                if (matchOffset < prefixDictLimit)\n                {\n                    continue;\n                }\n                if ((matchOffset + RAPIDLZ_MAX_OFFSET) < current)\n                {\n                    continue;\n                }\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    break;\n                }\n            } while (1);\n\n            RAPIDLZ_EXPAND_FORWARD(prefixDictStart, match, curSrc, curSrcAnchor);\n\n            token = curDest;\n            RAPIDLZ_RETURN_IF_NOT_TRUE(RapidlzStreamEncLiterals(curSrc, curSrcAnchor, &curDest, destEnd),\n                                       RAPIDLZ_ENC_NOT_OK);\n\n        _OFFSET_AND_MATCH:\n\n            RapidlzWriteLE16(curDest, curSrc - match);\n            curDest += 2;\n\n            uint32_t matchLen;\n            uint8_t *curSrcMatchEnd;\n\n            curSrcMatchEnd = (uint8_t *)RapidlzCompressExpandBackward(matchEndLimit, match + RAPIDLZ_MIN_MATCH,\n                                                                      curSrc + RAPIDLZ_MIN_MATCH);\n            matchLen = curSrcMatchEnd - curSrc - RAPIDLZ_MIN_MATCH;\n            curSrc = curSrcMatchEnd;\n#ifdef RAPIDLZ_DEBUG\n            if (RAPIDLZ_UNLIKELY(RAPIDLZ_LIT_AND_MATCH_COPY_END(curDest, matchLen) > destEnd))\n            {\n                return RAPIDLZ_ENC_NOT_OK;\n            }\n#endif\n            curDest += RapidlzStoreMatchLen(matchLen, token, curDest);\n\n            curSrcAnchor = curSrc;\n            if (curSrc >= matchStartLimit)\n            {\n                break;\n            }\n            uint32_t hv = RapidlzHash4CalcValue(curSrc - 2);\n            uint32_t index = curSrc - 2 - base;\n            RapidlzHash4PutPos(index, hv, strmCtx->hashTable);\n\n            hashValue = RapidlzHash4CalcValue(curSrc);\n            uint32_t current = (curSrc - base);\n            uint32_t matchOffset = RapidlzHash4GetPos(hashValue, strmCtx->hashTable);\n\n            match = base + matchOffset;\n\n            RapidlzHash4PutPos(current, hashValue, strmCtx->hashTable);\n            if ((matchOffset >= prefixDictLimit) && ((matchOffset + RAPIDLZ_MAX_OFFSET) >= current))\n            {\n                if (RAPIDLZ_READ32BIT(curSrc) == RAPIDLZ_READ32BIT(match))\n                {\n                    token = curDest++;\n                    *token = 0;\n                    goto _OFFSET_AND_MATCH;\n                }\n            }\n            forwardHashValue = RapidlzHash4CalcValue(++curSrc);\n        }\n\n        return RapidlzEncLastLiterals(curSrcAnchor, srcEnd, curDest, destEnd, dest);\n    }": "474", "void RapidlzStrmCtxNorm(RapidlzStreamCtx *strmCtx, char *src, int srcSize, char *dictEnd)\n    {\n        RapidlzDictSizeNorm(strmCtx, src, dictEnd);\n        strmCtx->acceleration =\n            ((strmCtx->acceleration < RAPIDLZ_STREAM_ACCELERAT_MIN)\n                 ? RAPIDLZ_STREAM_ACCELERAT_MIN\n                 : ((strmCtx->acceleration > RAPIDLZ_STREAM_ACCELERAT_MAX) ? RAPIDLZ_STREAM_ACCELERAT_MAX\n                                                                           : strmCtx->acceleration));\n        if (strmCtx->currentOffset + (uint32_t)srcSize > RAPIDLZ_PTR_DIFF_MAX_32)\n        {\n            uint32_t delta = strmCtx->currentOffset - RAPIDLZ_MAX_DICT_SIZE;\n            int i = 0;\n            for (; i < RAPIDLZ_STREAM_HASH_SIZE; i++)\n            {\n                if (strmCtx->hashTable[i] < delta)\n                {\n                    strmCtx->hashTable[i] = 0;\n                }\n                else\n                {\n                    strmCtx->hashTable[i] -= delta;\n                }\n            }\n            strmCtx->currentOffset = RAPIDLZ_MAX_DICT_SIZE;\n        }\n\n        char *srcEnd = src + srcSize;\n        if ((srcEnd > (char *)strmCtx->dict) && (srcEnd < dictEnd))\n        {\n            strmCtx->dictSize = (uint32_t)(dictEnd - srcEnd);\n            strmCtx->dictSize = ((strmCtx->dictSize > RAPIDLZ_MAX_DICT_SIZE)\n                                     ? RAPIDLZ_MAX_DICT_SIZE\n                                     : ((strmCtx->dictSize < RAPIDLZ_STREAM_HASH_BYTES) ? 0 : strmCtx->dictSize));\n            strmCtx->dict = (uint8_t *)(dictEnd - strmCtx->dictSize);\n        }\n    }": "475", "static inline void RapidlzSafeCopyMatchFast(uint8_t *curDest, uint8_t *matchSrc, uint8_t *destEnd, uint16_t offset,\n                                                uint32_t len)\n    {\n        errno_t err;\n        uint8_t *curDestCopyEnd = curDest + len;\n        if (offset < RAPIDLZ_EIGHT_BYTE)\n        {\n            curDest[0] = matchSrc[0];\n            curDest[1] = matchSrc[1];\n            curDest[2] = matchSrc[2];\n            curDest[3] = matchSrc[3];\n            matchSrc += g_enc32table[offset];\n            err = memcpy_s(curDest + RAPIDLZ_FOUR_BYTE, RAPIDLZ_FOUR_BYTE, matchSrc, RAPIDLZ_FOUR_BYTE);\n            matchSrc -= g_dec64table[offset];\n        }\n        else\n        {\n            err = memcpy_s(curDest, RAPIDLZ_EIGHT_BYTE, matchSrc, RAPIDLZ_EIGHT_BYTE);\n            matchSrc += RAPIDLZ_EIGHT_BYTE;\n        }\n#ifdef RAPIDLZ_DEBUG\n        RAPIDLZ_RETURN_IF_NOT_EOK(err, RAPIDLZ_DEC_NOT_OK);\n#else\n    (void)err;\n#endif\n        curDest += RAPIDLZ_EIGHT_BYTE;\n        uint8_t *curDestLimit = destEnd - (RAPIDLZ_EIGHT_BYTE - 1);\n        if (curDest < curDestLimit)\n        {\n            RapidlzWildCopy8(matchSrc, curDest, curDestLimit);\n            matchSrc += (curDestLimit - curDest);\n            curDest = curDestLimit;\n        }\n        while (curDest < curDestCopyEnd)\n        {\n            *curDest++ = *matchSrc++;\n        }\n    }": "476", "static int RapidlzDecWithPrefixDict(const char *const src, char *const dest, int srcSize, int outBufferSize,\n                                        const char *dictStart, int dictSize)\n    {\n        (void)dictStart;\n        (void)dictSize;\n#ifdef RAPIDLZ_DEBUG\n        dictSize = (dictSize > RAPIDLZ_MAX_DICT_SIZE) ? RAPIDLZ_MAX_DICT_SIZE : dictSize;\n        uint8_t *prefixDictStart = (uint8_t *)dest - dictSize;\n#endif\n        const uint8_t *curSrc = (const uint8_t *)src;\n        const uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + outBufferSize;\n\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *destEndFast = destEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n\n        uint32_t token, len;\n        uint16_t offset;\n        uint8_t *matchSrc;\n        uint32_t tmp = 0;\n        size_t leftSrcSize;\n        while (1)\n        {\n            token = *curSrc++;\n\n            len = token >> 4;\n            if (RAPIDLZ_LIKELY(len < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)))\n                {\n                    RapidlzCopy16Byte(curDest, curSrc);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, tmp);\n                if (RAPIDLZ_LIKELY((curSrc + len <= srcEndFast) && (curDest + len <= destEndFast)))\n                {\n                    RapidlzWildCopy16(curSrc, curDest, curDest + len);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n\n            offset = RapidlzReadLE16Bit(curSrc);\n            curSrc += 2;\n            matchSrc = curDest - offset;\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(RAPIDLZ_UNLIKELY(matchSrc < prefixDictStart)), RAPIDLZ_DEC_NOT_OK);\n#endif\n\n            len = token & RAPIDLZ_MAX_4BIT_VALUE;\n\n            if (len < RAPIDLZ_MAX_4BIT_VALUE)\n            {\n                len += 4;\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, tmp);\n                len += 4;\n            }\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS), RAPIDLZ_DEC_NOT_OK);\n#endif\n\n            if (RAPIDLZ_LIKELY((curDest + len) <= (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE + RAPIDLZ_LAST_LITERALS)))\n            {\n                RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                curDest += len;\n            }\n            else\n            {\n                if (RAPIDLZ_LIKELY(len < 1024))\n                {\n                    RAPIDLZ_FAST_SAFE_COPY_BY_BYTES(curDest, matchSrc, len);\n                }\n                else\n                {\n                    RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                    curDest += len;\n                }\n            }\n        }\n\n        return (int)((void *)curDest - (void *)(dest));\n    }": "477", "static int RapidlzDecWithExternalDict(const char *const src, char *const dest, int srcSize, int outBufferSize,\n                                          const char *dictStart, int dictSize)\n    {\n        const uint8_t *curSrc = (const uint8_t *)src;\n        const uint8_t *srcEnd = curSrc + srcSize;\n        uint8_t *curDest = (uint8_t *)dest;\n        uint8_t *destEnd = curDest + outBufferSize;\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *destEndFast = destEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        const uint8_t *dictEnd = (uint8_t *)dictStart + dictSize;\n\n        uint32_t token, len;\n        uint16_t offset;\n        uint8_t *matchSrc;\n        uint32_t temp = 0;\n        size_t leftSrcSize;\n        while (1)\n        {\n            token = *curSrc++;\n\n            len = token >> 4;\n            if (RAPIDLZ_LIKELY(len < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY(RAPIDLZ_DICT_FAST_COPY_AVAIL(curSrc, len, srcEndFast, curDest, destEndFast)))\n                {\n                    RapidlzCopy16Byte(curDest, curSrc);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(len, curSrc, srcEnd, temp);\n                if (RAPIDLZ_LIKELY(RAPIDLZ_DICT_FAST_COPY_AVAIL(curSrc, len, srcEndFast, curDest, destEndFast)))\n                {\n                    RapidlzWildCopy16(curSrc, curDest, curDest + len);\n                    RAPIDLZ_POSITION_UPDATE(curSrc, curDest, len);\n                }\n                else\n                {\n                    leftSrcSize = srcEnd - curSrc;\n                    RAPIDLZ_SAFE_COPY_TILL_END(curSrc, leftSrcSize, curDest, destEnd, len);\n                }\n            }\n\n            offset = RapidlzReadLE16Bit(curSrc);\n            curSrc += 2;\n            matchSrc = curDest - offset;\n\n            len = token & RAPIDLZ_MAX_4BIT_VALUE;\n\n            RAPIDLZ_GET_MATCH_LEN(len, curSrc, srcEnd, temp);\n\n#ifdef RAPIDLZ_DEBUG\n            RAPIDLZ_RETURN_IF_NOT_TRUE(!(curDest + len > destEnd - RAPIDLZ_LAST_LITERALS), RAPIDLZ_DEC_NOT_OK);\n#endif\n            if (matchSrc >= (uint8_t *)dest)\n            {\n                if (RAPIDLZ_LIKELY((curDest + len) <=\n                                   (destEndFast - RAPIDLZ_COPY_PROTECT_SIZE + RAPIDLZ_LAST_LITERALS)))\n                {\n                    RapidlzCopyMatchFast(curDest, matchSrc, offset, len);\n                    curDest += len;\n                }\n                else\n                {\n                    if (RAPIDLZ_LIKELY(len < 1024))\n                    {\n                        RAPIDLZ_FAST_SAFE_COPY_BY_BYTES(curDest, matchSrc, len);\n                    }\n                    else\n                    {\n                        RapidlzSafeCopyMatchFast(curDest, matchSrc, destEnd, offset, len);\n                        curDest += len;\n                    }\n                }\n            }\n            else\n            {\n                errno_t err;\n                if ((int)len <= ((uint8_t *)dest - matchSrc))\n                {\n                    err = memmove_s(curDest, destEnd - curDest, dictEnd - ((uint8_t *)dest - matchSrc), len);\n                    curDest += len;\n                }\n                else\n                {\n                    size_t externCopySize = (size_t)((uint8_t *)dest - matchSrc);\n                    size_t innerCopySize = len - externCopySize;\n                    err = memcpy_s(curDest, destEnd - curDest, dictEnd - externCopySize, externCopySize);\n                    curDest += externCopySize;\n                    if (innerCopySize > (size_t)(curDest - (uint8_t *)dest))\n                    {\n                        const uint8_t *copySrc = (uint8_t *)dest;\n                        while ((innerCopySize--) != 0)\n                        {\n                            *curDest++ = *copySrc++;\n                        }\n                    }\n                    else\n                    {\n                        err = memcpy_s(curDest, destEnd - curDest, (uint8_t *)dest, innerCopySize);\n                        curDest += innerCopySize;\n                    }\n                }\n#ifdef RAPIDLZ_DEBUG\n                RAPIDLZ_RETURN_IF_NOT_EOK(err, RAPIDLZ_DEC_NOT_OK);\n#else\n            (void)err;\n#endif\n            }\n        }\n\n        return (int)((void *)curDest - (void *)(dest));\n    }": "478", "int RapidlzCompressStream(RapidlzStreamCtx *strmCtx, const char *src, char *dst, int srcSize, int dstSize)\n    {\n        RapidlzCompressFunc rapidlzEncFunc = NULL;\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!(srcSize > RAPIDLZ_MAX_INPUT_SIZE), RAPIDLZ_ENC_NOT_OK);\n        RAPIDLZ_RETURN_IF_NOT_TRUE(!((src == NULL && srcSize != 0) || (dstSize <= 0) || (dst == NULL)),\n                                   RAPIDLZ_ENC_NOT_OK);\n        if (srcSize == 0)\n        {\n            return RapidlzZeroBytesEncode(dst, dstSize);\n        }\n        char *dictEnd = (strmCtx->dictSize != 0) ? (char *)strmCtx->dict + strmCtx->dictSize : NULL;\n        int cSize;\n        if (dictEnd == src)\n        {\n            rapidlzEncFunc = RapidlzCompWithPrefixDict;\n        }\n        else\n        {\n            if (strmCtx->strmCtxSpecific != NULL)\n            {\n                RAPIDLZ_RETURN_IF_NOT_EOK(\n                    memcpy_s(strmCtx, sizeof(RapidlzStreamCtx), strmCtx->strmCtxSpecific, sizeof(RapidlzStreamCtx)),\n                    RAPIDLZ_ENC_NOT_OK);\n            }\n            rapidlzEncFunc = RapidlzCompWithExternalDict;\n        }\n        RapidlzStrmCtxNorm(strmCtx, (char *)src, srcSize, dictEnd);\n        cSize = rapidlzEncFunc(strmCtx, src, dst, srcSize, dstSize);\n        strmCtx->dictSize = srcSize;\n        strmCtx->dict = (uint8_t *)src;\n        return cSize;\n    }": "479", "int RapidlzDecompressSafeUsingDict(const char *src, char *dst, int compressedSize, int dstSize,\n                                       const char *dictStart, int dictSize)\n    {\n        if ((src == NULL) || (compressedSize == 0) || (dst == NULL) || (dstSize < 0))\n        {\n            return RAPIDLZ_ERROR_PARAM_UNSUPPORTED;\n        }\n        if (RAPIDLZ_UNLIKELY(dstSize == 0))\n        {\n            return RapidlzZeroBytesDecode(src, compressedSize);\n        }\n        RapidlzDecompressFunc rapidlzDecFunc;\n        if ((dictSize == 0) || (dictStart + dictSize == dst))\n        {\n            rapidlzDecFunc = RapidlzDecWithPrefixDict;\n        }\n        else\n        {\n            rapidlzDecFunc = RapidlzDecWithExternalDict;\n        }\n        return rapidlzDecFunc(src, dst, compressedSize, dstSize, dictStart, dictSize);\n    }": "480", "void RapidlzLogWrite(size_t error_code, const char *file_name, unsigned short line, const char *fmt, ...)\n    {\n        va_list alist;\n        char output[LOG_BUF_SIZE];\n        int retVal, len;\n        RapidlzLogFunc func = g_rapidlzLogFunc;\n        char *filename;\n\n        if (func == NULL)\n        {\n            return;\n        }\n\n        filename = strdup(file_name);\n        if (filename == NULL)\n        {\n            return;\n        }\n\n        retVal = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1, \"\\n[Rapidlz-Log] File=%s, Line=%u, Error=%zu\\n\",\n                            basename(filename), line, error_code);\n        if (retVal < 0)\n        {\n            free(filename);\n            return;\n        }\n        len = retVal;\n\n        free(filename);\n\n        va_start(alist, fmt);\n        retVal = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1, fmt, alist);\n        va_end(alist);\n        if (retVal < 0)\n        {\n            return;\n        }\n\n        func(output, strlen(output) + 1);\n    }": "481", "void RapidlzLogRegister(RapidlzLogFunc func)\n    {\n        g_rapidlzLogFunc = func;\n    }": "482", "size_t RapidlzDecompress(const void *src, void *dst, size_t srcSize, size_t dstSize)\n    {\n        if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n            return 0;\n        }\n\n        uint8_t token, temp = 0;\n        register uint16_t offset;\n        register uint32_t litLen, matchLen;\n        uint8_t *matchSrc;\n        const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n        const uint8_t *srcCurr = (const uint8_t *)src;\n        const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n        uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n        uint8_t *dstCurr = (uint8_t *)dst;\n        uint8_t *dstEndFast = dstEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n\n        while (srcCurr < srcEnd)\n        {\n            token = *srcCurr++;\n            litLen = (token >> 4);\n\n            if (RAPIDLZ_LIKELY(litLen < RAPIDLZ_MAX_4BIT_VALUE))\n            {\n                if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n                {\n                    RapidlzCopy16Byte(dstCurr, srcCurr);\n                    dstCurr += litLen;\n                    srcCurr += litLen;\n                    goto READ_MATCH;\n                }\n            }\n            else\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(litLen, srcCurr, srcEnd, temp);\n                if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n                {\n                    RapidlzWildCopy16(srcCurr, dstCurr, dstCurr + litLen);\n                    dstCurr += litLen;\n                    srcCurr += litLen;\n                    goto READ_MATCH;\n                }\n            }\n\n            size_t leftSrcSize = srcEnd - srcCurr;\n            if (RAPIDLZ_UNLIKELY(litLen > leftSrcSize || memmove_s(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"litLen:%u dstEnd - dst:%zu\\n\", litLen, leftSrcSize);\n                return 0;\n            }\n\n            dstCurr += litLen;\n            srcCurr += litLen;\n\n            if (leftSrcSize == litLen)\n            {\n                return dstCurr - (uint8_t *)(dst);\n            }\n\n        READ_MATCH:\n            if (RAPIDLZ_UNLIKELY(srcCurr > srcEnd - 2))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n                return 0;\n            }\n            offset = RapidlzReadLE16Bit(srcCurr);\n            srcCurr += 2;\n            matchSrc = dstCurr - offset;\n            if (RAPIDLZ_UNLIKELY((void *)matchSrc < dst))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n                return 0;\n            }\n\n            matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE) + RAPIDLZ_MIN_MATCH;\n            if (matchLen == RAPIDLZ_MAX_4BIT_MATCH)\n            {\n                RAPIDLZ_READ_OPTIONAL_LENGTH(matchLen, srcCurr, srcEnd, temp);\n            }\n\n            if (RAPIDLZ_LIKELY(dstCurr + matchLen <= dstEndFast))\n            {\n                RapidlzCopyMatchFast(dstCurr, matchSrc, offset, matchLen);\n                dstCurr += matchLen;\n            }\n            else\n            {\n                if (dstCurr + matchLen > dstEnd)\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCurr:%zu matchLen:%u\\n\", dstEnd - dstCurr,\n                                matchLen);\n                    return 0;\n                }\n\n                SAFE_COPY_MATCH(dstCurr, matchSrc, matchLen);\n            }\n        }\n\n        return dstCurr - (uint8_t *)dst;\n    }": "483", "static inline int RapidlzIsLE(void)\n    {\n#if (defined(__GNUC__) || defined(__clang__))\n        return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n        int n = 1;\n        return *(char *)(&n);\n    }": "484", "static inline uint16_t RapidlzReadLE16Bit(const void *addr)\n    {\n        if (RapidlzIsLE() != 0)\n        {\n            return *(const uint16_t *)addr;\n        }\n\n        uint8_t tmp1 = ((const uint8_t *)addr)[0];\n        uint8_t tmp2 = ((const uint8_t *)addr)[1];\n        return (uint16_t)(tmp1 + (tmp2 << 8));\n    }": "485", "static inline uint8_t RapidlzCountTailZero64(uint64_t x)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return (uint8_t)__builtin_ctzll(x);\n#endif\n        if (x == 0)\n        {\n            return 0;\n        }\n        uint64_t val = x;\n        uint8_t num = 0;\n        while ((val & 1) == 0)\n        {\n            val >>= 1;\n            num++;\n        }\n        return num;\n    }": "486", "static inline uint8_t RapidlzCountLeadZero64(uint64_t x)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return (uint8_t)__builtin_clzll(x);\n#endif\n        if (x == 0)\n        {\n            return 0;\n        }\n        uint8_t num = 0;\n        uint64_t val = x;\n        while ((val & 0x8000000000000000ULL) == 0)\n        {\n            val <<= 1;\n            num++;\n        }\n        return num;\n    }": "487", "static inline uint8_t RapidlzHighBit64(uint64_t x)\n    {\n        RAPIDLZ_ASSERT(x != 0);\n\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return ((uint8_t)__builtin_clzll(x) ^ 63);\n#endif\n        uint8_t pos = 64;\n        uint64_t value = x;\n\n        if (value == 0)\n        {\n            return 0;\n        }\n        if ((value & 0xFFFFFFFF00000000) == 0)\n        {\n            value <<= 32;\n            pos -= 32;\n        }\n        if ((value & 0xFFFF000000000000) == 0)\n        {\n            value <<= 16;\n            pos -= 16;\n        }\n        if ((value & 0xFF00000000000000) == 0)\n        {\n            value <<= 8;\n            pos -= 8;\n        }\n        if ((value & 0xF000000000000000) == 0)\n        {\n            value <<= 4;\n            pos -= 4;\n        }\n        if ((value & 0xC000000000000000) == 0)\n        {\n            value <<= 2;\n            pos -= 2;\n        }\n        if ((value & 0x8000000000000000) == 0)\n        {\n            value <<= 1;\n            pos -= 1;\n        }\n\n        return pos - 1;\n    }": "488", "static inline void RapidlzWriteLE16(void *addr, uint16_t val)\n    {\n        if (RapidlzIsLE() != 0)\n        {\n            *(uint16_t *)addr = val;\n        }\n        else\n        {\n            uint8_t *tmp = (uint8_t *)addr;\n            tmp[0] = (uint8_t)val;\n            tmp[1] = (uint8_t)(val >> 8);\n        }\n    }": "489", "static inline void RapidlzCopy32Byte(void *dst, const void *src)\n    {\n#if defined(ARM_NEON)\n\n        vst1q_u8((uint8_t *)dst, vld1q_u8((const uint8_t *)src));\n        vst1q_u8((uint8_t *)dst + 16, vld1q_u8((const uint8_t *)src + 16));\n#elif defined(X86_SSE2)\n    _mm_storeu_si128((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n    _mm_storeu_si128((__m128i *)dst + 1, _mm_loadu_si128((const __m128i *)src + 1));\n#else\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 8, RAPIDLZ_READ64BIT((uint8_t *)src + 8));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 16, RAPIDLZ_READ64BIT((uint8_t *)src + 16));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 24, RAPIDLZ_READ64BIT((uint8_t *)src + 24));\n#endif\n    }": "490", "static inline void RapidlzCopy16Byte(void *dst, const void *src)\n    {\n#if defined(ARM_NEON)\n        vst1q_u8((uint8_t *)dst, vld1q_u8((const uint8_t *)src));\n#elif defined(X86_SSE2)\n    _mm_storeu_si128((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n#else\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 8, RAPIDLZ_READ64BIT((uint8_t *)src + 8));\n#endif\n    }": "491", "static inline void RapidlzCopy8Byte(void *dst, const void *src)\n    {\n#if defined(ARM_NEON)\n        vst1_u8((uint8_t *)dst, vld1_u8((const uint8_t *)src));\n#else\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n#endif\n    }": "492", "static inline void RapidlzWildCopy8(const uint8_t *srcPtr, uint8_t *dstPtr, uint8_t *dstEnd)\n    {\n        uint8_t *tmpDstPtr = dstPtr;\n        const uint8_t *tmpSrcPtr = srcPtr;\n        do\n        {\n            RapidlzCopy8Byte(tmpDstPtr, tmpSrcPtr);\n            tmpDstPtr += 8;\n            tmpSrcPtr += 8;\n        } while (tmpDstPtr < dstEnd);\n    }": "493", "static inline void RapidlzWildCopy16(const uint8_t *srcPtr, uint8_t *dstPtr, uint8_t *dstEnd)\n    {\n        uint8_t *tmpDstPtr = dstPtr;\n        const uint8_t *tmpSrcPtr = srcPtr;\n        do\n        {\n            RapidlzCopy16Byte(tmpDstPtr, tmpSrcPtr);\n            tmpDstPtr += 16;\n            tmpSrcPtr += 16;\n        } while (tmpDstPtr < dstEnd);\n    }": "494", "static inline void RapidlzWildCopy32(const uint8_t *srcPtr, uint8_t *dstPtr, uint8_t *dstEnd)\n    {\n        uint8_t *tmpDstPtr = dstPtr;\n        const uint8_t *tmpSrcPtr = srcPtr;\n        do\n        {\n            RapidlzCopy32Byte(tmpDstPtr, tmpSrcPtr);\n            tmpDstPtr += 32;\n            tmpSrcPtr += 32;\n        } while (tmpDstPtr < dstEnd);\n    }": "495", "static inline void RapidlzCopyLiteralsFast(const uint8_t *src, uint8_t *dst, uint32_t length)\n    {\n        if (RAPIDLZ_LIKELY(length <= RAPIDLZ_SIXTEEN_BYTE))\n        {\n            RapidlzCopy16Byte(dst, src);\n            return;\n        }\n\n        RapidlzWildCopy16(src, dst, dst + length);\n    }": "496", "static inline const uint8_t *RapidlzCompressExpandBackward(const uint8_t *matchLimit, const uint8_t *matchPtr,\n                                                               const uint8_t *srcCurr)\n    {\n        uint64_t xorVal;\n        const uint8_t *loopEnd = matchLimit - 7;\n        const uint8_t *srcCurrMatchEnd = srcCurr;\n        const uint8_t *matchBegin = matchPtr;\n\n        while (srcCurrMatchEnd < loopEnd)\n        {\n            xorVal = RAPIDLZ_READ64BIT(matchBegin) ^ RAPIDLZ_READ64BIT(srcCurrMatchEnd);\n            if (RAPIDLZ_UNLIKELY(xorVal == 0))\n            {\n                srcCurrMatchEnd += sizeof(uint64_t);\n                matchBegin += sizeof(uint64_t);\n                continue;\n            }\n            srcCurrMatchEnd +=\n                RapidlzIsLE() ? (RapidlzCountTailZero64(xorVal) >> 3) : (RapidlzCountLeadZero64(xorVal) >> 3);\n            return srcCurrMatchEnd;\n        }\n\n        if (((srcCurrMatchEnd + 3) < matchLimit) &&\n            (RAPIDLZ_READ32BIT(srcCurrMatchEnd) == RAPIDLZ_READ32BIT(matchBegin)))\n        {\n            srcCurrMatchEnd += sizeof(uint32_t);\n            matchBegin += sizeof(uint32_t);\n        }\n\n        if (((srcCurrMatchEnd + 1) < matchLimit) &&\n            (RAPIDLZ_READ16BIT(srcCurrMatchEnd) == RAPIDLZ_READ16BIT(matchBegin)))\n        {\n            srcCurrMatchEnd += sizeof(uint16_t);\n            matchBegin += sizeof(uint16_t);\n        }\n\n        if ((srcCurrMatchEnd < matchLimit) && (srcCurrMatchEnd[0] == matchBegin[0]))\n        {\n            srcCurrMatchEnd++;\n        }\n        return srcCurrMatchEnd;\n    }": "497", "static inline void RapidlzCopyMatchFast(uint8_t *dst, uint8_t *match, uint16_t offset, uint32_t length)\n    {\n        uint8_t *dstCurr = dst;\n        uint8_t *matchPtr = match;\n\n        if (offset >= RAPIDLZ_SIXTEEN_BYTE)\n        {\n            RapidlzCopyLiteralsFast(matchPtr, dstCurr, length);\n            return;\n        }\n\n        for (int i = 0; i < RAPIDLZ_EIGHT_BYTE; ++i)\n        {\n            dstCurr[i] = matchPtr[i];\n        }\n\n        if (length <= RAPIDLZ_EIGHT_BYTE)\n        {\n            return;\n        }\n\n        uint8_t *dstEnd = dstCurr + length;\n        if (offset < RAPIDLZ_EIGHT_BYTE)\n        {\n            matchPtr += g_overlapOffAddVal[offset];\n            dstCurr += RAPIDLZ_EIGHT_BYTE;\n        }\n\n        do\n        {\n            RapidlzCopy8Byte(dstCurr, matchPtr);\n            dstCurr += RAPIDLZ_EIGHT_BYTE;\n            matchPtr += RAPIDLZ_EIGHT_BYTE;\n        } while (dstCurr < dstEnd);\n    }": "498", "const char *RapidlzVersionGet(void)\n    {\n        return g_rapidlzVersion;\n    }": "499", "size_t RapidlzCompressBound(size_t srcSize)\n    {\n\n        return RAPIDLZ_COMPRESSBOUND(srcSize);\n    }": "500", "static inline void RapidlzPutPosOnTable(uint32_t pos, uint32_t hashValue, uint8_t *hashTable, uint8_t hashType)\n    {\n        if (hashType == 4)\n        {\n            *(((uint16_t *)hashTable) + hashValue) = (uint16_t)pos;\n        }\n        else if (hashType == 5)\n        {\n            *(((uint32_t *)hashTable) + hashValue) = (uint32_t)pos;\n        }\n    }": "501", "static inline uint32_t RapidlzGetPosOnTable(uint32_t hashValue, uint8_t *hashTable, uint8_t hashType)\n    {\n        if (hashType == 4)\n        {\n            return (uint32_t)(*(((uint16_t *)hashTable) + hashValue));\n        }\n        else if (hashType == 5)\n        {\n            return (*(((uint32_t *)hashTable) + hashValue));\n        }\n\n        return 0;\n    }": "502", "static inline uint32_t RapidlzCalcHashValue(const uint8_t *srcCurr, uint8_t hashType, uint8_t hashBits)\n    {\n        if (hashType == 5)\n        {\n            return (uint32_t)((((RAPIDLZ_READ64BIT(srcCurr)) << 24) * 11400714819323198485ULL) >> (64 - hashBits));\n        }\n        else\n        {\n            return (RAPIDLZ_READ32BIT(srcCurr) * 2654435769U) >> (32 - hashBits);\n        }\n    }": "503", "static inline uint8_t *RapidlzCompressStoreOptionalLength(uint8_t *dst, uint32_t litLength)\n    {\n        uint8_t *dstCurr = dst;\n        uint32_t length = litLength;\n\n        if (length < RAPIDLZ_MAX_BYTE_VALUE)\n        {\n            *dstCurr = (uint8_t)length;\n            dstCurr++;\n            return dstCurr;\n        }\n\n        do\n        {\n            *dstCurr = RAPIDLZ_MAX_BYTE_VALUE;\n            dstCurr++;\n            length -= RAPIDLZ_MAX_BYTE_VALUE;\n        } while (length >= RAPIDLZ_MAX_BYTE_VALUE);\n\n        *dstCurr = (uint8_t)length;\n        dstCurr++;\n        return dstCurr;\n    }": "504", "static inline uint8_t *RapidlzStoreLastLiterals(uint8_t *dst, uint8_t *dstEnd, const uint8_t *srcCurr,\n                                                    uint32_t litLength, uint8_t bufferLimit)\n    {\n        uint8_t *dstCurr = dst;\n\n        if (bufferLimit != 0)\n        {\n            const uint32_t litTokSize = 1 + litLength + (litLength / RAPIDLZ_MAX_BYTE_VALUE);\n            if (dstCurr + litTokSize > dstEnd)\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu litTokSize:%u\\n\", dstEnd - dstCurr,\n                            litTokSize);\n                return NULL;\n            }\n        }\n\n        uint8_t token = (uint8_t)(((litLength < RAPIDLZ_MAX_4BIT_VALUE) ? (litLength) : (RAPIDLZ_MAX_4BIT_VALUE)) << 4);\n        *dstCurr = token;\n        dstCurr++;\n\n        if (litLength >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            dstCurr = RapidlzCompressStoreOptionalLength(dstCurr, litLength - RAPIDLZ_MAX_4BIT_VALUE);\n        }\n\n        if (memcpy_s(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_SECUREC_ERROR, \"dstEnd - dstCurr:%zu litLength%u\\n\", dstEnd - dstCurr, litLength);\n            return NULL;\n        }\n\n        return dstCurr + litLength;\n    }": "505", "static inline uint8_t *RapidlzStoreOffMatch(uint8_t *dst, uint8_t *token, uint32_t matchLength, uint16_t offset)\n    {\n        uint8_t *dstCurr = dst;\n\n        RapidlzWriteLE16(dstCurr, offset);\n        dstCurr += 2;\n\n        if (matchLength >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            uint32_t optionalLen = matchLength - RAPIDLZ_MAX_4BIT_VALUE;\n            *token += RAPIDLZ_MAX_4BIT_VALUE;\n            for (; optionalLen >= RAPIDLZ_MAX_BYTE_VALUE; optionalLen -= RAPIDLZ_MAX_BYTE_VALUE)\n            {\n                *dstCurr++ = RAPIDLZ_MAX_BYTE_VALUE;\n            }\n            *dstCurr++ = (uint8_t)optionalLen;\n        }\n        else\n        {\n            *token += (uint8_t)matchLength;\n        }\n\n        return dstCurr;\n    }": "506", "static inline uint8_t *RapidlzStoreSequence(uint8_t *dst, const uint8_t *srcAnchor, uint32_t literalLength,\n                                                uint32_t matchLength, uint16_t offset)\n    {\n        uint8_t *dstCurr = dst;\n        uint8_t *token = dstCurr++;\n\n        if (literalLength >= RAPIDLZ_MAX_4BIT_VALUE)\n        {\n            *token = (RAPIDLZ_MAX_4BIT_VALUE << 4);\n            uint32_t optionalLen = literalLength - RAPIDLZ_MAX_4BIT_VALUE;\n            for (; optionalLen >= RAPIDLZ_MAX_BYTE_VALUE; optionalLen -= RAPIDLZ_MAX_BYTE_VALUE)\n            {\n                *dstCurr++ = (uint8_t)RAPIDLZ_MAX_BYTE_VALUE;\n            }\n            *dstCurr++ = (uint8_t)optionalLen;\n            RapidlzCopy16Byte(dstCurr, srcAnchor);\n            if (literalLength > 16)\n            {\n                RapidlzWildCopy16(srcAnchor + 16, dstCurr + 16, dstCurr + literalLength);\n            }\n            dstCurr += literalLength;\n        }\n        else if (literalLength > 0)\n        {\n            *token = (uint8_t)(literalLength << 4);\n            RapidlzCopy16Byte(dstCurr, srcAnchor);\n            dstCurr += literalLength;\n        }\n        else\n        {\n            *token = 0;\n        }\n\n        return RapidlzStoreOffMatch(dstCurr, token, matchLength, offset);\n    }": "507", "static size_t RapidlzCompressProcess(void *dst, size_t dstSize, const void *src, size_t srcSize, RapidlzCCtx *cCtx)\n    {\n        uint32_t hashValue, matchLength, literalLength;\n        uint32_t step = 1;\n        uint16_t offset;\n        uint8_t *hashTable = cCtx->hashTable;\n        const uint8_t *srcBegin = (const uint8_t *)src;\n        const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n        const uint8_t *srcCurr = srcBegin + 1;\n        const uint8_t *srcCurrMatchEnd;\n        const uint8_t *srcAnchor = srcBegin;\n        const uint8_t *matchBegin;\n        const uint8_t *matchLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n        const uint8_t *srcLimit = srcEnd - RAPIDLZ_MIN_COMPRESS_SIZE;\n        uint8_t *dstBegin = (uint8_t *)dst;\n        uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n        uint8_t *dstCurr = dstBegin;\n        uint8_t hashType = cCtx->hashType;\n        uint8_t hashBits = cCtx->hashBits;\n        uint32_t searchMatchNb = cCtx->step << RAPIDLZ_STEP_FORWARD_BASE;\n        uint32_t searchMatchNbTmp = searchMatchNb;\n        uint8_t bufferLimit = cCtx->bufferLimit;\n\n        while (RAPIDLZ_LIKELY(srcCurr <= srcLimit))\n        {\n            for (;;)\n            {\n                hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n                matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n                RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n                if ((RAPIDLZ_READ32BIT(srcCurr) == RAPIDLZ_READ32BIT(matchBegin)) &&\n                    RAPIDLZ_LIKELY((srcCurr - matchBegin) <= RAPIDLZ_MAX_OFFSET))\n                {\n                    break;\n                }\n\n                srcCurr += step;\n                step = (searchMatchNbTmp++ >> RAPIDLZ_STEP_FORWARD_BASE);\n\n                if (srcCurr > srcLimit)\n                {\n                    dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n                    if (dstCurr == NULL)\n                    {\n                        return 0;\n                    }\n                    return dstCurr - dstBegin;\n                }\n            }\n            step = 1;\n            searchMatchNbTmp = searchMatchNb;\n\n            srcCurrMatchEnd =\n                RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n            RAPIDLZ_EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor);\n            matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n            offset = (uint16_t)(srcCurr - matchBegin);\n            literalLength = srcCurr - srcAnchor;\n            if (bufferLimit != 0)\n            {\n                uint32_t writeSize = literalLength + 8 + (literalLength + matchLength / RAPIDLZ_MAX_BYTE_VALUE);\n                if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                                writeSize);\n                    return 0;\n                }\n            }\n            dstCurr = RapidlzStoreSequence(dstCurr, srcAnchor, literalLength, matchLength, offset);\n            srcCurr = srcCurrMatchEnd;\n            srcAnchor = srcCurr;\n            hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n            RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n\n            if (RAPIDLZ_UNLIKELY(srcCurr > srcLimit))\n            {\n                break;\n            }\n\n            hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n            matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n            RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n            if ((RAPIDLZ_READ32BIT(srcCurr) != RAPIDLZ_READ32BIT(matchBegin)) ||\n                RAPIDLZ_UNLIKELY((srcCurr - matchBegin) > RAPIDLZ_MAX_OFFSET))\n            {\n                srcCurr++;\n                continue;\n            }\n\n            srcCurrMatchEnd =\n                RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n            matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n            offset = (uint16_t)(srcCurr - matchBegin);\n            if (bufferLimit != 0)\n            {\n                const uint32_t writeSize = 8 + matchLength / RAPIDLZ_MAX_BYTE_VALUE;\n                if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n                {\n                    RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                                writeSize);\n                    return 0;\n                }\n            }\n            *dstCurr = 0;\n            dstCurr = RapidlzStoreOffMatch(dstCurr + 1, dstCurr, matchLength, offset);\n\n            srcCurr = srcCurrMatchEnd;\n            srcAnchor = srcCurr;\n\n            hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n            RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n        }\n\n        if (srcAnchor < srcEnd)\n        {\n            dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n            if (dstCurr == NULL)\n            {\n                return 0;\n            }\n        }\n\n        return dstCurr - dstBegin;\n    }": "508", "static void RapidlzCCtxFree(RapidlzCCtx *cCtx)\n    {\n        if (cCtx != NULL)\n        {\n            if (cCtx->hashTable != NULL)\n            {\n                free(cCtx->hashTable);\n                cCtx->hashTable = NULL;\n            }\n\n            free(cCtx);\n        }\n    }": "509", "size_t RapidlzCompress(const void *src, void *dst, size_t srcSize, size_t dstSize, int acceleration)\n    {\n        if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n            return 0;\n        }\n\n        if (acceleration < 1 || acceleration > RAPIDLZ_ACCELERATION_MAX)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"acceleration:%d\\n\", acceleration);\n            return 0;\n        }\n\n        RapidlzCCtx *cCtx = (RapidlzCCtx *)malloc(sizeof(RapidlzCCtx));\n        if (cCtx == NULL)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"cCtx malloc failed\\n\");\n            return 0;\n        }\n\n        cCtx->hashBits = RAPIDLZ_MIN_HASH_BIT;\n        size_t totalHashSize;\n        if (srcSize <= RAPIDLZ_SRC_SIZE_THRESHOLD)\n        {\n            cCtx->hashType = RAPIDLZ_HASH_TYPE_4;\n            if (srcSize >= 64)\n            {\n                cCtx->hashBits = (RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT) ? (RAPIDLZ_MAX_HASH_BIT + 1)\n                                                                                    : RapidlzHighBit64(srcSize);\n            }\n            totalHashSize = sizeof(uint16_t) * (uint32_t)(1 << cCtx->hashBits);\n        }\n        else\n        {\n            cCtx->hashType = RAPIDLZ_HASH_TYPE_5;\n            cCtx->hashBits = RAPIDLZ_MAX_HASH_BIT;\n            totalHashSize = sizeof(uint32_t) * (uint32_t)(1 << cCtx->hashBits);\n        }\n\n        uint8_t *table = (uint8_t *)malloc(totalHashSize);\n        if (table == NULL)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"hash table malloc failed\\n\");\n            free(cCtx);\n            return 0;\n        }\n        (void)memset_s(table, totalHashSize, 0, totalHashSize);\n        cCtx->hashTable = table;\n        cCtx->step = (uint8_t)acceleration;\n        cCtx->bufferLimit = dstSize < RapidlzCompressBound(srcSize);\n\n        size_t cSize = RapidlzCompressProcess(dst, dstSize, src, srcSize, cCtx);\n        RapidlzCCtxFree(cCtx);\n        return cSize;\n    }": "510", "size_t RapidlzCompressDefault(const void *src, void *dst, size_t srcSize, size_t dstSize)\n    {\n        return RapidlzCompress(src, dst, srcSize, dstSize, 1);\n    }": "511", "void vosSha256Begin(VOS_SHA256_CTX *pstCtx)\n    {\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n        pstCtx->h[0] = 0x6a09e667UL;\n        pstCtx->h[1] = 0xbb67ae85UL;\n        pstCtx->h[2] = 0x3c6ef372UL;\n        pstCtx->h[3] = 0xa54ff53aUL;\n        pstCtx->h[4] = 0x510e527fUL;\n        pstCtx->h[5] = 0x9b05688cUL;\n        pstCtx->h[6] = 0x1f83d9abUL;\n        pstCtx->h[7] = 0x5be0cd19UL;\n        pstCtx->outlen = SHA256_DIGEST_SIZE;\n    }": "512", "static uint32_t vosSha256CtxPrepare(VOS_SHA256_CTX *pstCtx, uint32_t uiLen)\n    {\n        uint32_t uiCntFirst;\n        uint32_t uiCntSec;\n\n        uiCntFirst = (pstCtx->N[0] + (uiLen << SHIFTS_PER_BYTE)) & 0xffffffffUL;\n        if (uiCntFirst < pstCtx->N[0])\n        {\n            ++pstCtx->N[1];\n            if (pstCtx->N[1] == 0)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n        }\n\n        uiCntSec = pstCtx->N[1] + (uiLen >> (BITSIZE(uint32_t) - SHIFTS_PER_BYTE));\n        if (uiCntSec < pstCtx->N[1])\n        {\n            pstCtx->corrupted = 1;\n            return SHA256_ERROR;\n        }\n\n        pstCtx->N[1] = uiCntSec;\n        pstCtx->N[0] = uiCntFirst;\n        return SHA256_OK;\n    }": "513", "static uint32_t vosSha256LastPadding(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx,\n                                         uint32_t *puiPaddingLen)\n    {\n        errno_t err;\n        uint32_t uiBlcLen = pstCtx->blocklen;\n        uint8_t *pucBlock = (uint8_t *)pstCtx->block;\n\n        if ((uiLen >= SHA256_BLOCK_SIZE) || (uiLen + uiBlcLen >= SHA256_BLOCK_SIZE))\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, SHA256_BLOCK_SIZE - uiBlcLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            *puiPaddingLen = SHA256_BLOCK_SIZE - uiBlcLen;\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n        }\n        else\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, uiLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            pstCtx->blocklen += (uint32_t)uiLen;\n            return SHA256_ERROR;\n        }\n\n        return SHA256_OK;\n    }": "514", "static void vosSha256HashByBlcMulti(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        errno_t err;\n        uint32_t uiBlcLen;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        uiBlcLen = (uint32_t)(uiLenTmp / SHA256_BLOCK_SIZE);\n        if (uiBlcLen > 0)\n        {\n            vosSha256CompressMul(pstCtx, pucSrc, uiBlcLen);\n            uiBlcLen *= SHA256_BLOCK_SIZE;\n            pucSrc += uiBlcLen;\n            uiLenTmp -= uiBlcLen;\n        }\n\n        if (uiLenTmp != 0)\n        {\n            pstCtx->blocklen = (uint32_t)uiLenTmp;\n            err = memcpy_s((uint8_t *)pstCtx->block, SHA256_BLOCK_SIZE, pucSrc, uiLenTmp);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return;\n            }\n        }\n        return;\n    }": "515", "void vosSha256Hash(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiBlcLen = 0;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        if ((pucSrc == NULL) || (uiLenTmp == 0) || (pstCtx == NULL) || (pstCtx->corrupted == 1) ||\n            (pstCtx->computed == 1) || (vosSha256CtxPrepare(pstCtx, uiLenTmp) != SHA256_OK))\n        {\n            return;\n        }\n\n        if (pstCtx->blocklen != 0)\n        {\n            if (vosSha256LastPadding(pucSrc, uiLenTmp, pstCtx, &uiBlcLen) == SHA256_OK)\n            {\n                pucSrc += uiBlcLen;\n                uiLenTmp -= uiBlcLen;\n            }\n            else\n            {\n                return;\n            }\n        }\n\n        vosSha256HashByBlcMulti(pucSrc, uiLenTmp, pstCtx);\n        return;\n    }": "516", "void vosSha256End(uint8_t *pucOut, uint32_t uiOutSize, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiIndex;\n        uint8_t *pucBlock = NULL;\n        uint32_t uiBlcLen;\n\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        pucBlock = (uint8_t *)pstCtx->block;\n        uiBlcLen = pstCtx->blocklen;\n\n        if ((pstCtx->corrupted == 1) || (uiOutSize < pstCtx->outlen))\n        {\n            (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n            return;\n        }\n\n        if (pstCtx->computed == 0)\n        {\n            pucBlock[uiBlcLen++] = 0x80;\n            if (uiBlcLen > (SHA256_BLOCK_SIZE - 8))\n            {\n                (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0, SHA256_BLOCK_SIZE - uiBlcLen);\n                uiBlcLen = 0;\n                vosSha256CompressMul(pstCtx, pucBlock, 1);\n            }\n\n            (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0, SHA256_BLOCK_SIZE - 8 - uiBlcLen);\n\n            pucBlock += SHA256_BLOCK_SIZE - 8;\n            PUT_UINT32_BE(pstCtx->N[1], pucBlock, 0);\n            pucBlock += sizeof(uint32_t);\n            PUT_UINT32_BE(pstCtx->N[0], pucBlock, 0);\n            pucBlock += sizeof(uint32_t);\n            pucBlock -= SHA256_BLOCK_SIZE;\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n            pstCtx->computed = 1;\n        }\n\n        uiBlcLen = ((pstCtx->outlen <= uiOutSize) ? pstCtx->outlen : uiOutSize) / sizeof(uint32_t);\n        if (pucOut != NULL)\n        {\n            for (uiIndex = 0; uiIndex < uiBlcLen; uiIndex++)\n            {\n                PUT_UINT32_BE(pstCtx->h[uiIndex], pucOut, sizeof(uint32_t) * uiIndex);\n            }\n        }\n\n        return;\n    }": "517", "static void vosSha256CompressBlock(uint32_t state[VOS_SHA256_CTX_HASH_LEN], const uint8_t block[SHA256_BLOCK_SIZE])\n    {\n        uint32_t W[64];\n        uint32_t i, j;\n        uint32_t a, b, c, d, e, f, g, h;\n\n        for (i = 0; i < 16; i++)\n        {\n            W[i] = GET_UINT32_BE(block, 4 * (i));\n        }\n\n        for (i = 16; i < 64; i++)\n        {\n            W[i] = W[i - 16] + W[i - 7] + (VOS_ROTR32(W[i - 15], 7) ^ VOS_ROTR32(W[i - 15], 18) ^ (W[i - 15] >> 3)) +\n                   (VOS_ROTR32(W[i - 2], 17) ^ VOS_ROTR32(W[i - 2], 19) ^ (W[i - 2] >> 10));\n        }\n\n        j = 0;\n        a = state[j++];\n        b = state[j++];\n        c = state[j++];\n        d = state[j++];\n        e = state[j++];\n        f = state[j++];\n        g = state[j++];\n        h = state[j];\n\n        for (i = 0; i < 64; i += 8)\n        {\n            j = 0;\n            VOS_ROUND(a, b, c, d, e, f, g, h, i + (j++), K256[i + 0], W);\n            VOS_ROUND(h, a, b, c, d, e, f, g, i + (j++), K256[i + 1], W);\n            VOS_ROUND(g, h, a, b, c, d, e, f, i + (j++), K256[i + 2], W);\n            VOS_ROUND(f, g, h, a, b, c, d, e, i + (j++), K256[i + 3], W);\n            VOS_ROUND(e, f, g, h, a, b, c, d, i + (j++), K256[i + 4], W);\n            VOS_ROUND(d, e, f, g, h, a, b, c, i + (j++), K256[i + 5], W);\n            VOS_ROUND(c, d, e, f, g, h, a, b, i + (j++), K256[i + 6], W);\n            VOS_ROUND(b, c, d, e, f, g, h, a, i + j, K256[i + 7], W);\n        }\n\n        j = 0;\n        state[j++] += a;\n        state[j++] += b;\n        state[j++] += c;\n        state[j++] += d;\n        state[j++] += e;\n        state[j++] += f;\n        state[j++] += g;\n        state[j] += h;\n    }": "518", "static void vosSha256CompressMul(VOS_SHA256_CTX *pstCtx, const uint8_t *pucInput, uint32_t uiNum)\n    {\n        uint32_t uiNumTmp = uiNum;\n        const uint8_t *pucBlock = pucInput;\n\n        while ((uiNumTmp--) != 0)\n        {\n            vosSha256CompressBlock(pstCtx->h, pucBlock);\n            pucBlock += SHA256_BLOCK_SIZE;\n        }\n    }": "519", "void VOS_Sha256Calc(const uint8_t *pucInput, uint32_t uiInputLen, uint8_t *pucOutput, uint32_t uiOutputLen)\n    {\n        VOS_SHA256_CTX stCtx;\n\n        vosSha256Begin(&stCtx);\n        vosSha256Hash(pucInput, uiInputLen, &stCtx);\n        vosSha256End(pucOutput, uiOutputLen, &stCtx);\n    }": "520"}