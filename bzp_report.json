{
    "All": 92,
    "Compilation Pass": 85,
    "Compilation Error": 7,
    "Pass Rate": 0.9239130434782609,
    "Error Information": [
        {
            "c_code": "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
            "rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman);\n    BzpHeapInit(huffman);\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1) {\n        idx1 = huffman.heap[1];\n        let tmp0 = 1;\n        huffman.heap[tmp0];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        idx2 = huffman.heap[1];\n        huffman.heap[1] = huffman.heap[huffman.nHeap];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        let tmp0 = huffman.nWeight;\n        let tmp1 = idx1;\n        huffman.weight[tmp0] = BzpHuffmanWeightAdd(huffman.weight[tmp1]);\n        huffman.parent[idx1] = huffman.nWeight;\n        huffman.parent[idx2] = huffman.nWeight;\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight;\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n    }\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612312074)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:40\n   |\n81 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                           -------     -^^^^^^^-------\n   |                           |           ||\n   |                           |           |immutable borrow occurs here\n   |                           |           mutable borrow later used here\n   |                           mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:40\n   |\n81 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:39\n   |\n81 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                       ^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:40\n   |\n85 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                           -------     -^^^^^^^-------\n   |                           |           ||\n   |                           |           |immutable borrow occurs here\n   |                           |           mutable borrow later used here\n   |                           mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:40\n   |\n85 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:39\n   |\n85 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                       ^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:24\n   |\n88 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:24\n   |\n88 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:23\n   |\n88 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:24\n   |\n91 |         huffman.parent[huffman.nWeight] = -1;\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:24\n   |\n91 |         huffman.parent[huffman.nWeight] = -1;\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:23\n   |\n91 |         huffman.parent[huffman.nWeight] = -1;\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:22\n   |\n93 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |         -------     -^^^^^^^-------\n   |         |           ||\n   |         |           |immutable borrow occurs here\n   |         |           mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:22\n   |\n93 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                      ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:21\n   |\n93 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                     ^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n",
            "optimized_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman);\n    BzpHeapInit(huffman);\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1) {\n        idx1 = huffman.heap[1];\n        let tmp0 = 1;\n        huffman.heap[tmp0];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        idx2 = huffman.heap[1];\n        huffman.heap[1] = huffman.heap[huffman.nHeap];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        let tmp0 = huffman.nWeight;\n        let tmp1 = idx1;\n        huffman.weight[tmp0] = BzpHuffmanWeightAdd(huffman.weight[tmp1]);\n        huffman.parent[idx1] = huffman.nWeight;\n        huffman.parent[idx2] = huffman.nWeight;\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight;\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612344235)\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:32\n   |\n91 |         huffman.weight[tmp0] = BzpHuffmanWeightAdd(huffman.weight[tmp1]);\n   |                                ^^^^^^^^^^^^^^^^^^^---------------------- argument #2 of type `i32` is missing\n   |\nnote: function defined here\n  --> src/src/compress/bzp_huffman_encode_c.rs:69:8\n   |\n69 | pub fn BzpHuffmanWeightAdd(mut w1: i32, mut w2: i32) -> i32 {\n   |        ^^^^^^^^^^^^^^^^^^^ -----------  -----------\nhelp: provide the argument\n   |\n91 |         huffman.weight[tmp0] = BzpHuffmanWeightAdd(huffman.weight[tmp1], /* i32 */);\n   |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information about this error, try `rustc --explain E0061`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed)\n    {\n        (void)memset_s(huffman->cost, sizeof(huffman->cost), 0, sizeof(huffman->cost));\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = st; k <= ed; k++)\n        {\n            for (int32_t t = 0; t < nGroups; t++)\n            {\n                huffman->cost[t] += huffman->huffmanGroups[t].len[huffman->block[k]];\n            }\n        }\n    }",
            "rust_code": "pub fn BzpCalculateCost(mut huffman: Ptr<BzpHuffmanGroups>, mut st: i32, mut ed: i32) {\n    c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n        c_for!(let mut t: i32 = 0; t < nGroups; t.suffix_plus_plus(); {\n            let tmp0 = t;\n            let tmp1 = huffman.block[k;\n            huffman.cost[tmp0].len[tmp1]];\n        });\n    });\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612429223)\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:291:79\n    |\n291 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n    |                             -- type must be known at this point               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\n    = note: multiple `impl`s satisfying `i32: std::ops::AddAssign<_>` found in the `core` crate:\n            - impl std::ops::AddAssign for i32;\n            - impl std::ops::AddAssign<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n291 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast::<T>();\n    |                                                                                   +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
            "optimized_code": "pub fn BzpCalculateCost(mut huffman: Ptr<BzpHuffmanGroups>, mut st: i32, mut ed: i32) {\n    c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n        c_for!(let mut t: i32 = 0; t < nGroups; t.suffix_plus_plus(); {\n            let tmp0 = t;\n            let tmp1 = huffman.block[k;\n            huffman.cost[tmp0].len[tmp1]];\n        });\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612443458)\nerror: expected one of `!`, `.`, `::`, `?`, `]`, `{`, or an operator, found `;`\n   --> src/src/compress/bzp_huffman_encode_c.rs:292:39\n    |\n292 |             let tmp1 = huffman.block[k;\n    |                                       ^ expected one of 7 possible tokens\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }",
            "rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        let tmp0 = k;\n        if (huffman.cost[tmp0]) {\n            id = k;\n        }\n    });\n    huffman.select[huffman.nSelect] = id;\n    huffman.nSelect += 1;\n    return id;\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612443641)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_huffman_encode_c.rs:299:20\n    |\n299 |     huffman.select[huffman.nSelect] = id.cast();\n    |     -------       -^^^^^^^---------\n    |     |             ||\n    |     |             |immutable borrow occurs here\n    |     |             mutable borrow later used here\n    |     mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_huffman_encode_c.rs:299:20\n    |\n299 |     huffman.select[huffman.nSelect] = id.cast();\n    |                    ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_huffman_encode_c.rs:299:19\n    |\n299 |     huffman.select[huffman.nSelect] = id.cast();\n    |                   ^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
            "optimized_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        let tmp0 = k;\n        if (huffman.cost[tmp0]) {\n            id = k;\n        }\n    });\n    huffman.select[huffman.nSelect] = id;\n    huffman.nSelect += 1;\n    return id;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612457151)\nerror[E0308]: mismatched types\n   --> src/src/compress/bzp_huffman_encode_c.rs:296:12\n    |\n296 |         if (huffman.cost[tmp0]) {\n    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "void BzpHuffmanMain(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n        huffman->nGroups = nGroups;\n\n        BzpInitLenArray(huffman);\n        int32_t st = 0, ed;\n\n        for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++)\n        {\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                (void)memset_s(huffman->huffmanGroups[j].weight, sizeof(huffman->huffmanGroups[j].weight), 0,\n                               sizeof(huffman->huffmanGroups[j].weight));\n            }\n\n            st = 0;\n            huffman->nSelect = 0;\n            while (st < huffman->nBlock)\n            {\n                ed = BZP_MIN_FUN(huffman->nBlock, st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) - 1;\n\n                BzpCalculateCost(huffman, st, ed);\n\n                int32_t id = BzpSelectTree(huffman);\n\n                for (int32_t k = st; k <= ed; k++)\n                {\n                    huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n                }\n                st = ed + 1;\n            }\n\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n            }\n        }\n\n        BzpGenerateSelectMTF(huffman);\n\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n        }\n    }",
            "rust_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock);\n    huffman.nGroups = nGroups;\n\n    BzpInitLenArray(huffman);\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0, c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock) {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman, st, ed);\n\n            let mut id: i32 = BzpSelectTree(huffman);\n\n            let block_k = huffman.block[k];\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[block_k] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]));\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman);\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]));\n    });\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612457341)\nerror[E0284]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:312:82\n    |\n312 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\n    = note: cannot satisfy `<i32 as std::ops::Add<_>>::Output == i32`\nhelp: consider specifying the generic argument\n    |\n312 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:312:82\n    |\n312 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\nnote: multiple `impl`s satisfying `i32: std::ops::Add<_>` found\n   --> src/translation_utils/types/num.rs:112:1\n    |\n112 | impl Add<Num> for i32 {\n    | ^^^^^^^^^^^^^^^^^^^^^\n    = note: and more `impl`s found in the following crates: `core`:\n            - impl std::ops::Add for i32;\n            - impl std::ops::Add<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n312 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
            "optimized_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock);\n    huffman.nGroups = nGroups;\n\n    BzpInitLenArray(huffman);\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0, c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock) {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman, st, ed);\n\n            let mut id: i32 = BzpSelectTree(huffman);\n\n            let block_k = huffman.block[k];\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[block_k] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]));\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman);\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]));\n    });\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612513120)\nerror[E0425]: cannot find value `k` in this scope\n   --> src/src/compress/bzp_huffman_encode_c.rs:318:41\n    |\n318 |             let block_k = huffman.block[k];\n    |                                         ^ help: a tuple variant with a similar name exists: `Ok`\n   --> /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/result.rs:532:5\n    |\n    = note: similarly named tuple variant `Ok` defined here\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
        },
        {
            "c_code": "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }",
            "rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8;\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i];\n        if (inData.num == BZP_RLC_NUM_4!()) {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData);\n            });\n            inData.lasChar = BZP_ASCII_SIZE!();\n            inData.num = 0;\n        } else if (ch == inData.lasChar) {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()) {\n            break;\n        }\n    });\n    return ret;\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612553522)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:250:26\n    |\n250 |         } else if (ch == inData.lasChar).as_bool() {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n250 |         } else if (i32::from(ch) == inData.lasChar).as_bool() {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n",
            "optimized_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8;\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i];\n        if (inData.num == BZP_RLC_NUM_4!()) {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData);\n            });\n            inData.lasChar = BZP_ASCII_SIZE!();\n            inData.num = 0;\n        } else if (ch == inData.lasChar) {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()) {\n            break;\n        }\n    });\n    return ret;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612584521)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:245:17\n    |\n245 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:250:26\n    |\n250 |         } else if (ch == inData.lasChar) {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n250 |         } else if (i32::from(ch) == inData.lasChar) {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:251:13\n    |\n251 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:255:13\n    |\n255 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
        },
        {
            "c_code": "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }",
            "rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()) || (num > BZP_RLC_NUM_UPPER_LIMIT!()) {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!());\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            let tmp0 = bwt.nBlock.suffix_plus_plus();\n            bwt.block[tmp0] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()) {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612721646)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:334:18\n    |\n334 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n",
            "optimized_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()) || (num > BZP_RLC_NUM_UPPER_LIMIT!()) {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!());\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            let tmp0 = bwt.nBlock.suffix_plus_plus();\n            bwt.block[tmp0] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()) {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612748863)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:334:18\n    |\n334 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:84\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                    ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:82\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                                  ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:38\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ i32`\n   --> src/src/public/bzp_stream_utils_h.rs:186:36\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ (*g_bzpCRC32Table.lock())[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                    ^ no implementation for `u32 ^ i32`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:330:9\n    |\n330 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<i32>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
        },
        {
            "c_code": "void BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata)\n    {\n\n        while (!BZP_BLOCK_FULL(bwt) && !BZP_BUFF_READ_EMPTY(bzpf))\n        {\n            int32_t pos = bzpf->input->pos;\n            uint8_t ch = (uint8_t)bzpf->input->buf[pos];\n            uint8_t lasch = (uint8_t)bzpf->lasChar;\n            if (ch != lasch || bzpf->num == BZP_RLC_NUM_UPPER_LIMIT)\n            {\n                BzpAddCharToBlock(lasch, bzpf->num, bwt);\n                bzpf->lasChar = ch;\n                bzpf->num = 1;\n            }\n            else\n            {\n                bzpf->num++;\n            }\n\n            bzpf->input->pos++;\n        }\n\n        if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n        {\n\n            BzpAddCharToBlock(bzpf->lasChar, bzpf->num, bwt);\n            bzpf->lasChar = BZP_ASCII_SIZE;\n            bzpf->num = 0;\n        }\n    }",
            "rust_code": "pub fn BzpBuffToBlockRLC(mut bzpf: Ptr<BzpFile>, mut bwt: Ptr<BzpBwtInfo>, mut IsLastdata: bool) {\n    while (!BZP_BLOCK_FULL!(bwt) && !(bzpf.input.pos >= bzpf.input.nBuf)) {\n        let mut pos: i32 = bzpf.input.pos;\n        let mut ch: u8 = bzpf.input.buf[pos].cast::<u8>();\n        let mut lasch: u8 = bzpf.lasChar.cast::<u8>();\n        if (ch != lasch) || (bzpf.num == BZP_RLC_NUM_UPPER_LIMIT) {\n            BzpAddCharToBlock(lasch, bzpf.num, bwt);\n            bzpf.lasChar = ch.cast();\n            bzpf.num = 1;\n        } else {\n            bzpf.num += 1;\n        }\n        bzpf.input.pos += 1;\n    }\n    if (IsLastdata && (bzpf.input.pos >= bzpf.input.nBuf)) {\n        BzpAddCharToBlock(bzpf.lasChar.cast(), bzpf.num, bwt);\n        bzpf.lasChar = BZP_ASCII_SIZE;\n        bzpf.num = 0;\n    }\n}\n",
            "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612749096)\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:331:48\n    |\n331 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:331:48\n    |\n331 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:68\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                    ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:33\n    |\n344 |     if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                 -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `lock` found for struct `memory::ptr::Ptr<bzp_stream_utils_h::BzpStream>` in the current scope\n   --> src/src/public/bzp_stream_utils_h.rs:180:97\n    |\n180 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { (*$bzpf.input.lock()).pos >= (*$bzpf.input.lock()).nBuf } }\n    |                                                                                                 ^^^^ method not found in `Ptr<BzpStream>`\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `lock` not found for this struct\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:33\n    |\n344 |     if (IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                 -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n",
            "optimized_code": "pub fn BzpBuffToBlockRLC(mut bzpf: Ptr<BzpFile>, mut bwt: Ptr<BzpBwtInfo>, mut IsLastdata: bool) {\n    while (!BZP_BLOCK_FULL!(bwt) && !(bzpf.input.pos >= bzpf.input.nBuf)) {\n        let mut pos: i32 = bzpf.input.pos;\n        let mut ch: u8 = bzpf.input.buf[pos].cast::<u8>();\n        let mut lasch: u8 = bzpf.lasChar.cast::<u8>();\n        if (ch != lasch) || (bzpf.num == BZP_RLC_NUM_UPPER_LIMIT) {\n            BzpAddCharToBlock(lasch, bzpf.num, bwt);\n            bzpf.lasChar = ch.cast();\n            bzpf.num = 1;\n        } else {\n            bzpf.num += 1;\n        }\n        bzpf.input.pos += 1;\n    }\n    if (IsLastdata && (bzpf.input.pos >= bzpf.input.nBuf)) {\n        BzpAddCharToBlock(bzpf.lasChar.cast(), bzpf.num, bwt);\n        bzpf.lasChar = BZP_ASCII_SIZE;\n        bzpf.num = 0;\n    }\n}\n",
            "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/RepoC2Rust/created_project/bzp_1744612792993)\nerror[E0423]: expected value, found macro `BZP_RLC_NUM_UPPER_LIMIT`\n   --> src/src/public/bzp_compress_stream_c.rs:335:42\n    |\n335 |         if (ch != lasch) || (bzpf.num == BZP_RLC_NUM_UPPER_LIMIT) {\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `BZP_ASCII_SIZE`\n   --> src/src/public/bzp_compress_stream_c.rs:346:24\n    |\n346 |         bzpf.lasChar = BZP_ASCII_SIZE;\n    |                        ^^^^^^^^^^^^^^ not a value\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
        }
    ]
}